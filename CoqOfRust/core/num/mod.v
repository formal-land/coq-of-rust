(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module Impl_i8.
    Definition Self : Ty.t := Ty.path "i8".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "i8" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "i8" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i8" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "i8" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "i8" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i8" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "i8" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "i8" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i8", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "i8",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "i8",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "u8", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i8" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i8", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "i8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i8", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i8",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i8",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.I8 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.I8, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i8",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i8",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "i8", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.I8
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.I8 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.I8 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (| BinOp.Wrap.div Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.I8
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.I8
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i8", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.I8 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.I8 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (| BinOp.Wrap.rem Integer.I8 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I8 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.I8
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.I8 (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I8 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.I8 (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i8", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i8", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "i8", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.I8
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i8", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div Integer.I8 (M.read (| β |)) (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "i8" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i8", [] |),
                            [ M.read (| M.use self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.I8, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u8", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u8", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "i8"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i8", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "i8" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_i8.
  
  Module Impl_i16.
    Definition Self : Ty.t := Ty.path "i16".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "i16" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "i16" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i16" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "i16" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "i16" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i16" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "i16" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "i16" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i16", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "i16",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "i16",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "u16", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i16" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i16", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "i16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i16", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i16",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i16",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.I16 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.I16 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.I16, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i16",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i16",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "i16", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.I16
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.I16 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.I16 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (| BinOp.Wrap.div Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem
                                    Integer.I16
                                    (M.read (| self |))
                                    (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.I16
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.I16
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i16", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.I16 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.I16 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (| BinOp.Wrap.rem Integer.I16 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I16 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.I16
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.I16 (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I16 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.I16 (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i16", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i16", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "i16", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.I16
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i16", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.I16
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "i16" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i16", [] |),
                            [ M.read (| M.use self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.I16, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u16", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u16", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "i16"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i16", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "i16" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_i16.
  
  Module Impl_i32.
    Definition Self : Ty.t := Ty.path "i32".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "i32" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "i32" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i32" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "i32" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "i32" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i32" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "i32" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "i32" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i32", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "i32",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "i32",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "u32", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i32" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i32", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "i32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i32", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i32",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i32",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.I32 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.I32 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.I32, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i32",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i32",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "i32", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.I32
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.I32 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.I32 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (| BinOp.Wrap.div Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem
                                    Integer.I32
                                    (M.read (| self |))
                                    (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.I32
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.I32
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i32", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.I32 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.I32 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (| BinOp.Wrap.rem Integer.I32 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I32 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.I32
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.I32 (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I32 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.I32 (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i32", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "i32", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.I32
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i32", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.I32
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "i32" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i32", [] |),
                            [ M.read (| M.use self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.I32, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u32", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u32", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "i32"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i32", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "i32" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_i32.
  
  Module Impl_i64.
    Definition Self : Ty.t := Ty.path "i64".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "i64" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "i64" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i64" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "i64" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "i64" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i64" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "i64" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "i64" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i64", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "i64",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "i64",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "u64", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i64" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i64", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "i64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i64", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i64",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i64",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.I64 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.I64 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.I64, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i64",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i64",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "i64", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.I64
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.I64 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.I64 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (| BinOp.Wrap.div Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem
                                    Integer.I64
                                    (M.read (| self |))
                                    (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.I64
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.I64
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i64", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.I64 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.I64 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (| BinOp.Wrap.rem Integer.I64 (M.read (| self |)) (M.read (| rhs |)) |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I64 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.I64
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.I64 (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I64 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.I64 (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i64", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i64", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "i64", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.I64
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i64", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.I64
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "i64" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i64", [] |),
                            [ M.read (| M.use self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.I64, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u64", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u64", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "i64"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i64", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "i64" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_i64.
  
  Module Impl_i128.
    Definition Self : Ty.t := Ty.path "i128".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "i128" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "i128" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i128" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "i128" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "i128" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "i128" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "i128" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "i128" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i128", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "i128",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "i128",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "i128" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i128", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "i128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i128", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i128",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i128",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.I128 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.I128 (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.I128, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "i128",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i128",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "i128", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.I128
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul
                                    Integer.I128
                                    (M.read (| base |))
                                    (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.I128 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (|
                    BinOp.Wrap.div Integer.I128 (M.read (| self |)) (M.read (| rhs |))
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem
                                    Integer.I128
                                    (M.read (| self |))
                                    (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.I128
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.I128
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I128 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "i128", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I128 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I128 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.I128 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.I128 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.I128 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.I128 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (|
                    BinOp.Wrap.rem Integer.I128 (M.read (| self |)) (M.read (| rhs |))
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I128 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.I128
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.I128 (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.I128 (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.I128 (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "i128", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i128", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "i128", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.I128
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "i128", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.I128
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "i128" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i128", [] |),
                            [ M.read (| M.use self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.I128, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u128", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u128", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "i128"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "i128", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "i128" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_i128.
  
  Module Impl_isize.
    Definition Self : Ty.t := Ty.path "isize".
    
    (*         pub const MIN: Self = !Self::MAX; *)
    (* Ty.path "isize" *)
    Definition value_MIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| UnOp.Pure.not (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self; *)
    (* Ty.path "isize" *)
    Definition value_MAX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.rust_cast
              (BinOp.Wrap.shr
                (M.read (| M.get_constant (| "core::num::MAX" |) |))
                (Value.Integer 1))
          |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = <$UnsignedT>::BITS; *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "isize" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*         pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() } *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "count_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                (self as $UnsignedT).leading_zeros()
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "leading_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                (self as $UnsignedT).trailing_zeros()
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "trailing_zeros", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (self as $UnsignedT).leading_ones()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "leading_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (self as $UnsignedT).trailing_ones()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "trailing_ones", [] |),
            [ M.rust_cast (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_left(n) as Self
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "rotate_left", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                (self as $UnsignedT).rotate_right(n) as Self
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "rotate_right", [] |),
              [ M.rust_cast (M.read (| self |)); M.read (| n |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                (self as $UnsignedT).swap_bytes() as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "swap_bytes", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                (self as $UnsignedT).reverse_bits() as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "reverse_bits", [] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_unsigned :
      M.IsAssociatedFunction Self "checked_add_unsigned" checked_add_unsigned.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
                let (a, b) = self.overflowing_sub_unsigned(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub_unsigned :
      M.IsAssociatedFunction Self "checked_sub_unsigned" checked_sub_unsigned.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "isize" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {
                    None
                } else {
                    // SAFETY: div by zero and by INT_MIN have been checked above
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (LogicalOp.and (|
                                    BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))))
                                  |)))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "isize" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              LogicalOp.or (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.bit_and
                                    (BinOp.Pure.eq
                                      (M.read (| self |))
                                      (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                    (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))))
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const unsafe fn unchecked_neg(self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_neg`.
                unsafe { intrinsics::unchecked_sub(0, self) }
            }
    *)
    Definition unchecked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "isize" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_neg :
      M.IsAssociatedFunction Self "unchecked_neg" unchecked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "isize" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "isize" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_abs(self) -> Option<Self> {
                if self.is_negative() {
                    self.checked_neg()
                } else {
                    Some(self)
                }
            }
    *)
    Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "isize", "checked_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "isize",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "isize",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn checked_isqrt(self) -> Option<Self> {
                if self < 0 {
                    None
                } else {
                    Some((self as $UnsignedT).isqrt() as Self)
                }
            }
    *)
    Definition checked_isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (| Ty.path "usize", "isqrt", [] |),
                              [ M.rust_cast (M.read (| self |)) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_isqrt :
      M.IsAssociatedFunction Self "checked_isqrt" checked_isqrt.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the upper bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_add_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "checked_add_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_unsigned :
      M.IsAssociatedFunction Self "saturating_add_unsigned" saturating_add_unsigned.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                // Overflow can only happen at the lower bound
                // We cannot use `unwrap_or` here because it is not `const`
                match self.checked_sub_unsigned(rhs) {
                    Some(x) => x,
                    None => Self::MIN,
                }
            }
    *)
    Definition saturating_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "checked_sub_unsigned", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub_unsigned :
      M.IsAssociatedFunction Self "saturating_sub_unsigned" saturating_sub_unsigned.
    
    (*
            pub const fn saturating_neg(self) -> Self {
                intrinsics::saturating_sub(0, self)
            }
    *)
    Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "isize" ] |),
            [ Value.Integer 0; M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_neg :
      M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
    
    (*
            pub const fn saturating_abs(self) -> Self {
                if self.is_negative() {
                    self.saturating_neg()
                } else {
                    self
                }
            }
    *)
    Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "isize", "saturating_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_abs :
      M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => if (self < 0) == (rhs < 0) {
                        Self::MAX
                    } else {
                        Self::MIN
                    }
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "core::num::MAX" |)));
                        fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MIN" |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                match self.overflowing_div(rhs) {
                    (result, false) => result,
                    (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow
                }
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    result));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _result := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None if self < 0 && exp % 2 == 1 => Self::MIN,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let γ :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (BinOp.Wrap.rem Integer.U32 (M.read (| exp |)) (Value.Integer 2))
                          (Value.Integer 1)
                      |) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MIN" |)));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_unsigned :
      M.IsAssociatedFunction Self "wrapping_add_unsigned" wrapping_add_unsigned.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {
                self.wrapping_sub(rhs as Self)
            }
    *)
    Definition wrapping_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub_unsigned :
      M.IsAssociatedFunction Self "wrapping_sub_unsigned" wrapping_sub_unsigned.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "isize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self.overflowing_div(rhs).0
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_div", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self.overflowing_div_euclid(rhs).0
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_div_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self.overflowing_rem(rhs).0
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_rem", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self.overflowing_rem_euclid(rhs).0
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_rem_euclid", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_abs(self) -> Self {
                 if self.is_negative() {
                     self.wrapping_neg()
                 } else {
                     self
                 }
            }
    *)
    Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "isize", "wrapping_neg", [] |),
                        [ M.read (| self |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_abs : M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
    
    (*
            pub const fn unsigned_abs(self) -> $UnsignedT {
                 self.wrapping_abs() as $UnsignedT
            }
    *)
    Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "wrapping_abs", [] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unsigned_abs : M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "isize",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "isize",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "i64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b != d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_add(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_unsigned :
      M.IsAssociatedFunction Self "overflowing_add_unsigned" overflowing_add_unsigned.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "i64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic.
                // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b != d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [ M.read (| c |); BinOp.Pure.ne (M.read (| b |)) (M.read (| d |)) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
                let rhs = rhs as Self;
                let (res, overflowed) = self.overflowing_sub(rhs);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_sub_unsigned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs := M.alloc (| M.rust_cast (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub_unsigned :
      M.IsAssociatedFunction Self "overflowing_sub_unsigned" overflowing_sub_unsigned.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "i64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self / rhs, false)
                }
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.div Integer.Isize (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                // Using `&` helps LLVM see that it is the same check made in division.
                if unlikely!((self == Self::MIN) & (rhs == -1)) {
                    (self, true)
                } else {
                    (self.div_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.bit_and
                                (BinOp.Pure.eq
                                  (M.read (| self |))
                                  (M.read (| M.get_constant (| "core::num::MIN" |) |)))
                                (BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self % rhs, false)
                }
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.rem Integer.Isize (M.read (| self |)) (M.read (| rhs |));
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                if unlikely!(rhs == -1) {
                    (0, self == Self::MIN)
                } else {
                    (self.rem_euclid(rhs), false)
                }
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          Value.Integer 0;
                          BinOp.Pure.eq
                            (M.read (| self |))
                            (M.read (| M.get_constant (| "core::num::MIN" |) |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |);
                          Value.Bool false
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                if unlikely!(self == Self::MIN) {
                    (Self::MIN, true)
                } else {
                    (-self, false)
                }
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [
                              BinOp.Pure.eq
                                (M.read (| self |))
                                (M.read (| M.get_constant (| "core::num::MIN" |) |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.get_constant (| "core::num::MIN" |) |); Value.Bool true ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.Tuple
                        [ UnOp.Panic.neg (| Integer.Isize, M.read (| self |) |); Value.Bool false ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_abs(self) -> (Self, bool) {
                (self.wrapping_abs(), self == Self::MIN)
            }
    *)
    Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "wrapping_abs", [] |),
                [ M.read (| self |) ]
              |);
              BinOp.Pure.eq (M.read (| self |)) (M.read (| M.get_constant (| "core::num::MIN" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_abs :
      M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0 {
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "isize",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "isize",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "isize", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.Isize
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul
                                    Integer.Isize
                                    (M.read (| base |))
                                    (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.Isize (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                // I would like to implement it as
                // ```
                // self.checked_isqrt().expect("argument of integer square root must be non-negative")
                // ```
                // but `expect` is not yet stable as a `const fn`.
                match self.checked_isqrt() {
                    Some(sqrt) => sqrt,
                    None => panic!("argument of integer square root must be non-negative"),
                }
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "checked_isqrt", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let sqrt := M.copy (| γ0_0 |) in
                    sqrt));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "argument of integer square root must be non-negative"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                let q = self / rhs;
                if self % rhs < 0 {
                    return if rhs > 0 { q - 1 } else { q + 1 }
                }
                q
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ q :=
                  M.alloc (|
                    BinOp.Wrap.div Integer.Isize (M.read (| self |)) (M.read (| rhs |))
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (BinOp.Wrap.rem
                                    Integer.Isize
                                    (M.read (| self |))
                                    (M.read (| rhs |)))
                                  (Value.Integer 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              BinOp.Wrap.sub
                                                Integer.Isize
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              BinOp.Wrap.add
                                                Integer.Isize
                                                (M.read (| q |))
                                                (Value.Integer 1)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                q
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                let r = self % rhs;
                if r < 0 {
                    // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.
                    // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow
                    // and is clearly equivalent, because `r` is negative.
                    // Otherwise, `rhs` is `Self::MIN`, then we have
                    // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates
                    // to `r.wrapping_add(Self::MIN)`, which is equivalent to
                    // `r - Self::MIN`, which is what we wanted (and will not overflow
                    // for negative `r`).
                    r.wrapping_add(rhs.wrapping_abs())
                } else {
                    r
                }
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.Isize (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "isize", "wrapping_add", [] |),
                        [
                          M.read (| r |);
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "wrapping_abs", [] |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic r)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    d - 1
                } else {
                    d
                }
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.Isize (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.Isize (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.sub Integer.Isize (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.Isize (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.Isize (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            LogicalOp.and (|
                              BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                              ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                              |)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.Isize (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return self;
                }
    
                let r = self % rhs;
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    self
                } else {
                    self + (rhs - m)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.alloc (|
                    BinOp.Wrap.rem Integer.Isize (M.read (| self |)) (M.read (| rhs |))
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.Isize (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        self));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.add
                            Integer.Isize
                            (M.read (| self |))
                            (BinOp.Wrap.sub Integer.Isize (M.read (| rhs |)) (M.read (| m |)))
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                // This would otherwise fail when calculating `r` when self == T::MIN.
                if rhs == -1 {
                    return Some(self);
                }
    
                let r = try_opt!(self.checked_rem(rhs));
                let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {
                    // r + rhs cannot overflow because they have opposite signs
                    r + rhs
                } else {
                    r
                };
    
                if m == 0 {
                    Some(self)
                } else {
                    // rhs - m cannot overflow because m has the same sign as rhs
                    self.checked_add(rhs - m)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer (-1))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| self |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ r :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "checked_rem", [] |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let x := M.copy (| γ0_0 |) in
                            x));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ m :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.and (|
                                      BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0)))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.lt (M.read (| r |)) (Value.Integer 0),
                                        ltac:(M.monadic
                                          (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.add Integer.Isize (M.read (| r |)) (M.read (| rhs |))
                            |)));
                        fun γ => ltac:(M.monadic r)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use (M.alloc (| BinOp.Pure.eq (M.read (| m |)) (Value.Integer 0) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.Isize (M.read (| rhs |)) (M.read (| m |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn midpoint(self, rhs: Self) -> Self {
                const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();
    
                // Map an $SelfT to an $UnsignedT
                // ex: i8 [-128; 127] to [0; 255]
                const fn map(a: $SelfT) -> $UnsignedT {
                    (a as $UnsignedT) ^ U
                }
    
                // Map an $UnsignedT to an $SelfT
                // ex: u8 [0; 255] to [-128; 127]
                const fn demap(a: $UnsignedT) -> $SelfT {
                    (a ^ U) as $SelfT
                }
    
                demap(<$UnsignedT>::midpoint(map(self), map(rhs)))
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Self, "demap.midpoint", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "midpoint", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (| Self, "map.midpoint", [] |),
                    [ M.read (| rhs |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "isize", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "isize", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "isize",
                                          "ilog2",
                                          []
                                        |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.Isize
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "isize", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.Isize
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if self <= 0 {
                    None
                } else {
                    // SAFETY: We just checked that this number is positive
                    let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };
                    Some(log)
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ log :=
                      M.alloc (|
                        BinOp.Wrap.sub
                          Integer.U32
                          (BinOp.Wrap.sub
                            Integer.U32
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 1))
                          (M.rust_cast
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::ctlz_nonzero",
                                [ Ty.path "isize" ]
                              |),
                              [ M.read (| self |) ]
                            |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| log |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if self > 0 {
                    Some(int_log10::$ActualT(self as $ActualT))
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (| "core::num::int_log10::i64", [] |),
                            [ M.rust_cast (M.read (| self |)) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn abs(self) -> Self {
                // Note that the #[rustc_inherit_overflow_checks] and #[inline]
                // above mean that the overflow semantics of the subtraction
                // depend on the crate we're being called from.
                if self.is_negative() {
                    -self
                } else {
                    self
                }
            }
    *)
    Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| UnOp.Panic.neg (| Integer.Isize, M.read (| self |) |) |)));
                fun γ => ltac:(M.monadic self)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
    
    (*
            pub const fn abs_diff(self, other: Self) -> $UnsignedT {
                if self < other {
                    // Converting a non-negative x from signed to unsigned by using
                    // `x as U` is left unchanged, but a negative x is converted
                    // to value x + 2^N. Thus if `s` and `o` are binary variables
                    // respectively indicating whether `self` and `other` are
                    // negative, we are computing the mathematical value:
                    //
                    //    (other + o*2^N) - (self + s*2^N)    mod  2^N
                    //    other - self + (o-s)*2^N            mod  2^N
                    //    other - self                        mod  2^N
                    //
                    // Finally, taking the mod 2^N of the mathematical value of
                    // `other - self` does not change it as it already is
                    // in the range [0, 2^N).
                    (other as $UnsignedT).wrapping_sub(self as $UnsignedT)
                } else {
                    (self as $UnsignedT).wrapping_sub(other as $UnsignedT)
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (M.read (| other |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| other |)); M.rust_cast (M.read (| self |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                        [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn signum(self) -> Self {
                // Picking the right way to phrase this is complicated
                // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)
                // so delegate it to `Ord` which is already producing -1/0/+1
                // exactly like we need and can be the place to deal with the complexity.
    
                // FIXME(const-hack): replace with cmp
                if self < 0 { -1 }
                else if self == 0 { 0 }
                else { 1 }
            }
    *)
    Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer (-1) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| self |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
    
    (*         pub const fn is_positive(self) -> bool { self > 0 } *)
    Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.gt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
    
    (*         pub const fn is_negative(self) -> bool { self < 0 } *)
    Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.lt (M.read (| self |)) (Value.Integer 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "isize"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "isize", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "isize" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*
            pub const fn min_value() -> Self {
                Self::MIN
            }
    *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*
            pub const fn max_value() -> Self {
                Self::MAX
            }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
  End Impl_isize.
  
  Definition value_ASCII_CASE_MASK : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 32 |))).
  
  Module Impl_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "u8" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "u8" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u8" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u8" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u8" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::cttz", [ Ty.path "u8" ] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bswap", [ Ty.path "u8" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u8" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u8", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "u8", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.U8
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u8", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div Integer.U8 (M.read (| β |)) (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU8",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU8",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU8",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU8",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "u8" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "u8" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "u8",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "u8",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "u8" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u8",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u8",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "u8" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.U8 (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.U8 (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u8" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u8",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u8",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u8", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.U8
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.U8 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.U8 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.U8
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.U8
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.U8
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.U8
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.U8 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.U8 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.U8 (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.U8
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.U8 (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u8", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.U8 (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (| BinOp.Wrap.sub Integer.U8 (M.read (| self |)) (Value.Integer 1) |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u8" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.U8
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "one_less_than_next_power_of_two", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "one_less_than_next_power_of_two", [] |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "one_less_than_next_power_of_two", [] |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "u8"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u8", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "u8" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition widening_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_mul", [] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 8))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_widening_mul : M.IsAssociatedFunction Self "widening_mul" widening_mul.
    
    (*
            pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe {
                    (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)
                };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition carrying_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u16", "unchecked_mul", [] |),
                      [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                    |);
                    M.rust_cast (M.read (| carry |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 8))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_mul : M.IsAssociatedFunction Self "carrying_mul" carrying_mul.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                ((self as $WideT + rhs as $WideT) / 2) as $SelfT
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.rust_cast
            (BinOp.Wrap.div
              Integer.U16
              (BinOp.Wrap.add
                Integer.U16
                (M.rust_cast (M.read (| self |)))
                (M.rust_cast (M.read (| rhs |))))
              (Value.Integer 2))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
        pub const fn is_ascii(&self) -> bool {
            *self <= 127
        }
    *)
    Definition is_ascii (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.le (M.read (| M.read (| self |) |)) (Value.Integer 127)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii : M.IsAssociatedFunction Self "is_ascii" is_ascii.
    
    (*
        pub const fn as_ascii(&self) -> Option<ascii::Char> {
            ascii::Char::from_u8( *self)
        }
    *)
    Definition as_ascii (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::ascii::ascii_char::AsciiChar",
              "from_u8",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ascii : M.IsAssociatedFunction Self "as_ascii" as_ascii.
    
    (*
        pub const fn to_ascii_uppercase(&self) -> u8 {
            // Toggle the 6th bit if this is a lowercase letter
            *self ^ ((self.is_ascii_lowercase() as u8) * ASCII_CASE_MASK)
        }
    *)
    Definition to_ascii_uppercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_xor
            (M.read (| M.read (| self |) |))
            (BinOp.Wrap.mul
              Integer.U8
              (M.rust_cast
                (M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "is_ascii_lowercase", [] |),
                  [ M.read (| self |) ]
                |)))
              (M.read (| M.get_constant (| "core::num::ASCII_CASE_MASK" |) |)))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ascii_uppercase :
      M.IsAssociatedFunction Self "to_ascii_uppercase" to_ascii_uppercase.
    
    (*
        pub const fn to_ascii_lowercase(&self) -> u8 {
            // Set the 6th bit if this is an uppercase letter
            *self | (self.is_ascii_uppercase() as u8 * ASCII_CASE_MASK)
        }
    *)
    Definition to_ascii_lowercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_or
            (M.read (| M.read (| self |) |))
            (BinOp.Wrap.mul
              Integer.U8
              (M.rust_cast
                (M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "is_ascii_uppercase", [] |),
                  [ M.read (| self |) ]
                |)))
              (M.read (| M.get_constant (| "core::num::ASCII_CASE_MASK" |) |)))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ascii_lowercase :
      M.IsAssociatedFunction Self "to_ascii_lowercase" to_ascii_lowercase.
    
    (*
        pub(crate) const fn ascii_change_case_unchecked(&self) -> u8 {
            *self ^ ASCII_CASE_MASK
        }
    *)
    Definition ascii_change_case_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_xor
            (M.read (| M.read (| self |) |))
            (M.read (| M.get_constant (| "core::num::ASCII_CASE_MASK" |) |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ascii_change_case_unchecked :
      M.IsAssociatedFunction Self "ascii_change_case_unchecked" ascii_change_case_unchecked.
    
    (*
        pub const fn eq_ignore_ascii_case(&self, other: &u8) -> bool {
            self.to_ascii_lowercase() == other.to_ascii_lowercase()
        }
    *)
    Definition eq_ignore_ascii_case (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "to_ascii_lowercase", [] |),
              [ M.read (| self |) ]
            |))
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "to_ascii_lowercase", [] |),
              [ M.read (| other |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_eq_ignore_ascii_case :
      M.IsAssociatedFunction Self "eq_ignore_ascii_case" eq_ignore_ascii_case.
    
    (*
        pub fn make_ascii_uppercase(&mut self) {
            *self = self.to_ascii_uppercase();
        }
    *)
    Definition make_ascii_uppercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "to_ascii_uppercase", [] |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_make_ascii_uppercase :
      M.IsAssociatedFunction Self "make_ascii_uppercase" make_ascii_uppercase.
    
    (*
        pub fn make_ascii_lowercase(&mut self) {
            *self = self.to_ascii_lowercase();
        }
    *)
    Definition make_ascii_lowercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "to_ascii_lowercase", [] |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_make_ascii_lowercase :
      M.IsAssociatedFunction Self "make_ascii_lowercase" make_ascii_lowercase.
    
    (*
        pub const fn is_ascii_alphabetic(&self) -> bool {
            matches!( *self, b'A'..=b'Z' | b'a'..=b'z')
        }
    *)
    Definition is_ascii_alphabetic (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ => ltac:(M.monadic (Value.Tuple []));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => M.alloc (| Value.Bool true |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_alphabetic :
      M.IsAssociatedFunction Self "is_ascii_alphabetic" is_ascii_alphabetic.
    
    (*
        pub const fn is_ascii_uppercase(&self) -> bool {
            matches!( *self, b'A'..=b'Z')
        }
    *)
    Definition is_ascii_uppercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_uppercase :
      M.IsAssociatedFunction Self "is_ascii_uppercase" is_ascii_uppercase.
    
    (*
        pub const fn is_ascii_lowercase(&self) -> bool {
            matches!( *self, b'a'..=b'z')
        }
    *)
    Definition is_ascii_lowercase (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_lowercase :
      M.IsAssociatedFunction Self "is_ascii_lowercase" is_ascii_lowercase.
    
    (*
        pub const fn is_ascii_alphanumeric(&self) -> bool {
            matches!( *self, b'0'..=b'9') | matches!( *self, b'A'..=b'Z') | matches!( *self, b'a'..=b'z')
        }
    *)
    Definition is_ascii_alphanumeric (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_or
            (BinOp.Pure.bit_or
              (M.read (|
                M.match_operator (|
                  M.read (| self |),
                  [
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                  ]
                |)
              |))
              (M.read (|
                M.match_operator (|
                  M.read (| self |),
                  [
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                  ]
                |)
              |)))
            (M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_alphanumeric :
      M.IsAssociatedFunction Self "is_ascii_alphanumeric" is_ascii_alphanumeric.
    
    (*
        pub const fn is_ascii_digit(&self) -> bool {
            matches!( *self, b'0'..=b'9')
        }
    *)
    Definition is_ascii_digit (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_digit :
      M.IsAssociatedFunction Self "is_ascii_digit" is_ascii_digit.
    
    (*
        pub const fn is_ascii_octdigit(&self) -> bool {
            matches!( *self, b'0'..=b'7')
        }
    *)
    Definition is_ascii_octdigit (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_octdigit :
      M.IsAssociatedFunction Self "is_ascii_octdigit" is_ascii_octdigit.
    
    (*
        pub const fn is_ascii_hexdigit(&self) -> bool {
            matches!( *self, b'0'..=b'9') | matches!( *self, b'A'..=b'F') | matches!( *self, b'a'..=b'f')
        }
    *)
    Definition is_ascii_hexdigit (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_or
            (BinOp.Pure.bit_or
              (M.read (|
                M.match_operator (|
                  M.read (| self |),
                  [
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                  ]
                |)
              |))
              (M.read (|
                M.match_operator (|
                  M.read (| self |),
                  [
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                  ]
                |)
              |)))
            (M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_hexdigit :
      M.IsAssociatedFunction Self "is_ascii_hexdigit" is_ascii_hexdigit.
    
    (*
        pub const fn is_ascii_punctuation(&self) -> bool {
            matches!( *self, b'!'..=b'/')
                | matches!( *self, b':'..=b'@')
                | matches!( *self, b'['..=b'`')
                | matches!( *self, b'{'..=b'~')
        }
    *)
    Definition is_ascii_punctuation (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.bit_or
            (BinOp.Pure.bit_or
              (BinOp.Pure.bit_or
                (M.read (|
                  M.match_operator (|
                    M.read (| self |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                    ]
                  |)
                |))
                (M.read (|
                  M.match_operator (|
                    M.read (| self |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                    ]
                  |)
                |)))
              (M.read (|
                M.match_operator (|
                  M.read (| self |),
                  [
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                  ]
                |)
              |)))
            (M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_punctuation :
      M.IsAssociatedFunction Self "is_ascii_punctuation" is_ascii_punctuation.
    
    (*
        pub const fn is_ascii_graphic(&self) -> bool {
            matches!( *self, b'!'..=b'~')
        }
    *)
    Definition is_ascii_graphic (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_graphic :
      M.IsAssociatedFunction Self "is_ascii_graphic" is_ascii_graphic.
    
    (*
        pub const fn is_ascii_whitespace(&self) -> bool {
            matches!( *self, b'\t' | b'\n' | b'\x0C' | b'\r' | b' ')
        }
    *)
    Definition is_ascii_whitespace (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 9 |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 10 |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 12 |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 13 |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 32 |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => M.alloc (| Value.Bool true |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_whitespace :
      M.IsAssociatedFunction Self "is_ascii_whitespace" is_ascii_whitespace.
    
    (*
        pub const fn is_ascii_control(&self) -> bool {
            matches!( *self, b'\0'..=b'\x1F' | b'\x7F')
        }
    *)
    Definition is_ascii_control (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ => ltac:(M.monadic (Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer 127
                              |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => M.alloc (| Value.Bool true |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_control :
      M.IsAssociatedFunction Self "is_ascii_control" is_ascii_control.
    
    (*
        pub fn escape_ascii(self) -> ascii::EscapeDefault {
            ascii::escape_default(self)
        }
    *)
    Definition escape_ascii (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "core::ascii::escape_default", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_escape_ascii : M.IsAssociatedFunction Self "escape_ascii" escape_ascii.
    
    (*
        pub(crate) const fn is_utf8_char_boundary(self) -> bool {
            // This is bit magic equivalent to: b < 128 || b >= 192
            (self as i8) >= -0x40
        }
    *)
    Definition is_utf8_char_boundary (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.ge (M.rust_cast (M.read (| self |))) (Value.Integer (-64))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_utf8_char_boundary :
      M.IsAssociatedFunction Self "is_utf8_char_boundary" is_utf8_char_boundary.
  End Impl_u8.
  
  Module Impl_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "u16" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "u16" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u16" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u16" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u16" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::cttz", [ Ty.path "u16" ] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bswap", [ Ty.path "u16" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u16" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "u16" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "u16" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u16", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "u16", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.U16
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u16", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.U16
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU16",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU16",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU16",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU16",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "u16" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "u16" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "u16",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "u16",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "u16" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u16",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u16",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "u16" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.U16 (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.U16 (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u16" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u16",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u16",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u16", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.U16
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.U16 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.U16 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.U16
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.U16
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.U16
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.U16
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.U16 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.U16 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.U16 (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.U16
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.U16 (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u16", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.U16 (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (| BinOp.Wrap.sub Integer.U16 (M.read (| self |)) (Value.Integer 1) |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u16" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.U16
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "one_less_than_next_power_of_two", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u16",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u16",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "u16"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u16", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "u16" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition widening_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_mul", [] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 16))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_widening_mul : M.IsAssociatedFunction Self "widening_mul" widening_mul.
    
    (*
            pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe {
                    (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)
                };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition carrying_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u32", "unchecked_mul", [] |),
                      [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                    |);
                    M.rust_cast (M.read (| carry |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 16))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_mul : M.IsAssociatedFunction Self "carrying_mul" carrying_mul.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                ((self as $WideT + rhs as $WideT) / 2) as $SelfT
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.rust_cast
            (BinOp.Wrap.div
              Integer.U32
              (BinOp.Wrap.add
                Integer.U32
                (M.rust_cast (M.read (| self |)))
                (M.rust_cast (M.read (| rhs |))))
              (Value.Integer 2))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    
    (*
        pub const fn is_utf16_surrogate(self) -> bool {
            matches!(self, 0xD800..=0xDFFF)
        }
    *)
    Definition is_utf16_surrogate (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_utf16_surrogate :
      M.IsAssociatedFunction Self "is_utf16_surrogate" is_utf16_surrogate.
  End Impl_u16.
  
  Module Impl_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "u32" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "u32" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u32" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::cttz", [ Ty.path "u32" ] |),
                  [ M.read (| self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| M.use n |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| M.use n |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bswap", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "u32" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "u32" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u32", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "u32", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u32", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.U32
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU32",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU32",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU32",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU32",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "u32" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.read (| M.use (M.get_constant (| "core::num::MAX" |)) |))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.use rhs
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "u32" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.read (| M.use (M.get_constant (| "core::num::MAX" |)) |))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.use rhs
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "u32",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "u32",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "u32" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u32",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u32",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "u32" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.U32 (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.U32 (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u32" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u32",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u32",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u32", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.U32
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.U32 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.U32 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.U32
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.U32
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.U32
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.U32
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.U32 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.U32 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.U32 (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.U32
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.U32 (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u32", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.U32 (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (| BinOp.Wrap.sub Integer.U32 (M.read (| self |)) (Value.Integer 1) |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u32" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.U32
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "one_less_than_next_power_of_two", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u32",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u32",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "u32"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u32", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "u32" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition widening_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_mul", [] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 32))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_widening_mul : M.IsAssociatedFunction Self "widening_mul" widening_mul.
    
    (*
            pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe {
                    (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)
                };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition carrying_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u64", "unchecked_mul", [] |),
                      [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                    |);
                    M.rust_cast (M.read (| carry |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 32))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_mul : M.IsAssociatedFunction Self "carrying_mul" carrying_mul.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                ((self as $WideT + rhs as $WideT) / 2) as $SelfT
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.rust_cast
            (BinOp.Wrap.div
              Integer.U64
              (BinOp.Wrap.add
                Integer.U64
                (M.rust_cast (M.read (| self |)))
                (M.rust_cast (M.read (| rhs |))))
              (Value.Integer 2))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
  End Impl_u32.
  
  Module Impl_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "u64" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "u64" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u64" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u64" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u64" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::cttz", [ Ty.path "u64" ] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bswap", [ Ty.path "u64" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u64" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "u64" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "u64" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u64", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "u64", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.U64
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u64", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.U64
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU64",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU64",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU64",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU64",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "u64" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "u64" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "u64",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "u64",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "u64" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u64",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u64",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "u64" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.U64 (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.U64 (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u64" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u64",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u64",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u64", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.U64
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul Integer.U64 (M.read (| base |)) (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.U64 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.U64
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.U64
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.U64
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.U64
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.U64 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.U64 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.U64 (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.U64
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.U64 (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u64", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.U64 (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (| BinOp.Wrap.sub Integer.U64 (M.read (| self |)) (Value.Integer 1) |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u64" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.U64
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "one_less_than_next_power_of_two", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u64",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u64",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "u64"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "u64" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition widening_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_mul", [] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 64))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_widening_mul : M.IsAssociatedFunction Self "widening_mul" widening_mul.
    
    (*
            pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe {
                    (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)
                };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition carrying_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u128", "unchecked_mul", [] |),
                      [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                    |);
                    M.rust_cast (M.read (| carry |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 64))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_mul : M.IsAssociatedFunction Self "carrying_mul" carrying_mul.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                ((self as $WideT + rhs as $WideT) / 2) as $SelfT
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.rust_cast
            (BinOp.Wrap.div
              Integer.U128
              (BinOp.Wrap.add
                Integer.U128
                (M.rust_cast (M.read (| self |)))
                (M.rust_cast (M.read (| rhs |))))
              (Value.Integer 2))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
  End Impl_u64.
  
  Module Impl_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "u128" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "u128" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u128" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u128" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u128" ] |),
              [ M.read (| M.use self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::cttz", [ Ty.path "u128" ] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bswap", [ Ty.path "u128" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.use
              (M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u128" ] |),
                  [ M.read (| M.use self |) ]
                |)
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "u128" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "u128" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u128", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (| Ty.path "u128", "ilog2", [] |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.U128
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "u128", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.U128
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU128",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU128",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroU128",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroU128",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "u128" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "u128" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "u128",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "u128",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "u128" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u128",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u128",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "u128" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.U128 (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.U128 (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u128" ] |),
                  [ M.read (| M.use self |); M.read (| M.use rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.read (| M.use a |); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "u128",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u128",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u128", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.U128
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul
                                    Integer.U128
                                    (M.read (| base |))
                                    (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.U128 (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "u128", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.U128
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.U128
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.U128
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.U128
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.U128 (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.U128 (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.U128 (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.U128
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.U128 (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "u128", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.U128 (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (| BinOp.Wrap.sub Integer.U128 (M.read (| self |)) (Value.Integer 1) |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u128" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.U128
            (M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "one_less_than_next_power_of_two", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u128",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "u128",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "u128"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u128", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "u128" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                // Use the well known branchless algorithm from Hacker's Delight to compute
                // `(a + b) / 2` without overflowing: `((a ^ b) >> 1) + (a & b)`.
                ((self ^ rhs) >> 1) + (self & rhs)
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.add
            Integer.U128
            (BinOp.Wrap.shr
              (BinOp.Pure.bit_xor (M.read (| self |)) (M.read (| rhs |)))
              (Value.Integer 1))
            (BinOp.Pure.bit_and (M.read (| self |)) (M.read (| rhs |)))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
  End Impl_u128.
  
  Module Impl_usize.
    Definition Self : Ty.t := Ty.path "usize".
    
    (*         pub const MIN: Self = 0; *)
    (* Ty.path "usize" *)
    Definition value_MIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
    
    Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
    
    (*         pub const MAX: Self = !0; *)
    (* Ty.path "usize" *)
    Definition value_MAX : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnOp.Pure.not (Value.Integer 0) |))).
    
    Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
    
    (*         pub const BITS: u32 = Self::MAX.count_ones(); *)
    (* Ty.path "u32" *)
    Definition value_BITS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "count_ones", [] |),
              [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |)
          |))).
    
    Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    
    (*
            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
                from_str_radix(src, radix)
            }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "usize" ] |),
            [ M.read (| src |); M.read (| radix |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
            pub const fn count_ones(self) -> u32 {
                intrinsics::ctpop(self as $ActualT) as u32
            }
    *)
    Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u64" ] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
    
    (*
            pub const fn count_zeros(self) -> u32 {
                (!self).count_ones()
            }
    *)
    Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "count_ones", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
    
    (*
            pub const fn leading_zeros(self) -> u32 {
                intrinsics::ctlz(self as $ActualT) as u32
            }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz", [ Ty.path "u64" ] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
            pub const fn trailing_zeros(self) -> u32 {
                intrinsics::cttz(self) as u32
            }
    *)
    Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::cttz", [ Ty.path "usize" ] |),
              [ M.read (| self |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_zeros :
      M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
    
    (*
            pub const fn leading_ones(self) -> u32 {
                (!self).leading_zeros()
            }
    *)
    Definition leading_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "leading_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_ones : M.IsAssociatedFunction Self "leading_ones" leading_ones.
    
    (*
            pub const fn trailing_ones(self) -> u32 {
                (!self).trailing_zeros()
            }
    *)
    Definition trailing_ones (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "trailing_zeros", [] |),
            [ UnOp.Pure.not (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_trailing_ones :
      M.IsAssociatedFunction Self "trailing_ones" trailing_ones.
    
    (*
            pub const fn rotate_left(self, n: u32) -> Self {
                intrinsics::rotate_left(self, n as $SelfT)
            }
    *)
    Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_left", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
    
    (*
            pub const fn rotate_right(self, n: u32) -> Self {
                intrinsics::rotate_right(self, n as $SelfT)
            }
    *)
    Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::rotate_right", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.rust_cast (M.read (| n |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate_right : M.IsAssociatedFunction Self "rotate_right" rotate_right.
    
    (*
            pub const fn swap_bytes(self) -> Self {
                intrinsics::bswap(self as $ActualT) as Self
            }
    *)
    Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::bswap", [ Ty.path "u64" ] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
    
    (*
            pub const fn reverse_bits(self) -> Self {
                intrinsics::bitreverse(self as $ActualT) as Self
            }
    *)
    Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_function (| "core::intrinsics::bitreverse", [ Ty.path "u64" ] |),
              [ M.rust_cast (M.read (| self |)) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reverse_bits : M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
    
    (*
            pub const fn from_be(x: Self) -> Self {
                #[cfg(target_endian = "big")]
                {
                    x
                }
                #[cfg(not(target_endian = "big"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "swap_bytes", [] |),
            [ M.read (| x |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
    
    (*
            pub const fn from_le(x: Self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    x
                }
                #[cfg(not(target_endian = "little"))]
                {
                    x.swap_bytes()
                }
            }
    *)
    Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (| x |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
    
    (*
            pub const fn to_be(self) -> Self { // or not to be?
                #[cfg(target_endian = "big")]
                {
                    self
                }
                #[cfg(not(target_endian = "big"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "swap_bytes", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
    
    (*
            pub const fn to_le(self) -> Self {
                #[cfg(target_endian = "little")]
                {
                    self
                }
                #[cfg(not(target_endian = "little"))]
                {
                    self.swap_bytes()
                }
            }
    *)
    Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| self |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
    
    (*
            pub const fn checked_add(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_add(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
            pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_add`.
                unsafe { intrinsics::unchecked_add(self, rhs) }
            }
    *)
    Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_add", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_add :
      M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
    
    (*
            pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {
                let (a, b) = self.overflowing_add_signed(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_add_signed", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add_signed :
      M.IsAssociatedFunction Self "checked_add_signed" checked_add_signed.
    
    (*
            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_sub(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
            pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_sub`.
                unsafe { intrinsics::unchecked_sub(self, rhs) }
            }
    *)
    Definition unchecked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_sub", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_sub :
      M.IsAssociatedFunction Self "unchecked_sub" unchecked_sub.
    
    (*
            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
                let (a, b) = self.overflowing_mul(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
            pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_mul`.
                unsafe { intrinsics::unchecked_mul(self, rhs) }
            }
    *)
    Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_mul", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_mul :
      M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
    
    (*
            pub const fn checked_div(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })
                }
            }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_div",
                              [ Ty.path "usize" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.div_euclid(rhs))
                }
            }
    *)
    Definition checked_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "div_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div_euclid :
      M.IsAssociatedFunction Self "checked_div_euclid" checked_div_euclid.
    
    (*
            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    // SAFETY: div by zero has been checked above and unsigned types have no other
                    // failure modes for division
                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })
                }
            }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::unchecked_rem",
                              [ Ty.path "usize" ]
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
                if unlikely!(rhs == 0) {
                    None
                } else {
                    Some(self.rem_euclid(rhs))
                }
            }
    *)
    Definition checked_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| rhs |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "rem_euclid", [] |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem_euclid :
      M.IsAssociatedFunction Self "checked_rem_euclid" checked_rem_euclid.
    
    (*
            pub const fn ilog(self, base: Self) -> u32 {
                assert!(base >= 2, "base of integer logarithm must be at least 2");
                if let Some(log) = self.checked_ilog(base) {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not (BinOp.Pure.ge (M.read (| base |)) (Value.Integer 2))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "base of integer logarithm must be at least 2"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "checked_ilog", [] |),
                          [ M.read (| self |); M.read (| base |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog : M.IsAssociatedFunction Self "ilog" ilog.
    
    (*
            pub const fn ilog2(self) -> u32 {
                if let Some(log) = self.checked_ilog2() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "checked_ilog2", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
    
    (*
            pub const fn ilog10(self) -> u32 {
                if let Some(log) = self.checked_ilog10() {
                    log
                } else {
                    int_log10::panic_for_nonpositive_argument()
                }
            }
    *)
    Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "checked_ilog10", [] |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let log := M.copy (| γ0_0 |) in
                    log));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (|
                            "core::num::int_log10::panic_for_nonpositive_argument",
                            []
                          |),
                          []
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
    
    (*
            pub const fn checked_ilog(self, base: Self) -> Option<u32> {
                if self <= 0 || base <= 1 {
                    None
                } else {
                    let mut n = 0;
                    let mut r = self;
    
                    // Optimization for 128 bit wide integers.
                    if Self::BITS == 128 {
                        let b = Self::ilog2(self) / (Self::ilog2(base) + 1);
                        n += b;
                        r /= base.pow(b as u32);
                    }
    
                    while r >= base {
                        r /= base;
                        n += 1;
                    }
                    Some(n)
                }
            }
    *)
    Definition checked_ilog (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; base ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let base := M.alloc (| base |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            BinOp.Pure.le (M.read (| self |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.le (M.read (| base |)) (Value.Integer 1)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ n := M.alloc (| Value.Integer 0 |) in
                    let~ r := M.copy (| self |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                      (Value.Integer 128)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ b :=
                                M.alloc (|
                                  BinOp.Wrap.div
                                    Integer.U32
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "usize", "ilog2", [] |),
                                      [ M.read (| self |) ]
                                    |))
                                    (BinOp.Wrap.add
                                      Integer.U32
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "ilog2",
                                          []
                                        |),
                                        [ M.read (| base |) ]
                                      |))
                                      (Value.Integer 1))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.U32 (M.read (| β |)) (M.read (| b |))
                                |) in
                              let~ _ :=
                                let β := r in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div
                                    Integer.Usize
                                    (M.read (| β |))
                                    (M.call_closure (|
                                      M.get_associated_function (| Ty.path "usize", "pow", [] |),
                                      [ M.read (| base |); M.read (| M.use b |) ]
                                    |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ge (M.read (| r |)) (M.read (| base |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    let β := r in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div
                                        Integer.Usize
                                        (M.read (| β |))
                                        (M.read (| base |))
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add Integer.U32 (M.read (| β |)) (Value.Integer 1)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog : M.IsAssociatedFunction Self "checked_ilog" checked_ilog.
    
    (*
            pub const fn checked_ilog2(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog2())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroUsize",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroUsize",
                              "ilog2",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog2 :
      M.IsAssociatedFunction Self "checked_ilog2" checked_ilog2.
    
    (*
            pub const fn checked_ilog10(self) -> Option<u32> {
                if let Some(x) = <$NonZeroT>::new(self) {
                    Some(x.ilog10())
                } else {
                    None
                }
            }
    *)
    Definition checked_ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::num::nonzero::NonZeroUsize",
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::num::nonzero::NonZeroUsize",
                              "ilog10",
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_ilog10 :
      M.IsAssociatedFunction Self "checked_ilog10" checked_ilog10.
    
    (*
            pub const fn checked_neg(self) -> Option<Self> {
                let (a, b) = self.overflowing_neg();
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_neg", [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
    
    (*
            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shl(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_shl", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
            pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shl`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shl", [ Ty.path "usize" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shl :
      M.IsAssociatedFunction Self "unchecked_shl" unchecked_shl.
    
    (*
            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {
                let (a, b) = self.overflowing_shr(rhs);
                if unlikely!(b) {None} else {Some(a)}
            }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_shr", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::intrinsics::unlikely", [] |),
                                    [ M.read (| b |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::option::Option::Some" [ M.read (| a |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
            pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {
                // SAFETY: the caller must uphold the safety contract for
                // `unchecked_shr`.
                // Any legal shift amount is losslessly representable in the self type.
                unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }
            }
    *)
    Definition unchecked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::unchecked_shr", [ Ty.path "usize" ] |),
            [
              M.read (| self |);
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                  (Value.Integer 32)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.le
                                    (M.read (| rhs |))
                                    (M.rust_cast
                                      (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| M.rust_cast (M.read (| rhs |)) |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_shr :
      M.IsAssociatedFunction Self "unchecked_shr" unchecked_shr.
    
    (*
            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {
                if exp == 0 {
                    return Some(1);
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = try_opt!(acc.checked_mul(base));
                    }
                    exp /= 2;
                    base = try_opt!(base.checked_mul(base));
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
    
                acc.checked_mul(base)
            }
    *)
    Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "usize",
                                                      "checked_mul",
                                                      []
                                                    |),
                                                    [ M.read (| acc |); M.read (| base |) ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let x := M.copy (| γ0_0 |) in
                                                      x));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::None"
                                                                []
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "usize",
                                            "checked_mul",
                                            []
                                          |),
                                          [ M.read (| base |); M.read (| base |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            x));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
    
    (*
            pub const fn saturating_add(self, rhs: Self) -> Self {
                intrinsics::saturating_add(self, rhs)
            }
    *)
    Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_add", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add :
      M.IsAssociatedFunction Self "saturating_add" saturating_add.
    
    (*
            pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {
                let (res, overflow) = self.overflowing_add(rhs as Self);
                if overflow == (rhs < 0) {
                    res
                } else if overflow {
                    Self::MAX
                } else {
                    0
                }
            }
    *)
    Definition saturating_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| overflow |))
                                    (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            res));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.get_constant (| "core::num::MAX" |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_add_signed :
      M.IsAssociatedFunction Self "saturating_add_signed" saturating_add_signed.
    
    (*
            pub const fn saturating_sub(self, rhs: Self) -> Self {
                intrinsics::saturating_sub(self, rhs)
            }
    *)
    Definition saturating_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::saturating_sub", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_sub :
      M.IsAssociatedFunction Self "saturating_sub" saturating_sub.
    
    (*
            pub const fn saturating_mul(self, rhs: Self) -> Self {
                match self.checked_mul(rhs) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_mul :
      M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
    
    (*
            pub const fn saturating_div(self, rhs: Self) -> Self {
                // on unsigned types, there is no overflow in integer division
                self.wrapping_div(rhs)
            }
    *)
    Definition saturating_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "wrapping_div", [] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_div :
      M.IsAssociatedFunction Self "saturating_div" saturating_div.
    
    (*
            pub const fn saturating_pow(self, exp: u32) -> Self {
                match self.checked_pow(exp) {
                    Some(x) => x,
                    None => Self::MAX,
                }
            }
    *)
    Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "checked_pow", [] |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    x));
                fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_saturating_pow :
      M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    
    (*
            pub const fn wrapping_add(self, rhs: Self) -> Self {
                intrinsics::wrapping_add(self, rhs)
            }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_add", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
            pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {
                self.wrapping_add(rhs as Self)
            }
    *)
    Definition wrapping_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add_signed :
      M.IsAssociatedFunction Self "wrapping_add_signed" wrapping_add_signed.
    
    (*
            pub const fn wrapping_sub(self, rhs: Self) -> Self {
                intrinsics::wrapping_sub(self, rhs)
            }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_sub", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
            pub const fn wrapping_mul(self, rhs: Self) -> Self {
                intrinsics::wrapping_mul(self, rhs)
            }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "core::intrinsics::wrapping_mul", [ Ty.path "usize" ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
            pub const fn wrapping_div(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div : M.IsAssociatedFunction Self "wrapping_div" wrapping_div.
    
    (*
            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition wrapping_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_div_euclid :
      M.IsAssociatedFunction Self "wrapping_div_euclid" wrapping_div_euclid.
    
    (*
            pub const fn wrapping_rem(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem : M.IsAssociatedFunction Self "wrapping_rem" wrapping_rem.
    
    (*
            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition wrapping_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_rem_euclid :
      M.IsAssociatedFunction Self "wrapping_rem_euclid" wrapping_rem_euclid.
    
    (*
            pub const fn wrapping_neg(self) -> Self {
                (0 as $SelfT).wrapping_sub(self)
            }
    *)
    Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
            [ M.read (| M.use (M.alloc (| Value.Integer 0 |)) |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_neg : M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
    
    (*
            pub const fn wrapping_shl(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shl(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "unchecked_shl", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shl : M.IsAssociatedFunction Self "wrapping_shl" wrapping_shl.
    
    (*
            pub const fn wrapping_shr(self, rhs: u32) -> Self {
                // SAFETY: the masking by the bitsize of the type ensures that we do not shift
                // out of bounds
                unsafe {
                    self.unchecked_shr(rhs & (Self::BITS - 1))
                }
            }
    *)
    Definition wrapping_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "unchecked_shr", [] |),
            [
              M.read (| self |);
              BinOp.Pure.bit_and
                (M.read (| rhs |))
                (BinOp.Wrap.sub
                  Integer.U32
                  (M.read (| M.get_constant (| "core::num::BITS" |) |))
                  (Value.Integer 1))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_shr : M.IsAssociatedFunction Self "wrapping_shr" wrapping_shr.
    
    (*
            pub const fn wrapping_pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc: Self = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc.wrapping_mul(base);
                    }
                    exp /= 2;
                    base = base.wrapping_mul(base);
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc.wrapping_mul(base)
            }
    *)
    Definition wrapping_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "usize",
                                                "wrapping_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "wrapping_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "wrapping_mul", [] |),
                    [ M.read (| acc |); M.read (| base |) ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_pow : M.IsAssociatedFunction Self "wrapping_pow" wrapping_pow.
    
    (*
            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::add_with_overflow", [ Ty.path "u64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add :
      M.IsAssociatedFunction Self "overflowing_add" overflowing_add.
    
    (*
            pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_add(rhs);
                let (c, d) = a.overflowing_add(carry as $SelfT);
                (c, b || d)
            }
    *)
    Definition carrying_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| carry |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_add : M.IsAssociatedFunction Self "carrying_add" carrying_add.
    
    (*
            pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {
                let (res, overflowed) = self.overflowing_add(rhs as Self);
                (res, overflowed ^ (rhs < 0))
            }
    *)
    Definition overflowing_add_signed (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                  [ M.read (| self |); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let res := M.copy (| γ0_0 |) in
                    let overflowed := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| res |);
                          BinOp.Pure.bit_xor
                            (M.read (| overflowed |))
                            (BinOp.Pure.lt (M.read (| rhs |)) (Value.Integer 0))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_add_signed :
      M.IsAssociatedFunction Self "overflowing_add_signed" overflowing_add_signed.
    
    (*
            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::sub_with_overflow", [ Ty.path "u64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_sub :
      M.IsAssociatedFunction Self "overflowing_sub" overflowing_sub.
    
    (*
            pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {
                // note: longer-term this should be done via an intrinsic, but this has been shown
                //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic
                let (a, b) = self.overflowing_sub(rhs);
                let (c, d) = a.overflowing_sub(borrow as $SelfT);
                (c, b || d)
            }
    *)
    Definition borrowing_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; borrow ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "overflowing_sub", [] |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "overflowing_sub", [] |),
                          [ M.read (| a |); M.rust_cast (M.read (| borrow |)) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let d := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.read (| c |);
                                  LogicalOp.or (|
                                    M.read (| b |),
                                    ltac:(M.monadic (M.read (| d |)))
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_borrowing_sub :
      M.IsAssociatedFunction Self "borrowing_sub" borrowing_sub.
    
    (*
            pub const fn abs_diff(self, other: Self) -> Self {
                if mem::size_of::<Self>() == 1 {
                    // Trick LLVM into generating the psadbw instruction when SSE2
                    // is available and this function is autovectorized for u8's.
                    (self as i32).wrapping_sub(other as i32).abs() as Self
                } else {
                    if self < other {
                        other - self
                    } else {
                        self - other
                    }
                }
            }
    *)
    Definition abs_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_function (| "core::mem::size_of", [ Ty.path "usize" ] |),
                              []
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "i32", "abs", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                              [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| other |)) ]
                            |)
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| self |)) (M.read (| other |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub Integer.Usize (M.read (| other |)) (M.read (| self |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Wrap.sub Integer.Usize (M.read (| self |)) (M.read (| other |))
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_abs_diff : M.IsAssociatedFunction Self "abs_diff" abs_diff.
    
    (*
            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
                (a as Self, b)
            }
    *)
    Definition overflowing_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::mul_with_overflow", [ Ty.path "u64" ] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| γ0_0 |) in
                    let b := M.copy (| γ0_1 |) in
                    M.alloc (| Value.Tuple [ M.rust_cast (M.read (| a |)); M.read (| b |) ] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_mul :
      M.IsAssociatedFunction Self "overflowing_mul" overflowing_mul.
    
    (*
            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div :
      M.IsAssociatedFunction Self "overflowing_div" overflowing_div.
    
    (*
            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
                (self / rhs, false)
            }
    *)
    Definition overflowing_div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_div_euclid :
      M.IsAssociatedFunction Self "overflowing_div_euclid" overflowing_div_euclid.
    
    (*
            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem :
      M.IsAssociatedFunction Self "overflowing_rem" overflowing_rem.
    
    (*
            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
                (self % rhs, false)
            }
    *)
    Definition overflowing_rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [ BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |)); Value.Bool false
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_rem_euclid :
      M.IsAssociatedFunction Self "overflowing_rem_euclid" overflowing_rem_euclid.
    
    (*
            pub const fn overflowing_neg(self) -> (Self, bool) {
                ((!self).wrapping_add(1), self != 0)
            }
    *)
    Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                [ UnOp.Pure.not (M.read (| self |)); Value.Integer 1 ]
              |);
              BinOp.Pure.ne (M.read (| self |)) (Value.Integer 0)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_neg :
      M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
    
    (*
            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shl(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "wrapping_shl", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shl :
      M.IsAssociatedFunction Self "overflowing_shl" overflowing_shl.
    
    (*
            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {
                (self.wrapping_shr(rhs), rhs >= Self::BITS)
            }
    *)
    Definition overflowing_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.Tuple
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "wrapping_shr", [] |),
                [ M.read (| self |); M.read (| rhs |) ]
              |);
              BinOp.Pure.ge (M.read (| rhs |)) (M.read (| M.get_constant (| "core::num::BITS" |) |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_shr :
      M.IsAssociatedFunction Self "overflowing_shr" overflowing_shr.
    
    (*
            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {
                if exp == 0{
                    return (1,false);
                }
                let mut base = self;
                let mut acc: Self = 1;
                let mut overflown = false;
                // Scratch space for storing results of overflowing_mul.
                let mut r;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        r = acc.overflowing_mul(base);
                        acc = r.0;
                        overflown |= r.1;
                    }
                    exp /= 2;
                    r = base.overflowing_mul(base);
                    base = r.0;
                    overflown |= r.1;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                r = acc.overflowing_mul(base);
                r.1 |= overflown;
    
                r
            }
    *)
    Definition overflowing_pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ Value.Integer 1; Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ overflown := M.alloc (| Value.Bool false |) in
                let~ r := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            r,
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "usize",
                                                "overflowing_mul",
                                                []
                                              |),
                                              [ M.read (| acc |); M.read (| base |) ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                          |) in
                                        let~ _ :=
                                          let β := overflown in
                                          M.write (|
                                            β,
                                            BinOp.Pure.bit_or
                                              (M.read (| β |))
                                              (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  r,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "overflowing_mul",
                                      []
                                    |),
                                    [ M.read (| base |); M.read (| base |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  M.read (| M.SubPointer.get_tuple_field (| r, 0 |) |)
                                |) in
                              let~ _ :=
                                let β := overflown in
                                M.write (|
                                  β,
                                  BinOp.Pure.bit_or
                                    (M.read (| β |))
                                    (M.read (| M.SubPointer.get_tuple_field (| r, 1 |) |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.write (|
                    r,
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                      [ M.read (| acc |); M.read (| base |) ]
                    |)
                  |) in
                let~ _ :=
                  let β := M.SubPointer.get_tuple_field (| r, 1 |) in
                  M.write (| β, BinOp.Pure.bit_or (M.read (| β |)) (M.read (| overflown |)) |) in
                r
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_overflowing_pow :
      M.IsAssociatedFunction Self "overflowing_pow" overflowing_pow.
    
    (*
            pub const fn pow(self, mut exp: u32) -> Self {
                if exp == 0 {
                    return 1;
                }
                let mut base = self;
                let mut acc = 1;
    
                while exp > 1 {
                    if (exp & 1) == 1 {
                        acc = acc * base;
                    }
                    exp /= 2;
                    base = base * base;
                }
    
                // since exp!=0, finally the exp must be 1.
                // Deal with the final bit of the exponent separately, since
                // squaring the base afterwards is not necessary and may cause a
                // needless overflow.
                acc * base
            }
    *)
    Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.eq (M.read (| exp |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 1 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ base := M.copy (| self |) in
                let~ acc := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt (M.read (| exp |)) (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.eq
                                                (BinOp.Pure.bit_and
                                                  (M.read (| exp |))
                                                  (Value.Integer 1))
                                                (Value.Integer 1)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            acc,
                                            BinOp.Wrap.mul
                                              Integer.Usize
                                              (M.read (| acc |))
                                              (M.read (| base |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := exp in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div Integer.U32 (M.read (| β |)) (Value.Integer 2)
                                |) in
                              let~ _ :=
                                M.write (|
                                  base,
                                  BinOp.Wrap.mul
                                    Integer.Usize
                                    (M.read (| base |))
                                    (M.read (| base |))
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| BinOp.Wrap.mul Integer.Usize (M.read (| acc |)) (M.read (| base |)) |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
    
    (*
            pub const fn isqrt(self) -> Self {
                if self < 2 {
                    return self;
                }
    
                // The algorithm is based on the one presented in
                // <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>
                // which cites as source the following C code:
                // <https://web.archive.org/web/20120306040058/http://medialab.freaknet.org/martin/src/sqrt/sqrt.c>.
    
                let mut op = self;
                let mut res = 0;
                let mut one = 1 << (self.ilog2() & !1);
    
                while one != 0 {
                    if op >= res + one {
                        op -= res + one;
                        res = (res >> 1) + one;
                    } else {
                        res >>= 1;
                    }
                    one >>= 2;
                }
    
                // SAFETY: the result is positive and fits in an integer with half as many bits.
                // Inform the optimizer about it.
                unsafe {
                    intrinsics::assume(0 < res);
                    intrinsics::assume(res < 1 << (Self::BITS / 2));
                }
    
                res
            }
    *)
    Definition isqrt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| self |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ op := M.copy (| self |) in
                let~ res := M.alloc (| Value.Integer 0 |) in
                let~ one :=
                  M.alloc (|
                    BinOp.Wrap.shl
                      (Value.Integer 1)
                      (BinOp.Pure.bit_and
                        (M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "ilog2", [] |),
                          [ M.read (| self |) ]
                        |))
                        (UnOp.Pure.not (Value.Integer 1)))
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne (M.read (| one |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge
                                                (M.read (| op |))
                                                (BinOp.Wrap.add
                                                  Integer.Usize
                                                  (M.read (| res |))
                                                  (M.read (| one |)))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := op in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.read (| β |))
                                              (BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| res |))
                                                (M.read (| one |)))
                                          |) in
                                        let~ _ :=
                                          M.write (|
                                            res,
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (BinOp.Wrap.shr (M.read (| res |)) (Value.Integer 1))
                                              (M.read (| one |))
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          let β := res in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 1)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ :=
                                let β := one in
                                M.write (|
                                  β,
                                  BinOp.Wrap.shr (M.read (| β |)) (Value.Integer 2)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [ BinOp.Pure.lt (Value.Integer 0) (M.read (| res |)) ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          BinOp.Pure.lt
                            (M.read (| res |))
                            (BinOp.Wrap.shl
                              (Value.Integer 1)
                              (BinOp.Wrap.div
                                Integer.U32
                                (M.read (| M.get_constant (| "core::num::BITS" |) |))
                                (Value.Integer 2)))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                res
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
    
    (*
            pub const fn div_euclid(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_euclid : M.IsAssociatedFunction Self "div_euclid" div_euclid.
    
    (*
            pub const fn rem_euclid(self, rhs: Self) -> Self {
                self % rhs
            }
    *)
    Definition rem_euclid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rem_euclid : M.IsAssociatedFunction Self "rem_euclid" rem_euclid.
    
    (*
            pub const fn div_floor(self, rhs: Self) -> Self {
                self / rhs
            }
    *)
    Definition div_floor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_floor : M.IsAssociatedFunction Self "div_floor" div_floor.
    
    (*
            pub const fn div_ceil(self, rhs: Self) -> Self {
                let d = self / rhs;
                let r = self % rhs;
                if r > 0 && rhs > 0 {
                    d + 1
                } else {
                    d
                }
            }
    *)
    Definition div_ceil (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ d :=
              M.alloc (| BinOp.Wrap.div Integer.Usize (M.read (| self |)) (M.read (| rhs |)) |) in
            let~ r :=
              M.alloc (| BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |)) |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            BinOp.Pure.gt (M.read (| r |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| rhs |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| BinOp.Wrap.add Integer.Usize (M.read (| d |)) (Value.Integer 1) |)));
                fun γ => ltac:(M.monadic d)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_div_ceil : M.IsAssociatedFunction Self "div_ceil" div_ceil.
    
    (*
            pub const fn next_multiple_of(self, rhs: Self) -> Self {
                match self % rhs {
                    0 => self,
                    r => self + (rhs - r)
                }
            }
    *)
    Definition next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              M.alloc (| BinOp.Wrap.rem Integer.Usize (M.read (| self |)) (M.read (| rhs |)) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (let r := M.copy (| γ |) in
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.Usize
                        (M.read (| self |))
                        (BinOp.Wrap.sub Integer.Usize (M.read (| rhs |)) (M.read (| r |)))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_multiple_of :
      M.IsAssociatedFunction Self "next_multiple_of" next_multiple_of.
    
    (*
            pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {
                match try_opt!(self.checked_rem(rhs)) {
                    0 => Some(self),
                    // rhs - r cannot overflow because r is smaller than rhs
                    r => self.checked_add(rhs - r)
                }
            }
    *)
    Definition checked_next_multiple_of (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "checked_rem", [] |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          x));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                        M.alloc (|
                          Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let r := M.copy (| γ |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                            [
                              M.read (| self |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| rhs |)) (M.read (| r |))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_multiple_of :
      M.IsAssociatedFunction Self "checked_next_multiple_of" checked_next_multiple_of.
    
    (*
            pub const fn is_power_of_two(self) -> bool {
                self.count_ones() == 1
            }
    *)
    Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "count_ones", [] |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_power_of_two :
      M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
    
    (*
            const fn one_less_than_next_power_of_two(self) -> Self {
                if self <= 1 { return 0; }
    
                let p = self - 1;
                // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
                // That means the shift is always in-bounds, and some processors
                // (such as intel pre-haswell) have more efficient ctlz
                // intrinsics when the argument is non-zero.
                let z = unsafe { intrinsics::ctlz_nonzero(p) };
                <$SelfT>::MAX >> z
            }
    *)
    Definition one_less_than_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.le (M.read (| self |)) (Value.Integer 1) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ p :=
                  M.alloc (|
                    BinOp.Wrap.sub Integer.Usize (M.read (| self |)) (Value.Integer 1)
                  |) in
                let~ z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "usize" ] |),
                      [ M.read (| p |) ]
                    |)
                  |) in
                M.alloc (|
                  BinOp.Wrap.shr
                    (M.read (| M.get_constant (| "core::num::MAX" |) |))
                    (M.read (| z |))
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one_less_than_next_power_of_two :
      M.IsAssociatedFunction Self "one_less_than_next_power_of_two" one_less_than_next_power_of_two.
    
    (*
            pub const fn next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two() + 1
            }
    *)
    Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.add
            Integer.Usize
            (M.call_closure (|
              M.get_associated_function (|
                Ty.path "usize",
                "one_less_than_next_power_of_two",
                []
              |),
              [ M.read (| self |) ]
            |))
            (Value.Integer 1)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_power_of_two :
      M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    
    (*
            pub const fn checked_next_power_of_two(self) -> Option<Self> {
                self.one_less_than_next_power_of_two().checked_add(1)
            }
    *)
    Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "usize",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_next_power_of_two :
      M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
    
    (*
            pub const fn wrapping_next_power_of_two(self) -> Self {
                self.one_less_than_next_power_of_two().wrapping_add(1)
            }
    *)
    Definition wrapping_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "usize",
                  "one_less_than_next_power_of_two",
                  []
                |),
                [ M.read (| self |) ]
              |);
              Value.Integer 1
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_next_power_of_two :
      M.IsAssociatedFunction Self "wrapping_next_power_of_two" wrapping_next_power_of_two.
    
    (*
            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_be().to_ne_bytes()
            }
    *)
    Definition to_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "to_be", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_be_bytes : M.IsAssociatedFunction Self "to_be_bytes" to_be_bytes.
    
    (*
            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {
                self.to_le().to_ne_bytes()
            }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "to_ne_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "to_le", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
                // SAFETY: integers are plain old datatypes so we can always transmute them to
                // arrays of bytes
                unsafe { mem::transmute(self) }
            }
    *)
    Definition to_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.path "usize"; Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_ne_bytes : M.IsAssociatedFunction Self "to_ne_bytes" to_ne_bytes.
    
    (*
            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_be(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_be_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "from_be", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction Self "from_be_bytes" from_be_bytes.
    
    (*
            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                Self::from_le(Self::from_ne_bytes(bytes))
            }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "from_le", [] |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "from_ne_bytes", [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {
                // SAFETY: integers are plain old datatypes so we can always transmute to them
                unsafe { mem::transmute(bytes) }
            }
    *)
    Definition from_ne_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "usize" ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction Self "from_ne_bytes" from_ne_bytes.
    
    (*         pub const fn min_value() -> Self { Self::MIN } *)
    Definition min_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MIN" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_min_value : M.IsAssociatedFunction Self "min_value" min_value.
    
    (*         pub const fn max_value() -> Self { Self::MAX } *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (M.read (| M.get_constant (| "core::num::MAX" |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
            pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition widening_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_mul", [] |),
                  [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 64))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_widening_mul : M.IsAssociatedFunction Self "widening_mul" widening_mul.
    
    (*
            pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {
                // note: longer-term this should be done via an intrinsic,
                //   but for now we can deal without an impl for u128/i128
                // SAFETY: overflow will be contained within the wider types
                let wide = unsafe {
                    (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)
                };
                (wide as $SelfT, (wide >> $BITS) as $SelfT)
            }
    *)
    Definition carrying_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs; carry ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ wide :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u128", "unchecked_mul", [] |),
                      [ M.rust_cast (M.read (| self |)); M.rust_cast (M.read (| rhs |)) ]
                    |);
                    M.rust_cast (M.read (| carry |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.rust_cast (M.read (| wide |));
                  M.rust_cast (BinOp.Wrap.shr (M.read (| wide |)) (Value.Integer 64))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_carrying_mul : M.IsAssociatedFunction Self "carrying_mul" carrying_mul.
    
    (*
            pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {
                ((self as $WideT + rhs as $WideT) / 2) as $SelfT
            }
    *)
    Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.rust_cast
            (BinOp.Wrap.div
              Integer.U128
              (BinOp.Wrap.add
                Integer.U128
                (M.rust_cast (M.read (| self |)))
                (M.rust_cast (M.read (| rhs |))))
              (Value.Integer 2))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
    (*
        pub(crate) const fn repeat_u8(x: u8) -> usize {
            usize::from_ne_bytes([x; mem::size_of::<usize>()])
        }
    *)
    Definition repeat_u8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "from_ne_bytes", [] |),
            [ repeat (M.read (| x |)) 8 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_repeat_u8 : M.IsAssociatedFunction Self "repeat_u8" repeat_u8.
    
    (*
        pub(crate) const fn repeat_u16(x: u16) -> usize {
            let mut r = 0usize;
            let mut i = 0;
            while i < mem::size_of::<usize>() {
                // Use `wrapping_shl` to make it work on targets with 16-bit `usize`
                r = r.wrapping_shl(16) | (x as usize);
                i += 2;
            }
            r
        }
    *)
    Definition repeat_u16 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (|
            let~ r := M.alloc (| Value.Integer 0 |) in
            let~ i := M.alloc (| Value.Integer 0 |) in
            let~ _ :=
              M.loop (|
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.lt
                                  (M.read (| i |))
                                  (M.call_closure (|
                                    M.get_function (| "core::mem::size_of", [ Ty.path "usize" ] |),
                                    []
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.write (|
                              r,
                              BinOp.Pure.bit_or
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "wrapping_shl",
                                    []
                                  |),
                                  [ M.read (| r |); Value.Integer 16 ]
                                |))
                                (M.rust_cast (M.read (| x |)))
                            |) in
                          let~ _ :=
                            let β := i in
                            M.write (|
                              β,
                              BinOp.Wrap.add Integer.Usize (M.read (| β |)) (Value.Integer 2)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            r
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_repeat_u16 : M.IsAssociatedFunction Self "repeat_u16" repeat_u16.
  End Impl_usize.
  
  
  (*
  Enum FpCategory
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Nan";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Infinite";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Zero";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Subnormal";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Normal";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_marker_Copy_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_core_num_FpCategory.
  
  Module Impl_core_clone_Clone_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_core_num_FpCategory.
  
  Module Impl_core_marker_StructuralPartialEq_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_core_num_FpCategory.
  
  Module Impl_core_cmp_PartialEq_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "core::num::FpCategory" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "core::num::FpCategory" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_core_num_FpCategory.
  
  Module Impl_core_marker_StructuralEq_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_core_num_FpCategory.
  
  Module Impl_core_cmp_Eq_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_core_num_FpCategory.
  
  Module Impl_core_fmt_Debug_for_core_num_FpCategory.
    Definition Self : Ty.t := Ty.path "core::num::FpCategory".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "Nan" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "Infinite" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "Zero" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "Subnormal" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "Normal" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_core_num_FpCategory.
  
  (* Trait *)
  (* Empty module 'FromStrRadixHelper' *)
  
  Module Impl_core_str_traits_FromStr_for_isize.
    Definition Self : Ty.t := Ty.path "isize".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "isize" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_isize.
  
  Module Impl_core_str_traits_FromStr_for_i8.
    Definition Self : Ty.t := Ty.path "i8".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i8" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_i8.
  
  Module Impl_core_str_traits_FromStr_for_i16.
    Definition Self : Ty.t := Ty.path "i16".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i16" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_i16.
  
  Module Impl_core_str_traits_FromStr_for_i32.
    Definition Self : Ty.t := Ty.path "i32".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i32" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_i32.
  
  Module Impl_core_str_traits_FromStr_for_i64.
    Definition Self : Ty.t := Ty.path "i64".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i64" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_i64.
  
  Module Impl_core_str_traits_FromStr_for_i128.
    Definition Self : Ty.t := Ty.path "i128".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "i128" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_i128.
  
  Module Impl_core_str_traits_FromStr_for_usize.
    Definition Self : Ty.t := Ty.path "usize".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "usize" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_usize.
  
  Module Impl_core_str_traits_FromStr_for_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u8" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_u8.
  
  Module Impl_core_str_traits_FromStr_for_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u16" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_u16.
  
  Module Impl_core_str_traits_FromStr_for_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u32" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_u32.
  
  Module Impl_core_str_traits_FromStr_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u64" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_u64.
  
  Module Impl_core_str_traits_FromStr_for_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    (*             type Err = ParseIntError; *)
    Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
    
    (*
                fn from_str(src: &str) -> Result<Self, ParseIntError> {
                    from_str_radix(src, 10)
                }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            M.get_function (| "core::num::from_str_radix", [ Ty.path "u128" ] |),
            [ M.read (| src |); Value.Integer 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_u128.
  
  Module Impl_core_num_FromStrRadixHelper_for_i8.
    Definition Self : Ty.t := Ty.path "i8".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "i8" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i8", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_i8.
  
  Module Impl_core_num_FromStrRadixHelper_for_i16.
    Definition Self : Ty.t := Ty.path "i16".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "i16" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i16", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_i16.
  
  Module Impl_core_num_FromStrRadixHelper_for_i32.
    Definition Self : Ty.t := Ty.path "i32".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "i32" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i32", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_i32.
  
  Module Impl_core_num_FromStrRadixHelper_for_i64.
    Definition Self : Ty.t := Ty.path "i64".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "i64" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i64", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_i64.
  
  Module Impl_core_num_FromStrRadixHelper_for_i128.
    Definition Self : Ty.t := Ty.path "i128".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "i128" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "i128", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_i128.
  
  Module Impl_core_num_FromStrRadixHelper_for_isize.
    Definition Self : Ty.t := Ty.path "isize".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "isize" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "isize", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_isize.
  
  Module Impl_core_num_FromStrRadixHelper_for_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "u8" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u8", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_u8.
  
  Module Impl_core_num_FromStrRadixHelper_for_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "u16" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u16", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_u16.
  
  Module Impl_core_num_FromStrRadixHelper_for_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "u32" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.read (| M.use u |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.use other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.use other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u32", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.use other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_u32.
  
  Module Impl_core_num_FromStrRadixHelper_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "u64" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u64", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_u64.
  
  Module Impl_core_num_FromStrRadixHelper_for_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "u128" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "u128", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_u128.
  
  Module Impl_core_num_FromStrRadixHelper_for_usize.
    Definition Self : Ty.t := Ty.path "usize".
    
    (*         const MIN: Self = Self::MIN; *)
    (* Ty.path "usize" *)
    Definition value_MIN : Value.t :=
      M.run ltac:(M.monadic (M.get_constant (| "core::num::MIN" |))).
    
    (*         fn from_u32(u: u32) -> Self { u as Self } *)
    Definition from_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.rust_cast (M.read (| u |))))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_mul(&self, other: u32) -> Option<Self> {
                Self::checked_mul( *self, other as Self)
            }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_sub(&self, other: u32) -> Option<Self> {
                Self::checked_sub( *self, other as Self)
            }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "checked_sub", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
            fn checked_add(&self, other: u32) -> Option<Self> {
                Self::checked_add( *self, other as Self)
            }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
            [ M.read (| M.read (| self |) |); M.rust_cast (M.read (| other |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::num::FromStrRadixHelper"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("value_MIN", InstanceField.Constant value_MIN);
          ("from_u32", InstanceField.Method from_u32);
          ("checked_mul", InstanceField.Method checked_mul);
          ("checked_sub", InstanceField.Method checked_sub);
          ("checked_add", InstanceField.Method checked_add)
        ].
  End Impl_core_num_FromStrRadixHelper_for_usize.
  
  (*
  pub fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits: &[u8]) -> bool {
      radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize
  }
  *)
  Definition can_not_overflow (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ radix; is_signed_ty; digits ] =>
      ltac:(M.monadic
        (let radix := M.alloc (| radix |) in
        let is_signed_ty := M.alloc (| is_signed_ty |) in
        let digits := M.alloc (| digits |) in
        LogicalOp.and (|
          BinOp.Pure.le (M.read (| radix |)) (Value.Integer 16),
          ltac:(M.monadic
            (BinOp.Pure.le
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                  "len",
                  []
                |),
                [ M.read (| digits |) ]
              |))
              (BinOp.Wrap.sub
                Integer.Usize
                (BinOp.Wrap.mul
                  Integer.Usize
                  (M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |))
                  (Value.Integer 2))
                (M.rust_cast (M.read (| is_signed_ty |))))))
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_can_not_overflow : M.IsFunction "core::num::can_not_overflow" can_not_overflow.
  
  (*
  fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {
      use self::IntErrorKind::*;
      use self::ParseIntError as PIE;
  
      assert!(
          (2..=36).contains(&radix),
          "from_str_radix_int: must lie in the range `[2, 36]` - found {}",
          radix
      );
  
      if src.is_empty() {
          return Err(PIE { kind: Empty });
      }
  
      let is_signed_ty = T::from_u32(0) > T::MIN;
  
      // all valid digits are ascii, so we will just iterate over the utf8 bytes
      // and cast them to chars. .to_digit() will safely return None for anything
      // other than a valid ascii digit for the given radix, including the first-byte
      // of multi-byte sequences
      let src = src.as_bytes();
  
      let (is_positive, digits) = match src[0] {
          b'+' | b'-' if src[1..].is_empty() => {
              return Err(PIE { kind: InvalidDigit });
          }
          b'+' => (true, &src[1..]),
          b'-' if is_signed_ty => (false, &src[1..]),
          _ => (true, src),
      };
  
      let mut result = T::from_u32(0);
  
      if can_not_overflow::<T>(radix, is_signed_ty, digits) {
          // If the len of the str is short compared to the range of the type
          // we are parsing into, then we can be certain that an overflow will not occur.
          // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition
          // above is a faster (conservative) approximation of this.
          //
          // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:
          // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.
          // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.
          macro_rules! run_unchecked_loop {
              ($unchecked_additive_op:expr) => {
                  for &c in digits {
                      result = result * T::from_u32(radix);
                      let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;
                      result = $unchecked_additive_op(result, T::from_u32(x));
                  }
              };
          }
          if is_positive {
              run_unchecked_loop!(<T as core::ops::Add>::add)
          } else {
              run_unchecked_loop!(<T as core::ops::Sub>::sub)
          };
      } else {
          macro_rules! run_checked_loop {
              ($checked_additive_op:ident, $overflow_err:expr) => {
                  for &c in digits {
                      // When `radix` is passed in as a literal, rather than doing a slow `imul`
                      // the compiler can use shifts if `radix` can be expressed as a
                      // sum of powers of 2 (x*10 can be written as x*8 + x*2).
                      // When the compiler can't use these optimisations,
                      // the latency of the multiplication can be hidden by issuing it
                      // before the result is needed to improve performance on
                      // modern out-of-order CPU as multiplication here is slower
                      // than the other instructions, we can get the end result faster
                      // doing multiplication first and let the CPU spends other cycles
                      // doing other computation and get multiplication result later.
                      let mul = result.checked_mul(radix);
                      let x = (c as char).to_digit(radix).ok_or(PIE { kind: InvalidDigit })?;
                      result = mul.ok_or_else($overflow_err)?;
                      result = T::$checked_additive_op(&result, x).ok_or_else($overflow_err)?;
                  }
              };
          }
          if is_positive {
              run_checked_loop!(checked_add, || PIE { kind: PosOverflow })
          } else {
              run_checked_loop!(checked_sub, || PIE { kind: NegOverflow })
          };
      }
      Ok(result)
  }
  *)
  Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; radix ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let radix := M.alloc (| radix |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeInclusive")
                                      [ Ty.path "u32" ],
                                    "contains",
                                    [ Ty.path "u32" ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeInclusive")
                                            [ Ty.path "u32" ],
                                          "new",
                                          []
                                        |),
                                        [ Value.Integer 2; Value.Integer 36 ]
                                      |)
                                    |);
                                    radix
                                  ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic_fmt", [] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_v1",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "from_str_radix_int: must lie in the range `[2, 36]` - found "
                                            |)
                                          ]
                                      |));
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_display",
                                                [ Ty.path "u32" ]
                                              |),
                                              [ radix ]
                                            |)
                                          ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "str", "is_empty", [] |),
                                [ M.read (| src |) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    Value.StructRecord
                                      "core::num::error::ParseIntError"
                                      [
                                        ("kind",
                                          Value.StructTuple
                                            "core::num::error::IntErrorKind::Empty"
                                            [])
                                      ]
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ is_signed_ty :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "gt", [] |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::num::FromStrRadixHelper",
                            T,
                            [],
                            "from_u32",
                            []
                          |),
                          [ Value.Integer 0 ]
                        |)
                      |);
                      M.get_constant (| "core::num::FromStrRadixHelper::MIN" |)
                    ]
                  |)
                |) in
              let~ src :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                    [ M.read (| src |) ]
                  |)
                |) in
              M.match_operator (|
                M.match_operator (|
                  M.SubPointer.get_array_field (|
                    M.read (| src |),
                    M.alloc (| Value.Integer 0 |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.find_or_pattern (|
                          γ,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Integer 43
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Integer 45
                                  |) in
                                Value.Tuple []))
                          ],
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [] =>
                                  let γ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                          "is_empty",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeFrom")
                                                  [ Ty.path "usize" ]
                                              ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.read (| src |);
                                              Value.StructRecord
                                                "core::ops::range::RangeFrom"
                                                [ ("start", Value.Integer 1) ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [
                                              Value.StructRecord
                                                "core::num::error::ParseIntError"
                                                [
                                                  ("kind",
                                                    Value.StructTuple
                                                      "core::num::error::IntErrorKind::InvalidDigit"
                                                      [])
                                                ]
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 43 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Bool true;
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (| src |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    [ ("start", Value.Integer 1) ]
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 45 |) in
                        let γ := is_signed_ty in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Bool false;
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (| src |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    [ ("start", Value.Integer 1) ]
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (| Value.Tuple [ Value.Bool true; M.read (| src |) ] |)))
                  ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let is_positive := M.copy (| γ0_0 |) in
                      let digits := M.copy (| γ0_1 |) in
                      let~ result :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::num::FromStrRadixHelper",
                              T,
                              [],
                              "from_u32",
                              []
                            |),
                            [ Value.Integer 0 ]
                          |)
                        |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_function (| "core::num::can_not_overflow", [ T ] |),
                                        [
                                          M.read (| radix |);
                                          M.read (| is_signed_ty |);
                                          M.read (| digits |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use is_positive in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.use
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]
                                                      ],
                                                    [],
                                                    "into_iter",
                                                    []
                                                  |),
                                                  [ M.read (| digits |) ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let iter := M.copy (| γ |) in
                                                    M.loop (|
                                                      ltac:(M.monadic
                                                        (let~ _ :=
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [ Ty.path "u8" ],
                                                                  [],
                                                                  "next",
                                                                  []
                                                                |),
                                                                [ iter ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let γ0_0 := M.read (| γ0_0 |) in
                                                                  let c := M.copy (| γ0_0 |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::arith::Mul",
                                                                          T,
                                                                          [ T ],
                                                                          "mul",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (| result |);
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::num::FromStrRadixHelper",
                                                                              T,
                                                                              [],
                                                                              "from_u32",
                                                                              []
                                                                            |),
                                                                            [ M.read (| radix |) ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ x :=
                                                                    M.copy (|
                                                                      M.match_operator (|
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::Try",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path "u32";
                                                                                  Ty.path
                                                                                    "core::num::error::ParseIntError"
                                                                                ],
                                                                              [],
                                                                              "branch",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    [ Ty.path "u32"
                                                                                    ],
                                                                                  "ok_or",
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.path
                                                                                        "char",
                                                                                      "to_digit",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.rust_cast
                                                                                        (M.read (|
                                                                                          c
                                                                                        |));
                                                                                      M.read (|
                                                                                        radix
                                                                                      |)
                                                                                    ]
                                                                                  |);
                                                                                  Value.StructRecord
                                                                                    "core::num::error::ParseIntError"
                                                                                    [
                                                                                      ("kind",
                                                                                        Value.StructTuple
                                                                                          "core::num::error::IntErrorKind::InvalidDigit"
                                                                                          [])
                                                                                    ]
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                                  0
                                                                                |) in
                                                                              let residual :=
                                                                                M.copy (| γ0_0 |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::try_trait::FromResidual",
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::result::Result")
                                                                                            [
                                                                                              T;
                                                                                              Ty.path
                                                                                                "core::num::error::ParseIntError"
                                                                                            ],
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                Ty.path
                                                                                                  "core::convert::Infallible";
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ]
                                                                                          ],
                                                                                          "from_residual",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            residual
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                                  0
                                                                                |) in
                                                                              let val :=
                                                                                M.copy (| γ0_0 |) in
                                                                              val))
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::arith::Add",
                                                                          T,
                                                                          [ T ],
                                                                          "add",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (| result |);
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::num::FromStrRadixHelper",
                                                                              T,
                                                                              [],
                                                                              "from_u32",
                                                                              []
                                                                            |),
                                                                            [ M.read (| x |) ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                    |)))
                                              ]
                                            |))));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.use
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]
                                                      ],
                                                    [],
                                                    "into_iter",
                                                    []
                                                  |),
                                                  [ M.read (| digits |) ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let iter := M.copy (| γ |) in
                                                    M.loop (|
                                                      ltac:(M.monadic
                                                        (let~ _ :=
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [ Ty.path "u8" ],
                                                                  [],
                                                                  "next",
                                                                  []
                                                                |),
                                                                [ iter ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let γ0_0 := M.read (| γ0_0 |) in
                                                                  let c := M.copy (| γ0_0 |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::arith::Mul",
                                                                          T,
                                                                          [ T ],
                                                                          "mul",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (| result |);
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::num::FromStrRadixHelper",
                                                                              T,
                                                                              [],
                                                                              "from_u32",
                                                                              []
                                                                            |),
                                                                            [ M.read (| radix |) ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ x :=
                                                                    M.copy (|
                                                                      M.match_operator (|
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::Try",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path "u32";
                                                                                  Ty.path
                                                                                    "core::num::error::ParseIntError"
                                                                                ],
                                                                              [],
                                                                              "branch",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    [ Ty.path "u32"
                                                                                    ],
                                                                                  "ok_or",
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.path
                                                                                        "char",
                                                                                      "to_digit",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.rust_cast
                                                                                        (M.read (|
                                                                                          c
                                                                                        |));
                                                                                      M.read (|
                                                                                        radix
                                                                                      |)
                                                                                    ]
                                                                                  |);
                                                                                  Value.StructRecord
                                                                                    "core::num::error::ParseIntError"
                                                                                    [
                                                                                      ("kind",
                                                                                        Value.StructTuple
                                                                                          "core::num::error::IntErrorKind::InvalidDigit"
                                                                                          [])
                                                                                    ]
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                                  0
                                                                                |) in
                                                                              let residual :=
                                                                                M.copy (| γ0_0 |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::try_trait::FromResidual",
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::result::Result")
                                                                                            [
                                                                                              T;
                                                                                              Ty.path
                                                                                                "core::num::error::ParseIntError"
                                                                                            ],
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                Ty.path
                                                                                                  "core::convert::Infallible";
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ]
                                                                                          ],
                                                                                          "from_residual",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            residual
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                                  0
                                                                                |) in
                                                                              let val :=
                                                                                M.copy (| γ0_0 |) in
                                                                              val))
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::arith::Sub",
                                                                          T,
                                                                          [ T ],
                                                                          "sub",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (| result |);
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::num::FromStrRadixHelper",
                                                                              T,
                                                                              [],
                                                                              "from_u32",
                                                                              []
                                                                            |),
                                                                            [ M.read (| x |) ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                    |)))
                                              ]
                                            |))))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use is_positive in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.use
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]
                                                      ],
                                                    [],
                                                    "into_iter",
                                                    []
                                                  |),
                                                  [ M.read (| digits |) ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let iter := M.copy (| γ |) in
                                                    M.loop (|
                                                      ltac:(M.monadic
                                                        (let~ _ :=
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [ Ty.path "u8" ],
                                                                  [],
                                                                  "next",
                                                                  []
                                                                |),
                                                                [ iter ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let γ0_0 := M.read (| γ0_0 |) in
                                                                  let c := M.copy (| γ0_0 |) in
                                                                  let~ mul :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::num::FromStrRadixHelper",
                                                                          T,
                                                                          [],
                                                                          "checked_mul",
                                                                          []
                                                                        |),
                                                                        [ result; M.read (| radix |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ x :=
                                                                    M.copy (|
                                                                      M.match_operator (|
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::Try",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path "u32";
                                                                                  Ty.path
                                                                                    "core::num::error::ParseIntError"
                                                                                ],
                                                                              [],
                                                                              "branch",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    [ Ty.path "u32"
                                                                                    ],
                                                                                  "ok_or",
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.path
                                                                                        "char",
                                                                                      "to_digit",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.rust_cast
                                                                                        (M.read (|
                                                                                          c
                                                                                        |));
                                                                                      M.read (|
                                                                                        radix
                                                                                      |)
                                                                                    ]
                                                                                  |);
                                                                                  Value.StructRecord
                                                                                    "core::num::error::ParseIntError"
                                                                                    [
                                                                                      ("kind",
                                                                                        Value.StructTuple
                                                                                          "core::num::error::IntErrorKind::InvalidDigit"
                                                                                          [])
                                                                                    ]
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                                  0
                                                                                |) in
                                                                              let residual :=
                                                                                M.copy (| γ0_0 |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::try_trait::FromResidual",
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::result::Result")
                                                                                            [
                                                                                              T;
                                                                                              Ty.path
                                                                                                "core::num::error::ParseIntError"
                                                                                            ],
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                Ty.path
                                                                                                  "core::convert::Infallible";
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ]
                                                                                          ],
                                                                                          "from_residual",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            residual
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                                  0
                                                                                |) in
                                                                              let val :=
                                                                                M.copy (| γ0_0 |) in
                                                                              val))
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.read (|
                                                                        M.match_operator (|
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::try_trait::Try",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ],
                                                                                [],
                                                                                "branch",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [ T ],
                                                                                    "ok_or_else",
                                                                                    [
                                                                                      Ty.path
                                                                                        "core::num::error::ParseIntError";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "core::num::error::ParseIntError")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      mul
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (Value.StructRecord
                                                                                                      "core::num::error::ParseIntError"
                                                                                                      [
                                                                                                        ("kind",
                                                                                                          Value.StructTuple
                                                                                                            "core::num::error::IntErrorKind::PosOverflow"
                                                                                                            [])
                                                                                                      ]))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                                    0
                                                                                  |) in
                                                                                let residual :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.never_to_any (|
                                                                                    M.read (|
                                                                                      M.return_ (|
                                                                                        M.call_closure (|
                                                                                          M.get_trait_method (|
                                                                                            "core::ops::try_trait::FromResidual",
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                T;
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ],
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "core::result::Result")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "core::convert::Infallible";
                                                                                                  Ty.path
                                                                                                    "core::num::error::ParseIntError"
                                                                                                ]
                                                                                            ],
                                                                                            "from_residual",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              residual
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                                    0
                                                                                  |) in
                                                                                let val :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                val))
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.read (|
                                                                        M.match_operator (|
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::try_trait::Try",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ],
                                                                                [],
                                                                                "branch",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [ T ],
                                                                                    "ok_or_else",
                                                                                    [
                                                                                      Ty.path
                                                                                        "core::num::error::ParseIntError";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "core::num::error::ParseIntError")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_trait_method (|
                                                                                        "core::num::FromStrRadixHelper",
                                                                                        T,
                                                                                        [],
                                                                                        "checked_add",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        result;
                                                                                        M.read (|
                                                                                          x
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (Value.StructRecord
                                                                                                      "core::num::error::ParseIntError"
                                                                                                      [
                                                                                                        ("kind",
                                                                                                          Value.StructTuple
                                                                                                            "core::num::error::IntErrorKind::PosOverflow"
                                                                                                            [])
                                                                                                      ]))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                                    0
                                                                                  |) in
                                                                                let residual :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.never_to_any (|
                                                                                    M.read (|
                                                                                      M.return_ (|
                                                                                        M.call_closure (|
                                                                                          M.get_trait_method (|
                                                                                            "core::ops::try_trait::FromResidual",
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                T;
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ],
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "core::result::Result")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "core::convert::Infallible";
                                                                                                  Ty.path
                                                                                                    "core::num::error::ParseIntError"
                                                                                                ]
                                                                                            ],
                                                                                            "from_residual",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              residual
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                                    0
                                                                                  |) in
                                                                                let val :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                val))
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                    |)))
                                              ]
                                            |))));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.use
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]
                                                      ],
                                                    [],
                                                    "into_iter",
                                                    []
                                                  |),
                                                  [ M.read (| digits |) ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let iter := M.copy (| γ |) in
                                                    M.loop (|
                                                      ltac:(M.monadic
                                                        (let~ _ :=
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [ Ty.path "u8" ],
                                                                  [],
                                                                  "next",
                                                                  []
                                                                |),
                                                                [ iter ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let γ0_0 := M.read (| γ0_0 |) in
                                                                  let c := M.copy (| γ0_0 |) in
                                                                  let~ mul :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::num::FromStrRadixHelper",
                                                                          T,
                                                                          [],
                                                                          "checked_mul",
                                                                          []
                                                                        |),
                                                                        [ result; M.read (| radix |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ x :=
                                                                    M.copy (|
                                                                      M.match_operator (|
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::Try",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path "u32";
                                                                                  Ty.path
                                                                                    "core::num::error::ParseIntError"
                                                                                ],
                                                                              [],
                                                                              "branch",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    [ Ty.path "u32"
                                                                                    ],
                                                                                  "ok_or",
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.path
                                                                                        "char",
                                                                                      "to_digit",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.rust_cast
                                                                                        (M.read (|
                                                                                          c
                                                                                        |));
                                                                                      M.read (|
                                                                                        radix
                                                                                      |)
                                                                                    ]
                                                                                  |);
                                                                                  Value.StructRecord
                                                                                    "core::num::error::ParseIntError"
                                                                                    [
                                                                                      ("kind",
                                                                                        Value.StructTuple
                                                                                          "core::num::error::IntErrorKind::InvalidDigit"
                                                                                          [])
                                                                                    ]
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                                  0
                                                                                |) in
                                                                              let residual :=
                                                                                M.copy (| γ0_0 |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::try_trait::FromResidual",
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::result::Result")
                                                                                            [
                                                                                              T;
                                                                                              Ty.path
                                                                                                "core::num::error::ParseIntError"
                                                                                            ],
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                Ty.path
                                                                                                  "core::convert::Infallible";
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ]
                                                                                          ],
                                                                                          "from_residual",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            residual
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                                  0
                                                                                |) in
                                                                              let val :=
                                                                                M.copy (| γ0_0 |) in
                                                                              val))
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.read (|
                                                                        M.match_operator (|
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::try_trait::Try",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ],
                                                                                [],
                                                                                "branch",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [ T ],
                                                                                    "ok_or_else",
                                                                                    [
                                                                                      Ty.path
                                                                                        "core::num::error::ParseIntError";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "core::num::error::ParseIntError")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      mul
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (Value.StructRecord
                                                                                                      "core::num::error::ParseIntError"
                                                                                                      [
                                                                                                        ("kind",
                                                                                                          Value.StructTuple
                                                                                                            "core::num::error::IntErrorKind::NegOverflow"
                                                                                                            [])
                                                                                                      ]))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                                    0
                                                                                  |) in
                                                                                let residual :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.never_to_any (|
                                                                                    M.read (|
                                                                                      M.return_ (|
                                                                                        M.call_closure (|
                                                                                          M.get_trait_method (|
                                                                                            "core::ops::try_trait::FromResidual",
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                T;
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ],
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "core::result::Result")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "core::convert::Infallible";
                                                                                                  Ty.path
                                                                                                    "core::num::error::ParseIntError"
                                                                                                ]
                                                                                            ],
                                                                                            "from_residual",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              residual
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                                    0
                                                                                  |) in
                                                                                let val :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                val))
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      result,
                                                                      M.read (|
                                                                        M.match_operator (|
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::try_trait::Try",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "core::num::error::ParseIntError"
                                                                                  ],
                                                                                [],
                                                                                "branch",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [ T ],
                                                                                    "ok_or_else",
                                                                                    [
                                                                                      Ty.path
                                                                                        "core::num::error::ParseIntError";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "core::num::error::ParseIntError")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_trait_method (|
                                                                                        "core::num::FromStrRadixHelper",
                                                                                        T,
                                                                                        [],
                                                                                        "checked_sub",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        result;
                                                                                        M.read (|
                                                                                          x
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (Value.StructRecord
                                                                                                      "core::num::error::ParseIntError"
                                                                                                      [
                                                                                                        ("kind",
                                                                                                          Value.StructTuple
                                                                                                            "core::num::error::IntErrorKind::NegOverflow"
                                                                                                            [])
                                                                                                      ]))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                                    0
                                                                                  |) in
                                                                                let residual :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.never_to_any (|
                                                                                    M.read (|
                                                                                      M.return_ (|
                                                                                        M.call_closure (|
                                                                                          M.get_trait_method (|
                                                                                            "core::ops::try_trait::FromResidual",
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "core::result::Result")
                                                                                              [
                                                                                                T;
                                                                                                Ty.path
                                                                                                  "core::num::error::ParseIntError"
                                                                                              ],
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "core::result::Result")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "core::convert::Infallible";
                                                                                                  Ty.path
                                                                                                    "core::num::error::ParseIntError"
                                                                                                ]
                                                                                            ],
                                                                                            "from_residual",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              residual
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ0_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                                    0
                                                                                  |) in
                                                                                let val :=
                                                                                  M.copy (|
                                                                                    γ0_0
                                                                                  |) in
                                                                                val))
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                    |)))
                                              ]
                                            |))))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                      |)))
                ]
              |)
            |)))
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_from_str_radix : M.IsFunction "core::num::from_str_radix" from_str_radix.
End num.
