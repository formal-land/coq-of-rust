(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module nonzero.
    (* StructTuple
      {
        name := "NonZeroU8";
        ty_params := [];
        fields := [ Ty.path "u8" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "u8",
                [ Ty.path "u8" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU8",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U8 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroU8::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroU8" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U8 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroU8" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU8", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u8" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU8",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u8" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU8",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u8",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroU8",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u8", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU8", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU8",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U8 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU8" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU8" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.U8 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU8" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU8" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroU8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroU8", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroU8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroU8_for_u8.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_ops_bit_BitOr_u8_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_u8_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU8_for_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU8",
                      [ Ty.path "core::num::nonzero::NonZeroU8" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_ops_bit_BitOrAssign_u8_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU8",
                      [ Ty.path "u8" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u8_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU8.
    
    (* StructTuple
      {
        name := "NonZeroU16";
        ty_params := [];
        fields := [ Ty.path "u16" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "u16",
                [ Ty.path "u16" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU16",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U16 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroU16::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroU16" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U16 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroU16" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU16", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u16" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU16",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u16" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU16",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u16",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroU16",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u16", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::nonzero::NonZeroU16",
                    0
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU16",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u16" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U16 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU16" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU16" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.U16 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU16" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU16" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroU16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroU16", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroU16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroU16_for_u16.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_ops_bit_BitOr_u16_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_u16_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU16_for_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU16",
                      [ Ty.path "core::num::nonzero::NonZeroU16" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_ops_bit_BitOrAssign_u16_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU16",
                      [ Ty.path "u16" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u16_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU16.
    
    (* StructTuple
      {
        name := "NonZeroU32";
        ty_params := [];
        fields := [ Ty.path "u32" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "u32", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "u32",
                [ Ty.path "u32" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "u32", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU32",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U32 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroU32::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroU32" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U32 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroU32" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU32", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u32" ] |),
                    [
                      M.read (|
                        M.use
                          (M.SubPointer.get_struct_tuple_field (|
                            self,
                            "core::num::nonzero::NonZeroU32",
                            0
                          |))
                      |)
                    ]
                  |)
                |))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u32" ] |),
                    [
                      M.read (|
                        M.use
                          (M.SubPointer.get_struct_tuple_field (|
                            self,
                            "core::num::nonzero::NonZeroU32",
                            0
                          |))
                      |)
                    ]
                  |)
                |))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u32",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroU32",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u32", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::nonzero::NonZeroU32",
                    0
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU32",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u32" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU32" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU32" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.U32 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU32" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU32" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroU32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroU32", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroU32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroU32_for_u32.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_ops_bit_BitOr_u32_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_u32_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU32_for_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU32",
                      [ Ty.path "core::num::nonzero::NonZeroU32" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_ops_bit_BitOrAssign_u32_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU32",
                      [ Ty.path "u32" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u32_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU32.
    
    (* StructTuple
      {
        name := "NonZeroU64";
        ty_params := [];
        fields := [ Ty.path "u64" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "u64", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "u64",
                [ Ty.path "u64" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "u64", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU64",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U64 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroU64::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroU64" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U64 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroU64" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU64", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u64" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU64",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u64" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU64",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u64",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroU64",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u64", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::nonzero::NonZeroU64",
                    0
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU64",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u64" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U64 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU64" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU64" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.U64 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU64" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU64" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroU64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroU64", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroU64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroU64_for_u64.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_ops_bit_BitOr_u64_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_u64_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU64_for_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU64",
                      [ Ty.path "core::num::nonzero::NonZeroU64" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_ops_bit_BitOrAssign_u64_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU64",
                      [ Ty.path "u64" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u64_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU64.
    
    (* StructTuple
      {
        name := "NonZeroU128";
        ty_params := [];
        fields := [ Ty.path "u128" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "u128", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "u128",
                [ Ty.path "u128" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "u128", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroU128",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U128 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroU128::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroU128" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U128 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroU128" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroU128", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u128" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU128",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u128" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroU128",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u128",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroU128",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u128", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::nonzero::NonZeroU128",
                    0
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU128",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroU128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroU128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "u128" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U128 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU128" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU128" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.U128 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroU128" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroU128" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroU128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                nonzero,
                "core::num::nonzero::NonZeroU128",
                0
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroU128" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroU128_for_u128.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_ops_bit_BitOr_u128_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_u128_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroU128_for_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU128",
                      [ Ty.path "core::num::nonzero::NonZeroU128" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_ops_bit_BitOrAssign_u128_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroU128",
                      [ Ty.path "u128" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u128_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "u128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroU128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroU128.
    
    (* StructTuple
      {
        name := "NonZeroUsize";
        ty_params := [];
        fields := [ Ty.path "usize" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "usize",
                [ Ty.path "usize" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "usize", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroUsize",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroUsize::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroUsize" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.Usize 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroUsize" [ M.read (| n |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroUsize", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "usize" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroUsize",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "usize" ] |),
                [
                  M.read (|
                    M.use
                      (M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroUsize",
                        0
                      |))
                  |)
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn checked_add(self, other: $Int) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_add(other) {
                              // SAFETY:
                              // - `checked_add` returns `None` on overflow
                              // - `self` is non-zero
                              // - the only way to get zero from an addition without overflow is for both
                              //   sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroUsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
                      pub const fn saturating_add(self, other: $Int) -> $Ty {
                          // SAFETY:
                          // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an addition without overflow is for both
                          //   sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }
                      }
      *)
      Definition saturating_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
                      pub const unsafe fn unchecked_add(self, other: $Int) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }
                      }
      *)
      Definition unchecked_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "unchecked_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
                      pub const fn checked_next_power_of_two(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_next_power_of_two() {
                              // SAFETY: The next power of two is positive
                              // and overflow is checked.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "usize",
                              "checked_next_power_of_two",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroUsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
                      pub const fn ilog2(self) -> u32 {
                          Self::BITS - 1 - self.leading_zeros()
                      }
      *)
      Definition ilog2 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroUsize",
                  "leading_zeros",
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
                      pub const fn ilog10(self) -> u32 {
                          super::int_log10::$Int(self.0)
                      }
      *)
      Definition ilog10 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::usize", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::nonzero::NonZeroUsize",
                    0
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
                      pub const fn midpoint(self, rhs: Self) -> Self {
                          // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                          // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                          // of the unsignedness of this number and also because $Ty is guaranteed to
                          // never being 0.
                          unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }
                      }
      *)
      Definition midpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "midpoint", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroUsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroUsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*
                      pub const fn is_power_of_two(self) -> bool {
                          // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                          // On the basic x86-64 target, this saves 3 instructions for the zero check.
                          // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                          // compared to the `POPCNT` implementation on the underlying integer type.
      
                          intrinsics::ctpop(self.get()) < 2
                      }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [ Ty.path "usize" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.Usize 2
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      (*                 pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroUsize" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "new",
                      []
                    |),
                    [ Value.Integer IntegerKind.Usize 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroUsize" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroUsize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                nonzero,
                "core::num::nonzero::NonZeroUsize",
                0
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroUsize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroUsize_for_usize.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_ops_bit_BitOr_usize_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_usize_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroUsize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroUsize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroUsize_for_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_ops_bit_BitOrAssign_usize_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      [ Ty.path "usize" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_usize_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroUsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroUsize.
    
    (* StructTuple
      {
        name := "NonZeroI8";
        ty_params := [];
        fields := [ Ty.path "i8" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "i8", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "i8",
                [ Ty.path "i8" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "i8", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI8",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.I8 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroI8::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroI8" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.I8 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroI8" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroI8", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u8" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI8",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u8" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI8",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI8",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI8",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI8",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "i8", "checked_neg", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroI8",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroI8",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI8",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroI8",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI8",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI8",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI8",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI8",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI8",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI8" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI8" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI8" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI8" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroI8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroI8", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroI8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroI8_for_i8.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_ops_bit_BitOr_i8_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_i8_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroI8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI8_for_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI8",
                      [ Ty.path "core::num::nonzero::NonZeroI8" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_ops_bit_BitOrAssign_i8_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI8",
                      [ Ty.path "i8" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i8_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI8",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI8.
    
    (* StructTuple
      {
        name := "NonZeroI16";
        ty_params := [];
        fields := [ Ty.path "i16" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "i16", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "i16",
                [ Ty.path "i16" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "i16", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI16",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.I16 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroI16::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroI16" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.I16 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroI16" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroI16", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u16" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI16",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u16" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI16",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI16",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI16",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI16",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "i16", "checked_neg", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroI16",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroI16",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI16",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroI16",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI16",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI16",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI16",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI16",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI16",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI16" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI16" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI16" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI16" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroI16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroI16", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroI16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroI16_for_i16.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_ops_bit_BitOr_i16_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_i16_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroI16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI16_for_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI16",
                      [ Ty.path "core::num::nonzero::NonZeroI16" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_ops_bit_BitOrAssign_i16_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI16",
                      [ Ty.path "i16" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i16_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI16",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI16.
    
    (* StructTuple
      {
        name := "NonZeroI32";
        ty_params := [];
        fields := [ Ty.path "i32" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "i32", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "i32",
                [ Ty.path "i32" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "i32", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI32",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.I32 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroI32::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroI32" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.I32 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroI32" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroI32", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u32" ] |),
                    [
                      M.rust_cast
                        (M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            self,
                            "core::num::nonzero::NonZeroI32",
                            0
                          |)
                        |))
                    ]
                  |)
                |))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u32" ] |),
                    [
                      M.rust_cast
                        (M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            self,
                            "core::num::nonzero::NonZeroI32",
                            0
                          |)
                        |))
                    ]
                  |)
                |))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI32",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI32",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI32",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "i32", "checked_neg", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroI32",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroI32",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI32",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroI32",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI32",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI32",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI32",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI32",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI32",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI32" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI32" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI32" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI32" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroI32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroI32", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroI32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroI32_for_i32.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_ops_bit_BitOr_i32_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_i32_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroI32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI32_for_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI32",
                      [ Ty.path "core::num::nonzero::NonZeroI32" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_ops_bit_BitOrAssign_i32_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI32",
                      [ Ty.path "i32" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i32_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI32",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI32.
    
    (* StructTuple
      {
        name := "NonZeroI64";
        ty_params := [];
        fields := [ Ty.path "i64" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "i64", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "i64",
                [ Ty.path "i64" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "i64", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI64",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.I64 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroI64::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroI64" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.I64 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroI64" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroI64", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u64" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI64",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u64" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI64",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI64",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI64",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI64",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "i64", "checked_neg", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroI64",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroI64",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI64",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroI64",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI64",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI64",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI64",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI64",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI64",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI64" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI64" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI64" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI64" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroI64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| nonzero, "core::num::nonzero::NonZeroI64", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroI64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroI64_for_i64.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_ops_bit_BitOr_i64_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_i64_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroI64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI64_for_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI64",
                      [ Ty.path "core::num::nonzero::NonZeroI64" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_ops_bit_BitOrAssign_i64_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI64",
                      [ Ty.path "i64" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i64_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI64",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI64.
    
    (* StructTuple
      {
        name := "NonZeroI128";
        ty_params := [];
        fields := [ Ty.path "i128" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "i128", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "i128",
                [ Ty.path "i128" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "i128", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroI128",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.I128 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroI128::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroI128" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.I128 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroI128" [ M.read (| n |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroI128", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "u128" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI128",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "u128" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroI128",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI128",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroU128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI128",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI128",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "i128", "checked_neg", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroI128",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroI128",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI128",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroI128",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroI128",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroI128",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI128",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroI128",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroI128",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI128" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI128" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroI128" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroI128" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroI128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                nonzero,
                "core::num::nonzero::NonZeroI128",
                0
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroI128" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroI128_for_i128.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_ops_bit_BitOr_i128_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_i128_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroI128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroI128_for_i128.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI128",
                      [ Ty.path "core::num::nonzero::NonZeroI128" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_ops_bit_BitOrAssign_i128_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroI128",
                      [ Ty.path "i128" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i128_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "i128", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroI128",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroI128.
    
    (* StructTuple
      {
        name := "NonZeroIsize";
        ty_params := [];
        fields := [ Ty.path "isize" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_clone_Clone_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             Ord *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             PartialOrd *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "isize",
                [ Ty.path "isize" ],
                "partial_cmp",
                []
              |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_hash_Hash_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::nonzero::NonZeroIsize",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      pub const unsafe fn new_unchecked(n: $Int) -> Self {
                          crate::panic::debug_assert_nounwind!(
                              n != 0,
                              concat!(stringify!($Ty), "::new_unchecked requires a non-zero argument")
                          );
                          // SAFETY: this is guaranteed to be safe by the caller.
                          unsafe {
                              Self(n)
                          }
                      }
      *)
      Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        BinOp.ne (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.Isize 0
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::panic_nounwind_fmt",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "NonZeroIsize::new_unchecked requires a non-zero argument"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |);
                                        Value.Bool false
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::num::nonzero::NonZeroIsize" [ M.read (| n |) ] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
      
      (*
                      pub const fn new(n: $Int) -> Option<Self> {
                          if n != 0 {
                              // SAFETY: we just checked that there's no `0`
                              Some(unsafe { Self(n) })
                          } else {
                              None
                          }
                      }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.Isize 0 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.StructTuple "core::num::nonzero::NonZeroIsize" [ M.read (| n |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                      pub const fn get(self) -> $Int {
                          self.0
                      }
      *)
      Definition get (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "core::num::nonzero::NonZeroIsize", 0 |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
      (*
                      pub const fn leading_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                          unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::ctlz_nonzero", [ Ty.path "usize" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroIsize",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                      pub const fn trailing_zeros(self) -> u32 {
                          // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                          unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }
                      }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::cttz_nonzero", [ Ty.path "usize" ] |),
                [
                  M.rust_cast
                    (M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::nonzero::NonZeroIsize",
                        0
                      |)
                    |))
                ]
              |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      (*
                      pub const fn abs(self) -> $Ty {
                          // SAFETY: This cannot overflow to zero.
                          unsafe { $Ty::new_unchecked(self.get().abs()) }
                      }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                      pub const fn checked_abs(self) -> Option<$Ty> {
                          if let Some(nz) = self.get().checked_abs() {
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              Some(unsafe { $Ty::new_unchecked(nz) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_abs", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroIsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroIsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
                      pub const fn overflowing_abs(self) -> ($Ty, bool) {
                          let (nz, flag) = self.get().overflowing_abs();
                          (
                              // SAFETY: absolute value of nonzero cannot yield zero values.
                              unsafe { $Ty::new_unchecked(nz) },
                              flag,
                          )
                      }
      *)
      Definition overflowing_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "overflowing_abs", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroIsize",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroIsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
                      pub const fn saturating_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }
                      }
      *)
      Definition saturating_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
                      pub const fn wrapping_abs(self) -> $Ty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }
                      }
      *)
      Definition wrapping_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
                      pub const fn unsigned_abs(self) -> $Uty {
                          // SAFETY: absolute value of nonzero cannot yield zero values.
                          unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }
                      }
      *)
      Definition unsigned_abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroUsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "unsigned_abs", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
                      pub const fn is_positive(self) -> bool {
                          self.get().is_positive()
                      }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_positive", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroIsize",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                      pub const fn is_negative(self) -> bool {
                          self.get().is_negative()
                      }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroIsize",
                    "get",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
                      pub const fn checked_neg(self) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_neg() {
                              // SAFETY: negation of nonzero cannot yield zero values.
                              return Some(unsafe { $Ty::new_unchecked(result) });
                          }
                          None
                      }
      *)
      Definition checked_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "isize",
                                    "checked_neg",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::num::nonzero::NonZeroIsize",
                                        "get",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroIsize",
                                            "new_unchecked",
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
                      pub const fn overflowing_neg(self) -> ($Ty, bool) {
                          let (result, overflow) = self.get().overflowing_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          ((unsafe { $Ty::new_unchecked(result) }), overflow)
                      }
      *)
      Definition overflowing_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "overflowing_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroIsize",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroIsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
                      pub const fn saturating_neg(self) -> $Ty {
                          if let Some(result) = self.checked_neg() {
                              return result;
                          }
                          $Ty::MAX
                      }
      *)
      Definition saturating_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroIsize",
                                    "checked_neg",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
                      pub const fn wrapping_neg(self) -> $Ty {
                          let result = self.get().wrapping_neg();
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(result) }
                      }
      *)
      Definition wrapping_neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "wrapping_neg", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroIsize",
                          "get",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroIsize",
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      (*
                      pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_mul(other.get()) {
                              // SAFETY:
                              // - `checked_mul` returns `None` on overflow
                              // - `self` and `other` are non-zero
                              // - the only way to get zero from a multiplication without overflow is for one
                              //   of the sides to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_mul", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroIsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroIsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroIsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                      pub const fn saturating_mul(self, other: $Ty) -> $Ty {
                          // SAFETY:
                          // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }
                      }
      *)
      Definition saturating_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                      pub const unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {
                          // SAFETY: The caller ensures there is no overflow.
                          unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }
                      }
      *)
      Definition unchecked_mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "unchecked_mul", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                      pub const fn checked_pow(self, other: u32) -> Option<$Ty> {
                          if let Some(result) = self.get().checked_pow(other) {
                              // SAFETY:
                              // - `checked_pow` returns `None` on overflow/underflow
                              // - `self` is non-zero
                              // - the only way to get zero from an exponentiation without overflow is
                              //   for base to be zero
                              //
                              // So the result cannot be zero.
                              Some(unsafe { $Ty::new_unchecked(result) })
                          } else {
                              None
                          }
                      }
      *)
      Definition checked_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_pow", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroIsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroIsize",
                                "new_unchecked",
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                      pub const fn saturating_pow(self, other: u32) -> $Ty {
                          // SAFETY:
                          // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                          //   all of which are non-zero
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }
                      }
      *)
      Definition saturating_pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_pow", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
      (*                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroIsize" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroIsize" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.path "core::num::nonzero::NonZeroIsize" *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "core::num::nonzero::NonZeroIsize" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "new",
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      (*                 pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
    End Impl_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZeroIsize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                      fn from(nonzero: $Ty) -> Self {
                          nonzero.0
                      }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                nonzero,
                "core::num::nonzero::NonZeroIsize",
                0
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "core::num::nonzero::NonZeroIsize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZeroIsize_for_isize.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn bitor(self, rhs: Self) -> Self::Output {
                          // SAFETY: since `self` and `rhs` are both nonzero, the
                          // result of the bitwise-or will be nonzero.
                          unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_ops_bit_BitOr_isize_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*                 type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn bitor(self, rhs: $Int) -> Self::Output {
                          // SAFETY: since `self` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `rhs`.
                          unsafe { $Ty::new_unchecked(self.get() | rhs) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
                  (M.read (| rhs |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_isize_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroIsize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn bitor(self, rhs: $Ty) -> Self::Output {
                          // SAFETY: since `rhs` is nonzero, the result of the
                          // bitwise-or will be nonzero regardless of the value of
                          // `self`.
                          unsafe { $Ty::new_unchecked(self | rhs.get()) }
                      }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                BinOp.bit_or
                  (M.read (| self |))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| rhs |) ]
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroIsize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_nonzero_NonZeroIsize_for_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn bitor_assign(&mut self, rhs: Self) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      [ Ty.path "core::num::nonzero::NonZeroIsize" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_ops_bit_BitOrAssign_isize_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn bitor_assign(&mut self, rhs: $Int) {
                          *self = *self | rhs;
                      }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      [ Ty.path "isize" ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_isize_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_Display_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          self.get().fmt(f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::num::nonzero::NonZeroIsize",
                      "get",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_core_num_nonzero_NonZeroIsize.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU8".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroU8" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU8",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "u8"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "u8" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroU8";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU8.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU16".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroU16" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU16",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "u16"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "u16" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroU16";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU16.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU32".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroU32" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU32",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "u32"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "u32" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroU32";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU32.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU64".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroU64" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU64",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "u64"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "u64" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroU64";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU64.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroU128".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroU128" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroU128",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "u128"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "u128" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroU128";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroU128.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroUsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroUsize".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "usize"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "usize" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroUsize";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroUsize.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroI8" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "i8"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "i8" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroI8";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI8.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroI16" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "i16"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "i16" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroI16";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI16.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroI32" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "i32"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "i32" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroI32";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI32.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroI64" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "i64"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "i64" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroI64";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI64.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroI128" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "i128"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "i128" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroI128";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroI128.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroIsize" ],
                    "ok_or",
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "new",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "isize"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::num::from_str_radix",
                                      [ Ty.path "isize" ]
                                    |),
                                    [ M.read (| src |); Value.Integer IntegerKind.U32 10 ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::num::nonzero::NonZeroIsize";
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZeroIsize.
    
    
    
    
    
    
    
    
    
    
    
    
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "u8" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU8",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU8_for_u8.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "u8" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU8",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU8" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU8_for_u8.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "u16" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU16",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU16_for_u16.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "u16" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU16",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU16" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU16_for_u16.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "u32" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU32",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU32_for_u32.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "u32" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU32",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU32" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU32_for_u32.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "u64" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU64",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU64_for_u64.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "u64" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU64",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU64" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU64_for_u64.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "u128" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU128",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroU128_for_u128.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "u128" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroU128",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroU128" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroU128_for_u128.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZeroUsize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                      fn div(self, other: $Ty) -> $Int {
                          // SAFETY: div by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_div(self, other.get()) }
                      }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [ Ty.path "usize" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroUsize",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroUsize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZeroUsize_for_usize.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroUsize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*                 type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                      fn rem(self, other: $Ty) -> $Int {
                          // SAFETY: rem by zero is checked because `other` is a nonzero,
                          // and MIN/-1 is checked because `self` is an unsigned int.
                          unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }
                      }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [ Ty.path "usize" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroUsize",
                    "get",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "core::num::nonzero::NonZeroUsize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZeroUsize_for_usize.
    
    
    
    
    
    
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI8.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI8".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI8",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "i8", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI8",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI8.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI16.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI16".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI16",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "i16", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI16",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI16.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI32.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI32".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI32",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "i32", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI32",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI32.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI64.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI64".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI64",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "i64", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI64",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI64.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI128.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroI128".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroI128",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "i128", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroI128",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroI128.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroIsize.
      Definition Self : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*                 type Output = $Ty; *)
      Definition _Output : Ty.t := Ty.path "core::num::nonzero::NonZeroIsize".
      
      (*
                      fn neg(self) -> $Ty {
                          // SAFETY: negation of nonzero cannot yield zero values.
                          unsafe { $Ty::new_unchecked(self.get().neg()) }
                      }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::num::nonzero::NonZeroIsize",
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", Ty.path "isize", [], "neg", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroIsize",
                        "get",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZeroIsize.
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  End nonzero.
End num.
