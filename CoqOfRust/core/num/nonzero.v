(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module nonzero.
    (* Trait *)
    (* Empty module 'ZeroablePrimitive' *)
    
    Module private.
      (* Trait *)
      (* Empty module 'Sealed' *)
      
      (* StructTuple
        {
          name := "NonZeroU8Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "u8" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroU8Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroU8Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU8Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU8Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU8Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU8Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroU8Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroU8Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU8Inner.
      
      (* StructTuple
        {
          name := "NonZeroU16Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "u16" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroU16Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroU16Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU16Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU16Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU16Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU16Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroU16Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroU16Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU16Inner.
      
      (* StructTuple
        {
          name := "NonZeroU32Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "u32" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroU32Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroU32Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU32Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU32Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU32Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU32Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroU32Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroU32Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU32Inner.
      
      (* StructTuple
        {
          name := "NonZeroU64Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "u64" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroU64Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroU64Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU64Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU64Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU64Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU64Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroU64Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroU64Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU64Inner.
      
      (* StructTuple
        {
          name := "NonZeroU128Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "u128" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroU128Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroU128Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroU128Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroU128Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroU128Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroU128Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroU128Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroU128Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroU128Inner.
      
      (* StructTuple
        {
          name := "NonZeroUsizeInner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "usize" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroUsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroUsizeInner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroUsizeInner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroUsizeInner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroUsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroUsizeInner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroUsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroUsizeInner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroUsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroUsizeInner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroUsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroUsizeInner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroUsizeInner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroUsizeInner.
      
      (* StructTuple
        {
          name := "NonZeroI8Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "i8" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroI8Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroI8Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI8Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI8Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI8Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI8Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI8Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroI8Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroI8Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI8Inner.
      
      (* StructTuple
        {
          name := "NonZeroI16Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "i16" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroI16Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroI16Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI16Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI16Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI16Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI16Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI16Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroI16Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroI16Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI16Inner.
      
      (* StructTuple
        {
          name := "NonZeroI32Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "i32" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroI32Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroI32Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI32Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI32Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI32Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI32Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI32Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroI32Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroI32Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI32Inner.
      
      (* StructTuple
        {
          name := "NonZeroI64Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "i64" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroI64Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroI64Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI64Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI64Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI64Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI64Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI64Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroI64Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroI64Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI64Inner.
      
      (* StructTuple
        {
          name := "NonZeroI128Inner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "i128" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroI128Inner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroI128Inner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroI128Inner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroI128Inner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroI128Inner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroI128Inner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI128Inner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroI128Inner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroI128Inner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroI128Inner.
      
      (* StructTuple
        {
          name := "NonZeroIsizeInner";
          const_params := [];
          ty_params := [];
          fields := [ Ty.path "isize" ];
        } *)
      
      Module Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroIsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
        
        (*                 Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| Value.String "NonZeroIsizeInner" |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::nonzero::private::NonZeroIsizeInner",
                              0
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_core_num_nonzero_private_NonZeroIsizeInner.
      
      Module Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroIsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
        
        (*                 Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_core_num_nonzero_private_NonZeroIsizeInner.
      
      Module Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroIsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_core_num_nonzero_private_NonZeroIsizeInner.
      
      Module Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroIsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_core_num_nonzero_private_NonZeroIsizeInner.
      
      Module Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroIsizeInner.
        Definition Self : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
        
        (*                 PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::private::NonZeroIsizeInner",
                    0
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::nonzero::private::NonZeroIsizeInner",
                    0
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_core_num_nonzero_private_NonZeroIsizeInner.
    End private.
    
    Module Impl_core_num_nonzero_private_Sealed_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_u8.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU8Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_u8.
    
    Module Impl_core_num_nonzero_private_Sealed_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_u16.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU16Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_u16.
    
    Module Impl_core_num_nonzero_private_Sealed_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_u32.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU32Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_u32.
    
    Module Impl_core_num_nonzero_private_Sealed_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_u64.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU64Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_u64.
    
    Module Impl_core_num_nonzero_private_Sealed_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_u128.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroU128Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_u128.
    
    Module Impl_core_num_nonzero_private_Sealed_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_usize.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroUsizeInner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_usize.
    
    Module Impl_core_num_nonzero_private_Sealed_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_i8.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI8Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_i8.
    
    Module Impl_core_num_nonzero_private_Sealed_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_i16.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI16Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_i16.
    
    Module Impl_core_num_nonzero_private_Sealed_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_i32.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI32Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_i32.
    
    Module Impl_core_num_nonzero_private_Sealed_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_i64.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI64Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_i64.
    
    Module Impl_core_num_nonzero_private_Sealed_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_i128.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroI128Inner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_i128.
    
    Module Impl_core_num_nonzero_private_Sealed_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::private::Sealed"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_num_nonzero_private_Sealed_for_isize.
    
    Module Impl_core_num_nonzero_ZeroablePrimitive_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*                 type NonZeroInner = private::$NonZeroInner; *)
      Definition _NonZeroInner : Ty.t := Ty.path "core::num::nonzero::private::NonZeroIsizeInner".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::num::nonzero::ZeroablePrimitive"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("NonZeroInner", InstanceField.Ty _NonZeroInner) ].
    End Impl_core_num_nonzero_ZeroablePrimitive_for_isize.
    
    (* StructTuple
      {
        name := "NonZero";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ Ty.associated ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Debug_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Debug_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_fmt_Display_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Display_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Display_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Display_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_fmt_Binary_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Binary_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Binary"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Binary_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Binary_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_fmt_Octal_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Octal_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Octal"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Octal_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_Octal_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_fmt_LowerHex_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_LowerHex_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_LowerHex_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_LowerHex_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_fmt_UpperHex_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_UpperHex_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      self.get().fmt(f)
                  }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_UpperHex_where_core_num_nonzero_ZeroablePrimitive_T_where_core_fmt_UpperHex_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_Freeze_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Freeze_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Freeze"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Freeze_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Freeze_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_num_nonzero_ZeroablePrimitive_T_where_core_panic_unwind_safe_RefUnwindSafe_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::panic::unwind_safe::RefUnwindSafe"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_num_nonzero_ZeroablePrimitive_T_where_core_panic_unwind_safe_RefUnwindSafe_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_Send_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Send_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Send_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_Sync_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Sync_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Sync_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_Unpin_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Unpin_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Unpin"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Unpin_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_Unpin_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_panic_unwind_safe_UnwindSafe_where_core_num_nonzero_ZeroablePrimitive_T_where_core_panic_unwind_safe_UnwindSafe_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::panic::unwind_safe::UnwindSafe"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_panic_unwind_safe_UnwindSafe_where_core_num_nonzero_ZeroablePrimitive_T_where_core_panic_unwind_safe_UnwindSafe_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_clone_Clone_where_core_num_nonzero_ZeroablePrimitive_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              Self(self.0)
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::nonzero::NonZero"
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::nonzero::NonZero",
                    0
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_num_nonzero_ZeroablePrimitive_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_Copy_where_core_num_nonzero_ZeroablePrimitive_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_num_nonzero_ZeroablePrimitive_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_cmp_PartialEq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_PartialEq_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn eq(&self, other: &Self) -> bool {
              self.get() == other.get()
          }
      *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn ne(&self, other: &Self) -> bool {
              self.get() != other.get()
          }
      *)
      Definition ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("eq", InstanceField.Method (eq T)); ("ne", InstanceField.Method (ne T)) ].
    End Impl_core_cmp_PartialEq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_PartialEq_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_marker_StructuralPartialEq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_StructuralPartialEq_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_marker_StructuralPartialEq_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_cmp_Eq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_Eq_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_Eq_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_PartialOrd_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
              self.get().partial_cmp(&other.get())
          }
      *)
      Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "partial_cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                            "get",
                            [],
                            []
                          |),
                          [ M.read (| M.deref (| M.read (| other |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn lt(&self, other: &Self) -> bool {
              self.get() < other.get()
          }
      *)
      Definition lt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "lt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn le(&self, other: &Self) -> bool {
              self.get() <= other.get()
          }
      *)
      Definition le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "le", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn gt(&self, other: &Self) -> bool {
              self.get() > other.get()
          }
      *)
      Definition gt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "gt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn ge(&self, other: &Self) -> bool {
              self.get() >= other.get()
          }
      *)
      Definition ge (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "ge", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| other |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("partial_cmp", InstanceField.Method (partial_cmp T));
            ("lt", InstanceField.Method (lt T));
            ("le", InstanceField.Method (le T));
            ("gt", InstanceField.Method (gt T));
            ("ge", InstanceField.Method (ge T))
          ].
    End Impl_core_cmp_PartialOrd_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_PartialOrd_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_cmp_Ord_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_Ord_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn cmp(&self, other: &Self) -> Ordering {
              self.get().cmp(&other.get())
          }
      *)
      Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                            "get",
                            [],
                            []
                          |),
                          [ M.read (| M.deref (| M.read (| other |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn max(self, other: Self) -> Self {
              // SAFETY: The maximum of two non-zero values is still non-zero.
              unsafe { Self::new_unchecked(self.get().max(other.get())) }
          }
      *)
      Definition max (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", T, [], [], "max", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn min(self, other: Self) -> Self {
              // SAFETY: The minimum of two non-zero values is still non-zero.
              unsafe { Self::new_unchecked(self.get().min(other.get())) }
          }
      *)
      Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", T, [], [], "min", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn clamp(self, min: Self, max: Self) -> Self {
              // SAFETY: A non-zero value clamped between two non-zero values is still non-zero.
              unsafe { Self::new_unchecked(self.get().clamp(min.get(), max.get())) }
          }
      *)
      Definition clamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; min; max ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let min := M.alloc (| min |) in
            let max := M.alloc (| max |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", T, [], [], "clamp", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| min |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| max |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("cmp", InstanceField.Method (cmp T));
            ("max", InstanceField.Method (max T));
            ("min", InstanceField.Method (min T));
            ("clamp", InstanceField.Method (clamp T))
          ].
    End Impl_core_cmp_Ord_where_core_num_nonzero_ZeroablePrimitive_T_where_core_cmp_Ord_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_hash_Hash_where_core_num_nonzero_ZeroablePrimitive_T_where_core_hash_Hash_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn hash<H>(&self, state: &mut H)
          where
              H: Hasher,
          {
              self.get().hash(state)
          }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_num_nonzero_ZeroablePrimitive_T_where_core_hash_Hash_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_convert_From_where_core_num_nonzero_ZeroablePrimitive_T_core_num_nonzero_NonZero_T_for_T.
      Definition Self (T : Ty.t) : Ty.t := T.
      
      (*
          fn from(nonzero: NonZero<T>) -> Self {
              // Call `get` method to keep range information.
              nonzero.get()
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ nonzero ] =>
          ltac:(M.monadic
            (let nonzero := M.alloc (| nonzero |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "get",
                [],
                []
              |),
              [ M.read (| nonzero |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_core_num_nonzero_ZeroablePrimitive_T_core_num_nonzero_NonZero_T_for_T.
    
    Module Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*     type Output = Self; *)
      Definition _Output (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn bitor(self, rhs: Self) -> Self::Output {
              // SAFETY: Bitwise OR of two non-zero values is still non-zero.
              unsafe { Self::new_unchecked(self.get() | rhs.get()) }
          }
      *)
      Definition bitor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::bit::BitOr", T, [], [ T ], "bitor", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output T)); ("bitor", InstanceField.Method (bitor T)) ].
    End Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*     type Output = Self; *)
      Definition _Output (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn bitor(self, rhs: T) -> Self::Output {
              // SAFETY: Bitwise OR of a non-zero value with anything is still non-zero.
              unsafe { Self::new_unchecked(self.get() | rhs) }
          }
      *)
      Definition bitor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::bit::BitOr", T, [], [ T ], "bitor", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| rhs |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (Self T)
          (* Trait polymorphic types *) [ (* Rhs *) T ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output T)); ("bitor", InstanceField.Method (bitor T)) ].
    End Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_core_num_nonzero_NonZero_T_for_T.
      Definition Self (T : Ty.t) : Ty.t := T.
      
      (*     type Output = NonZero<T>; *)
      Definition _Output (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn bitor(self, rhs: NonZero<T>) -> Self::Output {
              // SAFETY: Bitwise OR of anything with a non-zero value is still non-zero.
              unsafe { NonZero::new_unchecked(self | rhs.get()) }
          }
      *)
      Definition bitor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::ops::bit::BitOr", T, [], [ T ], "bitor", [], [] |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (Self T)
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output T)); ("bitor", InstanceField.Method (bitor T)) ].
    End Impl_core_ops_bit_BitOr_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_T_core_num_nonzero_NonZero_T_for_T.
    
    Module Impl_core_ops_bit_BitOrAssign_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_core_num_nonzero_NonZero_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn bitor_assign(&mut self, rhs: Self) {
              *self = *self | rhs;
          }
      *)
      Definition bitor_assign
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ],
                      "bitor",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign T)) ].
    End Impl_core_ops_bit_BitOrAssign_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_core_num_nonzero_NonZero_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_ops_bit_BitOrAssign_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_core_num_nonzero_NonZero_T_T_T_for_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          fn bitor_assign(&mut self, rhs: T) {
              *self = *self | rhs;
          }
      *)
      Definition bitor_assign
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                      [],
                      [ T ],
                      "bitor",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (Self T)
          (* Trait polymorphic types *) [ (* Rhs *) T ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign T)) ].
    End Impl_core_ops_bit_BitOrAssign_where_core_num_nonzero_ZeroablePrimitive_T_where_core_ops_bit_BitOr_core_num_nonzero_NonZero_T_T_T_for_core_num_nonzero_NonZero_T.
    
    Module Impl_core_num_nonzero_NonZero_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ].
      
      (*
          pub const fn new(n: T) -> Option<Self> {
              // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has
              //         the same layout and size as `T`, with `0` representing `None`.
              unsafe { intrinsics::transmute_unchecked(n) }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute_unchecked",
                [],
                [
                  T;
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ]
                ]
              |),
              [ M.read (| n |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub const unsafe fn new_unchecked(n: T) -> Self {
              match Self::new(n) {
                  Some(n) => n,
                  None => {
                      // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.
                      unsafe {
                          ub_checks::assert_unsafe_precondition!(
                              check_language_ub,
                              "NonZero::new_unchecked requires the argument to be non-zero",
                              () => false,
                          );
                          intrinsics::unreachable()
                      }
                  }
              }
          }
      *)
      Definition new_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      n));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::ub_checks::check_language_ub",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Self,
                                        "precondition_check.new_unchecked",
                                        [],
                                        []
                                      |),
                                      []
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unreachable", [], [] |),
                            []
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new_unchecked" (new_unchecked T).
      
      (*
          pub fn from_mut(n: &mut T) -> Option<&mut Self> {
              // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has
              //         the same layout and size as `T`, with `0` representing `None`.
              let opt_n = unsafe { &mut *(ptr::from_mut(n).cast::<Option<Self>>()) };
      
              opt_n.as_mut()
          }
      *)
      Definition from_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.read (|
              let~ opt_n :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "cast",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_function (| "core::ptr::from_mut", [], [ T ] |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| n |) |) |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ] ],
                    "as_mut",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| opt_n |) |) |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut" (from_mut T).
      
      (*
          pub unsafe fn from_mut_unchecked(n: &mut T) -> &mut Self {
              match Self::from_mut(n) {
                  Some(n) => n,
                  None => {
                      // SAFETY: The caller guarantees that `n` references a value that is non-zero, so this is unreachable.
                      unsafe {
                          ub_checks::assert_unsafe_precondition!(
                              check_library_ub,
                              "NonZero::from_mut_unchecked requires the argument to dereference as non-zero",
                              () => false,
                          );
                          intrinsics::unreachable()
                      }
                  }
              }
          }
      *)
      Definition from_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ],
                              "from_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| n |) |) |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let n := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| n |) |) |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.read (|
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::intrinsics::ub_checks",
                                                          [],
                                                          []
                                                        |),
                                                        []
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Self,
                                                        "precondition_check.from_mut_unchecked",
                                                        [],
                                                        []
                                                      |),
                                                      []
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::intrinsics::unreachable",
                                              [],
                                              []
                                            |),
                                            []
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut_unchecked" (from_mut_unchecked T).
      
      (*
          pub const fn get(self) -> T {
              // FIXME: This can be changed to simply `self.0` once LLVM supports `!range` metadata
              // for function arguments: https://github.com/llvm/llvm-project/issues/76628
              //
              // Rustc can set range metadata only if it loads `self` from
              // memory somewhere. If the value of `self` was from by-value argument
              // of some not-inlined function, LLVM don't have range metadata
              // to understand that the value cannot be zero.
              //
              // For now, using the transmute `assume`s the range at runtime.
              //
              // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity
              // of `.0` is such that this transmute is sound.
              unsafe { intrinsics::transmute_unchecked(self) }
          }
      *)
      Definition get (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute_unchecked",
                [],
                [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ T ]; T ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get" (get T).
    End Impl_core_num_nonzero_NonZero_T.
    
    Axiom NonZeroU8 :
      (Ty.path "core::num::nonzero::NonZeroU8") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ]).
    
    Module Impl_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u8" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u8" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.U8 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u8",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u8", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u8", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u8", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u8",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "u8" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u8_for_u8.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "u8",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u8_for_u8.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "u8" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u8_for_u8.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "u8",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u8_for_u8.
    
    Axiom NonZeroU16 :
      (Ty.path "core::num::nonzero::NonZeroU16") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ]).
    
    Module Impl_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u16" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u16" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.U16 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u16",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u16", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "u16" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u16", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u16",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "u16" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u16_for_u16.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "u16",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u16_for_u16.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "u16" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u16_for_u16.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "u16",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u16_for_u16.
    
    Axiom NonZeroU32 :
      (Ty.path "core::num::nonzero::NonZeroU32") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ]).
    
    Module Impl_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u32" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u32" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.U32 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u32",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u32", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "u32" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u32", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u32",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "u32" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u32_for_u32.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "u32",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u32_for_u32.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "u32" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u32_for_u32.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "u32",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u32_for_u32.
    
    Axiom NonZeroU64 :
      (Ty.path "core::num::nonzero::NonZeroU64") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ]).
    
    Module Impl_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u64" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u64" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.U64 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u64",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u64", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "u64" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u64", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u64",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "u64" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u64_for_u64.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "u64",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u64_for_u64.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "u64" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u64_for_u64.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "u64",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u64_for_u64.
    
    Axiom NonZeroU128 :
      (Ty.path "core::num::nonzero::NonZeroU128") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ]).
    
    Module Impl_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u128" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u128" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.U128 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "u128",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::u128", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "u128" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "u128", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "u128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "u128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "u128",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "u128" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_u128_for_u128.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "u128",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_u128_for_u128.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "u128" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_u128_for_u128.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "u128",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_u128_for_u128.
    
    Axiom NonZeroUsize :
      (Ty.path "core::num::nonzero::NonZeroUsize") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]).
    
    Module Impl_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "usize" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "usize" ] |),
              [
                M.read (|
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(1).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      "new",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.Usize 1 ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn checked_add(self, other: $Int) -> Option<Self> {
                  if let Some(result) = self.get().checked_add(other) {
                      // SAFETY:
                      // - `checked_add` returns `None` on overflow
                      // - `self` is non-zero
                      // - the only way to get zero from an addition without overflow is for both
                      //   sides to be zero
                      //
                      // So the result cannot be zero.
                      Some(unsafe { Self::new_unchecked(result) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_add", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "usize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
      
      (*
              pub const fn saturating_add(self, other: $Int) -> Self {
                  // SAFETY:
                  // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero
                  // - `self` is non-zero
                  // - the only way to get zero from an addition without overflow is for both
                  //   sides to be zero
                  //
                  // So the result cannot be zero.
                  unsafe { Self::new_unchecked(self.get().saturating_add(other)) }
              }
      *)
      Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_add :
        M.IsAssociatedFunction Self "saturating_add" saturating_add.
      
      (*
              pub const unsafe fn unchecked_add(self, other: $Int) -> Self {
                  // SAFETY: The caller ensures there is no overflow.
                  unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }
              }
      *)
      Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "unchecked_add", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_add :
        M.IsAssociatedFunction Self "unchecked_add" unchecked_add.
      
      (*
              pub const fn checked_next_power_of_two(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_next_power_of_two() {
                      // SAFETY: The next power of two is positive
                      // and overflow is checked.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_next_power_of_two
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "usize",
                              "checked_next_power_of_two",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "usize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_next_power_of_two :
        M.IsAssociatedFunction Self "checked_next_power_of_two" checked_next_power_of_two.
      
      (*
              pub const fn ilog2(self) -> u32 {
                  Self::BITS - 1 - self.leading_zeros()
              }
      *)
      Definition ilog2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              BinOp.Wrap.sub (|
                M.read (| M.get_constant (| "core::num::nonzero::BITS" |) |),
                Value.Integer IntegerKind.U32 1
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                  "leading_zeros",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog2 : M.IsAssociatedFunction Self "ilog2" ilog2.
      
      (*
              pub const fn ilog10(self) -> u32 {
                  super::int_log10::$Int(self.get())
              }
      *)
      Definition ilog10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::num::int_log10::usize", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ilog10 : M.IsAssociatedFunction Self "ilog10" ilog10.
      
      (*
              pub const fn midpoint(self, rhs: Self) -> Self {
                  // SAFETY: The only way to get `0` with midpoint is to have two opposite or
                  // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because
                  // of the unsignedness of this number and also because `Self` is guaranteed to
                  // never being 0.
                  unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }
              }
      *)
      Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "midpoint", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_midpoint : M.IsAssociatedFunction Self "midpoint" midpoint.
      
      (*
              pub const fn is_power_of_two(self) -> bool {
                  // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.
                  // On the basic x86-64 target, this saves 3 instructions for the zero check.
                  // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction
                  // compared to the `POPCNT` implementation on the underlying integer type.
      
                  intrinsics::ctpop(self.get()) < 2
              }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.lt (|
              M.call_closure (|
                M.get_function (| "core::intrinsics::ctpop", [], [ Ty.path "usize" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |),
              Value.Integer IntegerKind.U32 2
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
              pub const fn isqrt(self) -> Self {
                  let result = self.get().isqrt();
      
                  // SAFETY: Integer square root is a monotonically nondecreasing
                  // function, which means that increasing the input will never cause
                  // the output to decrease. Thus, since the input for nonzero
                  // unsigned integers has a lower bound of 1, the lower bound of the
                  // results will be sqrt(1), which is 1, so a result can't be zero.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition isqrt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "isqrt", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_isqrt : M.IsAssociatedFunction Self "isqrt" isqrt.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "usize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "usize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_ops_arith_Div_core_num_nonzero_NonZero_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn div(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Division by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_div(self, other.get()) }
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_div", [], [ Ty.path "usize" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_nonzero_NonZero_usize_for_usize.
    
    Module Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn div_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "usize",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_nonzero_NonZero_usize_for_usize.
    
    Module Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $Int; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn rem(self, other: NonZero<$Int>) -> $Int {
                      // SAFETY: Remainder by zero is checked because `other` is non-zero,
                      // and MIN/-1 is checked because `self` is an unsigned int.
                      unsafe { intrinsics::unchecked_rem(self, other.get()) }
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::unchecked_rem", [], [ Ty.path "usize" ] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_nonzero_NonZero_usize_for_usize.
    
    Module Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn rem_assign(&mut self, other: NonZero<$Int>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.path "usize",
                      [],
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *)
          [ (* Rhs *) Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_nonzero_NonZero_usize_for_usize.
    
    Axiom NonZeroI8 :
      (Ty.path "core::num::nonzero::NonZeroI8") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ]).
    
    Module Impl_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u8" ] |),
              [
                M.cast
                  (Ty.path "u8")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u8" ] |),
              [
                M.cast
                  (Ty.path "u8")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "i8",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "i8" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "i8" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "i8" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i8", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i8" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i8",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "i8",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i8.
    
    Axiom NonZeroI16 :
      (Ty.path "core::num::nonzero::NonZeroI16") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ]).
    
    Module Impl_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u16" ] |),
              [
                M.cast
                  (Ty.path "u16")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u16" ] |),
              [
                M.cast
                  (Ty.path "u16")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "i16",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "i16" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "i16" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "i16" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i16", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i16" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i16" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i16",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "i16",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i16.
    
    Axiom NonZeroI32 :
      (Ty.path "core::num::nonzero::NonZeroI32") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ]).
    
    Module Impl_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u32" ] |),
              [
                M.cast
                  (Ty.path "u32")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u32" ] |),
              [
                M.cast
                  (Ty.path "u32")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "i32",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "i32" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "i32" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "i32" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i32", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i32" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i32" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i32",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "i32",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i32.
    
    Axiom NonZeroI64 :
      (Ty.path "core::num::nonzero::NonZeroI64") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ]).
    
    Module Impl_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u64" ] |),
              [
                M.cast
                  (Ty.path "u64")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u64" ] |),
              [
                M.cast
                  (Ty.path "u64")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "i64",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "i64" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "i64" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "i64" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i64", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i64" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i64" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i64",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "i64",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i64.
    
    Axiom NonZeroI128 :
      (Ty.path "core::num::nonzero::NonZeroI128") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ]).
    
    Module Impl_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "u128" ] |),
              [
                M.cast
                  (Ty.path "u128")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "u128" ] |),
              [
                M.cast
                  (Ty.path "u128")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "i128",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "i128" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "i128" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "i128" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "i128", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "i128" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "i128" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i128"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "i128",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i128" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "i128",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_i128.
    
    Axiom NonZeroIsize :
      (Ty.path "core::num::nonzero::NonZeroIsize") =
        (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ]).
    
    Module Impl_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             pub const BITS: u32 = <$Int>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.
                      unsafe {
                          intrinsics::ctlz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::ctlz_nonzero", [], [ Ty.path "usize" ] |),
              [
                M.cast
                  (Ty.path "usize")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.
                      unsafe {
                          intrinsics::cttz_nonzero(self.get() as $Uint)
                      }
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::cttz_nonzero", [], [ Ty.path "usize" ] |),
              [
                M.cast
                  (Ty.path "usize")
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      "get",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn count_ones(self) -> NonZero<u32> {
                      // SAFETY:
                      // `self` is non-zero, which means it has at least one bit set, which means
                      // that the result of `count_ones` is non-zero.
                      unsafe { NonZero::new_unchecked(self.get().count_ones()) }
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "count_ones", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      let result = self.get().rotate_left(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "rotate_left", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      let result = self.get().rotate_right(n);
                      // SAFETY: Rotating bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "rotate_right", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      let result = self.get().swap_bytes();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "swap_bytes", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      let result = self.get().reverse_bits();
                      // SAFETY: Reversing bits preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "reverse_bits", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      let result = $Int::from_be(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "from_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      let result = $Int::from_le(x.get());
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "from_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      let result = self.get().to_be();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "to_be", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      let result = self.get().to_le();
                      // SAFETY: Shuffling bytes preserves the property int > 0.
                      unsafe { Self::new_unchecked(result) }
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "to_le", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*         pub const MIN: Self = Self::new(<$Int>::MIN).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*         pub const MAX: Self = Self::new(<$Int>::MAX).unwrap(); *)
      (* Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                  |)
                ]
              |)
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*
              pub const fn abs(self) -> Self {
                  // SAFETY: This cannot overflow to zero.
                  unsafe { Self::new_unchecked(self.get().abs()) }
              }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
              pub const fn checked_abs(self) -> Option<Self> {
                  if let Some(nz) = self.get().checked_abs() {
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      Some(unsafe { Self::new_unchecked(nz) })
                  } else {
                      None
                  }
              }
      *)
      Definition checked_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_abs", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "isize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let nz := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "isize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_abs : M.IsAssociatedFunction Self "checked_abs" checked_abs.
      
      (*
              pub const fn overflowing_abs(self) -> (Self, bool) {
                  let (nz, flag) = self.get().overflowing_abs();
                  (
                      // SAFETY: absolute value of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(nz) },
                      flag,
                  )
              }
      *)
      Definition overflowing_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "overflowing_abs", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let nz := M.copy (| γ0_0 |) in
                      let flag := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "isize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| nz |) ]
                            |);
                            M.read (| flag |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_abs :
        M.IsAssociatedFunction Self "overflowing_abs" overflowing_abs.
      
      (*
              pub const fn saturating_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().saturating_abs()) }
              }
      *)
      Definition saturating_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_abs :
        M.IsAssociatedFunction Self "saturating_abs" saturating_abs.
      
      (*
              pub const fn wrapping_abs(self) -> Self {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(self.get().wrapping_abs()) }
              }
      *)
      Definition wrapping_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_abs :
        M.IsAssociatedFunction Self "wrapping_abs" wrapping_abs.
      
      (*
              pub const fn unsigned_abs(self) -> NonZero<$Uint> {
                  // SAFETY: absolute value of nonzero cannot yield zero values.
                  unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }
              }
      *)
      Definition unsigned_abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "unsigned_abs", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unsigned_abs :
        M.IsAssociatedFunction Self "unsigned_abs" unsigned_abs.
      
      (*
              pub const fn is_positive(self) -> bool {
                  self.get().is_positive()
              }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_positive", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
              pub const fn is_negative(self) -> bool {
                  self.get().is_negative()
              }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_negative", [], [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
      
      (*
              pub const fn checked_neg(self) -> Option<Self> {
                  if let Some(result) = self.get().checked_neg() {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      return Some(unsafe { Self::new_unchecked(result) });
                  }
                  None
              }
      *)
      Definition checked_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "isize",
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::num::nonzero::NonZero")
                                          []
                                          [ Ty.path "isize" ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "isize" ],
                                            "new_unchecked",
                                            [],
                                            []
                                          |),
                                          [ M.read (| result |) ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_neg : M.IsAssociatedFunction Self "checked_neg" checked_neg.
      
      (*
              pub const fn overflowing_neg(self) -> (Self, bool) {
                  let (result, overflow) = self.get().overflowing_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  ((unsafe { Self::new_unchecked(result) }), overflow)
              }
      *)
      Definition overflowing_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "overflowing_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "isize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |);
                            M.read (| overflow |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_overflowing_neg :
        M.IsAssociatedFunction Self "overflowing_neg" overflowing_neg.
      
      (*
              pub const fn saturating_neg(self) -> Self {
                  if let Some(result) = self.checked_neg() {
                      return result;
                  }
                  Self::MAX
              }
      *)
      Definition saturating_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::num::nonzero::NonZero")
                                      []
                                      [ Ty.path "isize" ],
                                    "checked_neg",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let result := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| result |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.get_constant (| "core::num::nonzero::MAX" |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_neg :
        M.IsAssociatedFunction Self "saturating_neg" saturating_neg.
      
      (*
              pub const fn wrapping_neg(self) -> Self {
                  let result = self.get().wrapping_neg();
                  // SAFETY: negation of nonzero cannot yield zero values.
                  unsafe { Self::new_unchecked(result) }
              }
      *)
      Definition wrapping_neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "wrapping_neg", [], [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| result |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_neg :
        M.IsAssociatedFunction Self "wrapping_neg" wrapping_neg.
      
      (*
                  pub const fn checked_mul(self, other: Self) -> Option<Self> {
                      if let Some(result) = self.get().checked_mul(other.get()) {
                          // SAFETY:
                          // - `checked_mul` returns `None` on overflow
                          // - `self` and `other` are non-zero
                          // - the only way to get zero from a multiplication without overflow is for one
                          //   of the sides to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_mul", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "isize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "isize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "isize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
      
      (*
                  pub const fn saturating_mul(self, other: Self) -> Self {
                      // SAFETY:
                      // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` and `other` are non-zero
                      // - the only way to get zero from a multiplication without overflow is for one
                      //   of the sides to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }
                  }
      *)
      Definition saturating_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_mul :
        M.IsAssociatedFunction Self "saturating_mul" saturating_mul.
      
      (*
                  pub const unsafe fn unchecked_mul(self, other: Self) -> Self {
                      // SAFETY: The caller ensures there is no overflow.
                      unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }
                  }
      *)
      Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "unchecked_mul", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| other |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unchecked_mul :
        M.IsAssociatedFunction Self "unchecked_mul" unchecked_mul.
      
      (*
                  pub const fn checked_pow(self, other: u32) -> Option<Self> {
                      if let Some(result) = self.get().checked_pow(other) {
                          // SAFETY:
                          // - `checked_pow` returns `None` on overflow/underflow
                          // - `self` is non-zero
                          // - the only way to get zero from an exponentiation without overflow is
                          //   for base to be zero
                          //
                          // So the result cannot be zero.
                          Some(unsafe { Self::new_unchecked(result) })
                      } else {
                          None
                      }
                  }
      *)
      Definition checked_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "checked_pow", [], [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "isize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [ M.read (| self |) ]
                              |);
                              M.read (| other |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let result := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "isize" ],
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| result |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_checked_pow : M.IsAssociatedFunction Self "checked_pow" checked_pow.
      
      (*
                  pub const fn saturating_pow(self, other: u32) -> Self {
                      // SAFETY:
                      // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,
                      //   all of which are non-zero
                      // - `self` is non-zero
                      // - the only way to get zero from an exponentiation without overflow is
                      //   for base to be zero
                      //
                      // So the result cannot be zero.
                      unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }
                  }
      *)
      Definition saturating_pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "saturating_pow", [], [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| other |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_saturating_pow :
        M.IsAssociatedFunction Self "saturating_pow" saturating_pow.
    End Impl_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Err = ParseIntError; *)
      Definition _Err : Ty.t := Ty.path "core::num::error::ParseIntError".
      
      (*
                  fn from_str(src: &str) -> Result<Self, Self::Err> {
                      Self::new(<$Int>::from_str_radix(src, 10)?)
                          .ok_or(ParseIntError {
                              kind: IntErrorKind::Zero
                          })
                  }
      *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ],
                    "ok_or",
                    [],
                    [ Ty.path "core::num::error::ParseIntError" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::ParseIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "isize",
                                      "from_str_radix",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |);
                                      Value.Integer IntegerKind.U32 10
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::ParseIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::ParseIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    Value.StructRecord
                      "core::num::error::ParseIntError"
                      [ ("kind", Value.StructTuple "core::num::error::IntErrorKind::Zero" []) ]
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*
                  fn neg(self) -> Self {
                      // SAFETY: negation of nonzero cannot yield zero values.
                      unsafe { Self::new_unchecked(self.get().neg()) }
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.path "isize",
                    [],
                    [],
                    "neg",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_nonzero_NonZero_isize.
  End nonzero.
End num.
