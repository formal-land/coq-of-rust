(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module saturating.
    (* StructTuple
      {
        name := "Saturating";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ T ];
      } *)
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_num_saturating_Saturating_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* PartialEq *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_num_saturating_Saturating_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_core_num_saturating_Saturating_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* PartialOrd *)
      Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "partial_cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_core_num_saturating_Saturating_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* Ord *)
      Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "core::num::saturating::Saturating",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_default_Default_where_core_default_Default_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* Default *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_where_core_default_Default_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (* Hash *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_Display_where_core_fmt_Display_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Display", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Display_where_core_fmt_Display_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_Binary_where_core_fmt_Binary_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Binary", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Binary"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Binary_where_core_fmt_Binary_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_Octal_where_core_fmt_Octal_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Octal", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Octal"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Octal_where_core_fmt_Octal_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_LowerHex_where_core_fmt_LowerHex_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::LowerHex", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_LowerHex_where_core_fmt_LowerHex_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_fmt_UpperHex_where_core_fmt_UpperHex_T_for_core_num_saturating_Saturating_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::UpperHex", T, [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::saturating::Saturating",
                    0
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_UpperHex_where_core_fmt_UpperHex_T_for_core_num_saturating_Saturating_T.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_AddAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_SubAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_MulAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_DivAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "usize",
                    [],
                    [ Ty.path "usize" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_RemAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitXorAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_bit_BitAndAssign_usize_for_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "usize" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_usize_for_core_num_saturating_Saturating_usize.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_AddAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_SubAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_MulAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_DivAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "u8",
                    [],
                    [ Ty.path "u8" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_RemAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitXorAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_bit_BitAndAssign_u8_for_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u8_for_core_num_saturating_Saturating_u8.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_AddAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_SubAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_MulAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_DivAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "u16",
                    [],
                    [ Ty.path "u16" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_RemAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitXorAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_bit_BitAndAssign_u16_for_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u16" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u16_for_core_num_saturating_Saturating_u16.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_AddAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_SubAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_MulAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_DivAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "u32",
                    [],
                    [ Ty.path "u32" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_RemAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitXorAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_bit_BitAndAssign_u32_for_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u32" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u32_for_core_num_saturating_Saturating_u32.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_AddAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_SubAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_MulAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_DivAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "u64",
                    [],
                    [ Ty.path "u64" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_RemAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitXorAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_bit_BitAndAssign_u64_for_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u64" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u64_for_core_num_saturating_Saturating_u64.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_AddAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_SubAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_MulAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_DivAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u128" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_RemAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitXorAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_bit_BitAndAssign_u128_for_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "u128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "u128" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u128_for_core_num_saturating_Saturating_u128.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_AddAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_SubAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_MulAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_DivAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "isize",
                    [],
                    [ Ty.path "isize" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_RemAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitXorAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_bit_BitAndAssign_isize_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "isize" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "isize" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_isize_for_core_num_saturating_Saturating_isize.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_AddAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_SubAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_MulAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_DivAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "i8",
                    [],
                    [ Ty.path "i8" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_RemAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitXorAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_bit_BitAndAssign_i8_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ],
                        [],
                        [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i8_for_core_num_saturating_Saturating_i8.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_AddAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_SubAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_MulAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_DivAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "i16",
                    [],
                    [ Ty.path "i16" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_RemAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitXorAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_bit_BitAndAssign_i16_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i16" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i16_for_core_num_saturating_Saturating_i16.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_AddAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_SubAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_MulAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_DivAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "i32",
                    [],
                    [ Ty.path "i32" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_RemAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitXorAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_bit_BitAndAssign_i32_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i32" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i32_for_core_num_saturating_Saturating_i32.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_AddAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_SubAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_MulAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_DivAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "i64",
                    [],
                    [ Ty.path "i64" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_RemAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitXorAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_bit_BitAndAssign_i64_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i64" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i64_for_core_num_saturating_Saturating_i64.
    
    Module Impl_core_ops_arith_Add_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn add(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_add(other.0))
                  }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn add_assign(&mut self, other: Saturating<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_AddAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Saturating(other);
                  }
      *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn sub(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_sub(other.0))
                  }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn sub_assign(&mut self, other: Saturating<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_SubAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Saturating(other);
                  }
      *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn mul(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_mul(other.0))
                  }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn mul_assign(&mut self, other: Saturating<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_MulAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Saturating(other);
                  }
      *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_Div_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn div(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.saturating_div(other.0))
                  }
      *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_div", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn div_assign(&mut self, other: Saturating<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_DivAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Saturating(other);
                  }
      *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "div",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn rem(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0.rem(other.0))
                  }
      *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.path "i128",
                    [],
                    [ Ty.path "i128" ],
                    "rem",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn rem_assign(&mut self, other: Saturating<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_arith_RemAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Saturating(other);
                  }
      *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "rem",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn not(self) -> Saturating<$t> {
                      Saturating(!self.0)
                  }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                UnOp.not (|
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::saturating::Saturating",
                      0
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitXorAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Saturating(other);
                  }
      *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 | other.0)
                  }
      *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitor_assign(&mut self, other: Saturating<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitOrAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Saturating(other);
                  }
      *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Saturating<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {
                      Saturating(self.0 & other.0)
                  }
      *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitand_assign(&mut self, other: Saturating<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_core_num_saturating_Saturating_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_ops_bit_BitAndAssign_i128_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Saturating(other);
                  }
      *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "core::num::saturating::Saturating")
                          []
                          [ Ty.path "i128" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::num::saturating::Saturating")
                            []
                            [ Ty.path "i128" ]
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        Value.StructTuple "core::num::saturating::Saturating" [ M.read (| other |) ]
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i128_for_core_num_saturating_Saturating_i128.
    
    Module Impl_core_num_saturating_Saturating_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "usize", "MIN", Ty.path "usize" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "usize" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "usize", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "usize", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "usize", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "usize", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "usize", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "usize", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_usize.
    
    Module Impl_core_num_saturating_Saturating_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u8" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "u8", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u8", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u8", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u8", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u8", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "u8", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_u8.
    
    Module Impl_core_num_saturating_Saturating_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u16" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "u16", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u16", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u16", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u16", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u16", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "u16", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_u16.
    
    Module Impl_core_num_saturating_Saturating_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u32", "MIN", Ty.path "u32" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u32" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "u32", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "u32", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_u32.
    
    Module Impl_core_num_saturating_Saturating_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u64", "MIN", Ty.path "u64" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u64" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "u64", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u64", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u64", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u64", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u64", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "u64", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_u64.
    
    Module Impl_core_num_saturating_Saturating_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u128", "MIN", Ty.path "u128" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "u128" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "u128", "MAX", Ty.path "u128" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "u128", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u128", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u128", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u128", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u128", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "u128", "is_power_of_two", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction.C Self "is_power_of_two" is_power_of_two.
      Admitted.
      Global Typeclasses Opaque is_power_of_two.
    End Impl_core_num_saturating_Saturating_u128.
    
    Module Impl_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "isize", "MIN", Ty.path "isize" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "isize", "MAX", Ty.path "isize" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "isize", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "isize", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "isize", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "isize", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "isize", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "isize", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "isize", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_isize.
    
    Module Impl_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "i8", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i8", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i8", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i8", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i8", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i8", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i8", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_i8.
    
    Module Impl_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "i16", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i16", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i16", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i16", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i16", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i16", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i16", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_i16.
    
    Module Impl_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i32", "MIN", Ty.path "i32" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i32", "MAX", Ty.path "i32" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "i32", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i32", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i32", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i32", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i32", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i32", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i32", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_i32.
    
    Module Impl_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i64", "MIN", Ty.path "i64" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i64", "MAX", Ty.path "i64" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "i64", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i64", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i64", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i64", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i64", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i64", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i64", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_i64.
    
    Module Impl_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i128", "MIN", Ty.path "i128" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ] *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "core::num::saturating::Saturating"
              [ M.read (| get_associated_constant (| Ty.path "i128", "MAX", Ty.path "i128" |) |) ]
          |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (get_associated_constant (| Ty.path "i128", "BITS", Ty.path "u32" |))).
      
      Global Instance AssociatedConstant_value_BITS :
        M.IsAssociatedFunction.C Self "BITS" value_BITS.
      Admitted.
      Global Typeclasses Opaque value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i128", "count_ones", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_ones :
        M.IsAssociatedFunction.C Self "count_ones" count_ones.
      Admitted.
      Global Typeclasses Opaque count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i128", "count_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_count_zeros :
        M.IsAssociatedFunction.C Self "count_zeros" count_zeros.
      Admitted.
      Global Typeclasses Opaque count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i128", "trailing_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction.C Self "trailing_zeros" trailing_zeros.
      Admitted.
      Global Typeclasses Opaque trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Saturating(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "rotate_left", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_left :
        M.IsAssociatedFunction.C Self "rotate_left" rotate_left.
      Admitted.
      Global Typeclasses Opaque rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Saturating(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "rotate_right", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rotate_right :
        M.IsAssociatedFunction.C Self "rotate_right" rotate_right.
      Admitted.
      Global Typeclasses Opaque rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Saturating(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "swap_bytes", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap_bytes :
        M.IsAssociatedFunction.C Self "swap_bytes" swap_bytes.
      Admitted.
      Global Typeclasses Opaque swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Saturating(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "reverse_bits", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction.C Self "reverse_bits" reverse_bits.
      Admitted.
      Global Typeclasses Opaque reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Saturating(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "from_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_be : M.IsAssociatedFunction.C Self "from_be" from_be.
      Admitted.
      Global Typeclasses Opaque from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Saturating(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "from_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_le : M.IsAssociatedFunction.C Self "from_le" from_le.
      Admitted.
      Global Typeclasses Opaque from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Saturating(self.0.to_be())
                  }
      *)
      Definition to_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "to_be", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_be : M.IsAssociatedFunction.C Self "to_be" to_be.
      Admitted.
      Global Typeclasses Opaque to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Saturating(self.0.to_le())
                  }
      *)
      Definition to_le (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "to_le", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_le : M.IsAssociatedFunction.C Self "to_le" to_le.
      Admitted.
      Global Typeclasses Opaque to_le.
      
      (*
                  pub const fn pow(self, exp: u32) -> Self {
                      Saturating(self.0.saturating_pow(exp))
                  }
      *)
      Definition pow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_pow", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow : M.IsAssociatedFunction.C Self "pow" pow.
      Admitted.
      Global Typeclasses Opaque pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "i128", "leading_zeros", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
      Admitted.
      Global Typeclasses Opaque leading_zeros.
      
      (*
                  pub const fn abs(self) -> Saturating<$t> {
                      Saturating(self.0.saturating_abs())
                  }
      *)
      Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_abs", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
                  pub const fn signum(self) -> Saturating<$t> {
                      Saturating(self.0.signum())
                  }
      *)
      Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "signum", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
      Admitted.
      Global Typeclasses Opaque signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i128", "is_positive", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_positive :
        M.IsAssociatedFunction.C Self "is_positive" is_positive.
      Admitted.
      Global Typeclasses Opaque is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "i128", "is_negative", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "core::num::saturating::Saturating",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_negative :
        M.IsAssociatedFunction.C Self "is_negative" is_negative.
      Admitted.
      Global Typeclasses Opaque is_negative.
    End Impl_core_num_saturating_Saturating_i128.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "isize" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_isize.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i8" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i8.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i16" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i16.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i32" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i32.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i64" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i64.
    
    
    Module Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::saturating::Saturating") [] [ Ty.path "i128" ].
      
      (*
                  fn neg(self) -> Self {
                      Saturating(self.0.saturating_neg())
                  }
      *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::saturating::Saturating"
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "saturating_neg", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::saturating::Saturating",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_saturating_Saturating_i128.
    
    
    
    
    
    
  End saturating.
End num.
