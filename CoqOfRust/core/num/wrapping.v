(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module wrapping.
    (* StructTuple
      {
        name := "Wrapping";
        ty_params := [ "T" ];
        fields := [ T ];
      } *)
    
    Module Impl_core_marker_StructuralPartialEq_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* PartialEq *)
      Definition eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::wrapping::Wrapping",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_marker_StructuralEq_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* PartialOrd *)
      Definition partial_cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::wrapping::Wrapping",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* Ord *)
      Definition cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| other |),
                  "core::num::wrapping::Wrapping",
                  0
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_default_Default_where_core_default_Default_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* Default *)
      Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                  []
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_where_core_default_Default_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (* Hash *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_Display_where_core_fmt_Display_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Display_where_core_fmt_Display_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_Binary_where_core_fmt_Binary_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Binary", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Binary"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Binary_where_core_fmt_Binary_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_Octal_where_core_fmt_Octal_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Octal", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Octal"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Octal_where_core_fmt_Octal_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_LowerHex_where_core_fmt_LowerHex_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::LowerHex", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_LowerHex_where_core_fmt_LowerHex_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_fmt_UpperHex_where_core_fmt_UpperHex_T_for_core_num_wrapping_Wrapping_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::UpperHex", T, [], "fmt", [] |),
              [
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "core::num::wrapping::Wrapping",
                  0
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_UpperHex_where_core_fmt_UpperHex_T_for_core_num_wrapping_Wrapping_T.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (| M.get_constant (| "core::num::wrapping::shift_max::u8" |) |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (| M.get_constant (| "core::num::wrapping::shift_max::u8" |) |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u16" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u16" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u32" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u32" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u64" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u64" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u128" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::u128" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::platform::usize" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::platform::usize" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (| M.get_constant (| "core::num::wrapping::shift_max::i8" |) |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (| M.get_constant (| "core::num::wrapping::shift_max::i8" |) |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i16" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i16" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i32" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i32" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i64" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i64" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i128" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::i128" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn shl(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_shl", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::platform::isize" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self = *self << other;
                  }
      *)
      Definition shl_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.path "usize" ],
                      "shl",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn shr(self, other: $f) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))
                  }
      *)
      Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_shr", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (M.read (| other |))
                        (M.rust_cast
                          (M.read (|
                            M.get_constant (| "core::num::wrapping::shift_max::platform::isize" |)
                          |))))
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self = *self >> other;
                  }
      *)
      Definition shr_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.path "usize" ],
                      "shr",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_AddAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_SubAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_MulAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_DivAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_RemAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitXorAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_bit_BitAndAssign_usize_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_usize_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_AddAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_SubAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_MulAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_DivAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_RemAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitXorAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_bit_BitAndAssign_u8_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u8_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_AddAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_SubAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_MulAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_DivAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_RemAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitXorAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_bit_BitAndAssign_u16_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u16" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u16_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_AddAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_SubAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_MulAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_DivAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_RemAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitXorAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_bit_BitAndAssign_u32_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u32_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_AddAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_SubAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_MulAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_DivAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_RemAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitXorAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_bit_BitAndAssign_u64_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u64" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u64_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_AddAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_SubAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_MulAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_DivAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_RemAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitXorAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_bit_BitAndAssign_u128_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u128" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_u128_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_AddAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_SubAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_MulAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_DivAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_RemAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitXorAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_bit_BitAndAssign_isize_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "isize" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_isize_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_AddAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_SubAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_MulAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_DivAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_RemAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitXorAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_bit_BitAndAssign_i8_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i8" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i8_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_AddAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_SubAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_MulAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_DivAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_RemAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitXorAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_bit_BitAndAssign_i16_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i16" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i16_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_AddAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_SubAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_MulAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_DivAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_RemAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitXorAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_bit_BitAndAssign_i32_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i32" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i32_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_AddAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_SubAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_MulAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_DivAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_RemAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitXorAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_bit_BitAndAssign_i64_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i64" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i64_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_add(other.0))
                  }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn add_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self + other;
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "add",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_AddAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn add_assign(&mut self, other: $t) {
                      *self = *self + Wrapping(other);
                  }
      *)
      Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "add",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_sub(other.0))
                  }
      *)
      Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn sub_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self - other;
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "sub",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_SubAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn sub_assign(&mut self, other: $t) {
                      *self = *self - Wrapping(other);
                  }
      *)
      Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_mul(other.0))
                  }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_mul", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn mul_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self * other;
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "mul",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_MulAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn mul_assign(&mut self, other: $t) {
                      *self = *self * Wrapping(other);
                  }
      *)
      Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "mul",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_div(other.0))
                  }
      *)
      Definition div (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_div", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn div_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self / other;
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "div",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_DivAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn div_assign(&mut self, other: $t) {
                      *self = *self / Wrapping(other);
                  }
      *)
      Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "div",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_rem(other.0))
                  }
      *)
      Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_rem", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        other,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn rem_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self % other;
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "rem",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_RemAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn rem_assign(&mut self, other: $t) {
                      *self = *self % Wrapping(other);
                  }
      *)
      Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "rem",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn not(self) -> Wrapping<$t> {
                      Wrapping(!self.0)
                  }
      *)
      Definition not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                UnOp.Pure.not
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 ^ other.0)
                  }
      *)
      Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_xor
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self ^ other;
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitxor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitXorAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitxor_assign(&mut self, other: $t) {
                      *self = *self ^ Wrapping(other);
                  }
      *)
      Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitxor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 | other.0)
                  }
      *)
      Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_or
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitor_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self | other;
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitor",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitOrAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitor_assign(&mut self, other: $t) {
                      *self = *self | Wrapping(other);
                  }
      *)
      Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitor",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Wrapping<$t>; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {
                      Wrapping(self.0 & other.0)
                  }
      *)
      Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                BinOp.Pure.bit_and
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "core::num::wrapping::Wrapping",
                      0
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitand_assign(&mut self, other: Wrapping<$t>) {
                      *self = *self & other;
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitand",
                      []
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| other |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_bit_BitAndAssign_i128_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn bitand_assign(&mut self, other: $t) {
                      *self = *self & Wrapping(other);
                  }
      *)
      Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.write (|
                  M.read (| self |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                      [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                      "bitand",
                      []
                    |),
                    [
                      M.read (| M.read (| self |) |);
                      Value.StructTuple "core::num::wrapping::Wrapping" [ M.read (| other |) ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "i128" ]
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_i128_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             type Output = Self; *)
      Definition _Output : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*
                  fn neg(self) -> Self {
                      Wrapping(0) - self
                  }
      *)
      Definition neg (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ],
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ],
                "sub",
                []
              |),
              [
                Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_core_num_wrapping_Wrapping_i128.
    
    Module Impl_core_num_wrapping_Wrapping_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_usize.
    
    Module Impl_core_num_wrapping_Wrapping_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_u8.
    
    Module Impl_core_num_wrapping_Wrapping_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_u16.
    
    Module Impl_core_num_wrapping_Wrapping_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_u32.
    
    Module Impl_core_num_wrapping_Wrapping_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_u64.
    
    Module Impl_core_num_wrapping_Wrapping_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn is_power_of_two(self) -> bool {
                      self.0.is_power_of_two()
                  }
      *)
      Definition is_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "is_power_of_two", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_power_of_two :
        M.IsAssociatedFunction Self "is_power_of_two" is_power_of_two.
      
      (*
                  pub fn next_power_of_two(self) -> Self {
                      Wrapping(self.0.wrapping_next_power_of_two())
                  }
      *)
      Definition next_power_of_two (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_next_power_of_two", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next_power_of_two :
        M.IsAssociatedFunction Self "next_power_of_two" next_power_of_two.
    End Impl_core_num_wrapping_Wrapping_u128.
    
    Module Impl_core_num_wrapping_Wrapping_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_isize.
    
    Module Impl_core_num_wrapping_Wrapping_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_i8.
    
    Module Impl_core_num_wrapping_Wrapping_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_i16.
    
    Module Impl_core_num_wrapping_Wrapping_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_i32.
    
    Module Impl_core_num_wrapping_Wrapping_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_i64.
    
    Module Impl_core_num_wrapping_Wrapping_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
      
      (*             pub const MIN: Self = Self(<$t>::MIN); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MIN" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MIN : M.IsAssociatedConstant Self "value_MIN" value_MIN.
      
      (*             pub const MAX: Self = Self(<$t>::MAX); *)
      (* Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] *)
      Definition value_MAX : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::num::wrapping::Wrapping"
                [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
            |))).
      
      Axiom AssociatedConstant_value_MAX : M.IsAssociatedConstant Self "value_MAX" value_MAX.
      
      (*             pub const BITS: u32 = <$t>::BITS; *)
      (* Ty.path "u32" *)
      Definition value_BITS : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::BITS" |))).
      
      Axiom AssociatedConstant_value_BITS : M.IsAssociatedConstant Self "value_BITS" value_BITS.
      
      (*
                  pub const fn count_ones(self) -> u32 {
                      self.0.count_ones()
                  }
      *)
      Definition count_ones (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "count_ones", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_ones : M.IsAssociatedFunction Self "count_ones" count_ones.
      
      (*
                  pub const fn count_zeros(self) -> u32 {
                      self.0.count_zeros()
                  }
      *)
      Definition count_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "count_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_count_zeros : M.IsAssociatedFunction Self "count_zeros" count_zeros.
      
      (*
                  pub const fn trailing_zeros(self) -> u32 {
                      self.0.trailing_zeros()
                  }
      *)
      Definition trailing_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "trailing_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_trailing_zeros :
        M.IsAssociatedFunction Self "trailing_zeros" trailing_zeros.
      
      (*
                  pub const fn rotate_left(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_left(n))
                  }
      *)
      Definition rotate_left (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "rotate_left", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left : M.IsAssociatedFunction Self "rotate_left" rotate_left.
      
      (*
                  pub const fn rotate_right(self, n: u32) -> Self {
                      Wrapping(self.0.rotate_right(n))
                  }
      *)
      Definition rotate_right (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "rotate_right", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| n |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        M.IsAssociatedFunction Self "rotate_right" rotate_right.
      
      (*
                  pub const fn swap_bytes(self) -> Self {
                      Wrapping(self.0.swap_bytes())
                  }
      *)
      Definition swap_bytes (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "swap_bytes", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_bytes : M.IsAssociatedFunction Self "swap_bytes" swap_bytes.
      
      (*
                  pub const fn reverse_bits(self) -> Self {
                      Wrapping(self.0.reverse_bits())
                  }
      *)
      Definition reverse_bits (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "reverse_bits", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reverse_bits :
        M.IsAssociatedFunction Self "reverse_bits" reverse_bits.
      
      (*
                  pub const fn from_be(x: Self) -> Self {
                      Wrapping(<$t>::from_be(x.0))
                  }
      *)
      Definition from_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "from_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_be : M.IsAssociatedFunction Self "from_be" from_be.
      
      (*
                  pub const fn from_le(x: Self) -> Self {
                      Wrapping(<$t>::from_le(x.0))
                  }
      *)
      Definition from_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "from_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        x,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_le : M.IsAssociatedFunction Self "from_le" from_le.
      
      (*
                  pub const fn to_be(self) -> Self {
                      Wrapping(self.0.to_be())
                  }
      *)
      Definition to_be (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "to_be", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_be : M.IsAssociatedFunction Self "to_be" to_be.
      
      (*
                  pub const fn to_le(self) -> Self {
                      Wrapping(self.0.to_le())
                  }
      *)
      Definition to_le (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "to_le", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_le : M.IsAssociatedFunction Self "to_le" to_le.
      
      (*
                  pub fn pow(self, exp: u32) -> Self {
                      Wrapping(self.0.wrapping_pow(exp))
                  }
      *)
      Definition pow (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_pow", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |);
                    M.read (| exp |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pow : M.IsAssociatedFunction Self "pow" pow.
      (*
                  pub const fn leading_zeros(self) -> u32 {
                      self.0.leading_zeros()
                  }
      *)
      Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "leading_zeros", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_leading_zeros :
        M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
      
      (*
                  pub fn abs(self) -> Wrapping<$t> {
                      Wrapping(self.0.wrapping_abs())
                  }
      *)
      Definition abs (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_abs", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_abs : M.IsAssociatedFunction Self "abs" abs.
      
      (*
                  pub fn signum(self) -> Wrapping<$t> {
                      Wrapping(self.0.signum())
                  }
      *)
      Definition signum (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::num::wrapping::Wrapping"
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "signum", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "core::num::wrapping::Wrapping",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_signum : M.IsAssociatedFunction Self "signum" signum.
      
      (*
                  pub const fn is_positive(self) -> bool {
                      self.0.is_positive()
                  }
      *)
      Definition is_positive (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_positive", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_positive : M.IsAssociatedFunction Self "is_positive" is_positive.
      
      (*
                  pub const fn is_negative(self) -> bool {
                      self.0.is_negative()
                  }
      *)
      Definition is_negative (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "is_negative", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "core::num::wrapping::Wrapping", 0 |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_negative : M.IsAssociatedFunction Self "is_negative" is_negative.
    End Impl_core_num_wrapping_Wrapping_i128.
    
    
    
    
    
    
    
    
    
    
    
    
    
    Module shift_max.
      Module platform.
        Definition usize : Value.t :=
          M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::u64" |))).
        
        Definition isize : Value.t :=
          M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i64" |))).
      End platform.
      
      Definition i8 : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.U32
                (BinOp.Wrap.shl (Value.Integer 1) (Value.Integer 3))
                (Value.Integer 1)
            |))).
      
      Definition i16 : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.U32
                (BinOp.Wrap.shl (Value.Integer 1) (Value.Integer 4))
                (Value.Integer 1)
            |))).
      
      Definition i32 : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.U32
                (BinOp.Wrap.shl (Value.Integer 1) (Value.Integer 5))
                (Value.Integer 1)
            |))).
      
      Definition i64 : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.U32
                (BinOp.Wrap.shl (Value.Integer 1) (Value.Integer 6))
                (Value.Integer 1)
            |))).
      
      Definition i128 : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.U32
                (BinOp.Wrap.shl (Value.Integer 1) (Value.Integer 7))
                (Value.Integer 1)
            |))).
      
      Definition u8 : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i8" |))).
      
      Definition u16 : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i16" |))).
      
      Definition u32 : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i32" |))).
      
      Definition u64 : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i64" |))).
      
      Definition u128 : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "core::num::wrapping::shift_max::i128" |))).
    End shift_max.
  End wrapping.
End num.
