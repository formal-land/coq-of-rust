(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ops.
  Module arith.
    (* Trait *)
    (* Empty module 'Add' *)
    
    Module Impl_core_ops_arith_Add_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "usize", self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_usize_for_usize.
    
    Module Impl_core_ops_arith_Add_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u8", self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            M.call_closure (|
              Ty.path "u8",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_u8_for_u8.
    
    Module Impl_core_ops_arith_Add_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u16", self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            M.call_closure (|
              Ty.path "u16",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_u16_for_u16.
    
    Module Impl_core_ops_arith_Add_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u32", self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_u32_for_u32.
    
    Module Impl_core_ops_arith_Add_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u64", self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_u64_for_u64.
    
    Module Impl_core_ops_arith_Add_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u128", self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            M.call_closure (|
              Ty.path "u128",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_u128_for_u128.
    
    Module Impl_core_ops_arith_Add_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            M.call_closure (|
              Ty.path "isize",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_isize_for_isize.
    
    Module Impl_core_ops_arith_Add_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            M.call_closure (|
              Ty.path "i8",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_i8_for_i8.
    
    Module Impl_core_ops_arith_Add_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            M.call_closure (|
              Ty.path "i16",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_i16_for_i16.
    
    Module Impl_core_ops_arith_Add_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            M.call_closure (|
              Ty.path "i32",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_i32_for_i32.
    
    Module Impl_core_ops_arith_Add_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            M.call_closure (|
              Ty.path "i64",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_i64_for_i64.
    
    Module Impl_core_ops_arith_Add_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            M.call_closure (|
              Ty.path "i128",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_i128_for_i128.
    
    Module Impl_core_ops_arith_Add_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            M.call_closure (|
              Ty.path "f16",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_f16_for_f16.
    
    Module Impl_core_ops_arith_Add_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_f32_for_f32.
    
    Module Impl_core_ops_arith_Add_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            M.call_closure (|
              Ty.path "f64",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_f64_for_f64.
    
    Module Impl_core_ops_arith_Add_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn add(self, other: $t) -> $t { self + other } *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            M.call_closure (|
              Ty.path "f128",
              BinOp.Wrap.add,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'Sub' *)
    
    Module Impl_core_ops_arith_Sub_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "usize", self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_usize_for_usize.
    
    Module Impl_core_ops_arith_Sub_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u8", self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            M.call_closure (|
              Ty.path "u8",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_u8_for_u8.
    
    Module Impl_core_ops_arith_Sub_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u16", self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            M.call_closure (|
              Ty.path "u16",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_u16_for_u16.
    
    Module Impl_core_ops_arith_Sub_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u32", self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_u32_for_u32.
    
    Module Impl_core_ops_arith_Sub_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u64", self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_u64_for_u64.
    
    Module Impl_core_ops_arith_Sub_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u128", self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            M.call_closure (|
              Ty.path "u128",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_u128_for_u128.
    
    Module Impl_core_ops_arith_Sub_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            M.call_closure (|
              Ty.path "isize",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_isize_for_isize.
    
    Module Impl_core_ops_arith_Sub_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            M.call_closure (|
              Ty.path "i8",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_i8_for_i8.
    
    Module Impl_core_ops_arith_Sub_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            M.call_closure (|
              Ty.path "i16",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_i16_for_i16.
    
    Module Impl_core_ops_arith_Sub_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            M.call_closure (|
              Ty.path "i32",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_i32_for_i32.
    
    Module Impl_core_ops_arith_Sub_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            M.call_closure (|
              Ty.path "i64",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_i64_for_i64.
    
    Module Impl_core_ops_arith_Sub_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            M.call_closure (|
              Ty.path "i128",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_i128_for_i128.
    
    Module Impl_core_ops_arith_Sub_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            M.call_closure (|
              Ty.path "f16",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_f16_for_f16.
    
    Module Impl_core_ops_arith_Sub_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_f32_for_f32.
    
    Module Impl_core_ops_arith_Sub_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            M.call_closure (|
              Ty.path "f64",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_f64_for_f64.
    
    Module Impl_core_ops_arith_Sub_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn sub(self, other: $t) -> $t { self - other } *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            M.call_closure (|
              Ty.path "f128",
              BinOp.Wrap.sub,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'Mul' *)
    
    Module Impl_core_ops_arith_Mul_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "usize", self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_usize_for_usize.
    
    Module Impl_core_ops_arith_Mul_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u8", self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            M.call_closure (|
              Ty.path "u8",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_u8_for_u8.
    
    Module Impl_core_ops_arith_Mul_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u16", self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            M.call_closure (|
              Ty.path "u16",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_u16_for_u16.
    
    Module Impl_core_ops_arith_Mul_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u32", self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_u32_for_u32.
    
    Module Impl_core_ops_arith_Mul_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u64", self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_u64_for_u64.
    
    Module Impl_core_ops_arith_Mul_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u128", self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            M.call_closure (|
              Ty.path "u128",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_u128_for_u128.
    
    Module Impl_core_ops_arith_Mul_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            M.call_closure (|
              Ty.path "isize",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_isize_for_isize.
    
    Module Impl_core_ops_arith_Mul_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            M.call_closure (|
              Ty.path "i8",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_i8_for_i8.
    
    Module Impl_core_ops_arith_Mul_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            M.call_closure (|
              Ty.path "i16",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_i16_for_i16.
    
    Module Impl_core_ops_arith_Mul_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            M.call_closure (|
              Ty.path "i32",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_i32_for_i32.
    
    Module Impl_core_ops_arith_Mul_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            M.call_closure (|
              Ty.path "i64",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_i64_for_i64.
    
    Module Impl_core_ops_arith_Mul_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            M.call_closure (|
              Ty.path "i128",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_i128_for_i128.
    
    Module Impl_core_ops_arith_Mul_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            M.call_closure (|
              Ty.path "f16",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_f16_for_f16.
    
    Module Impl_core_ops_arith_Mul_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_f32_for_f32.
    
    Module Impl_core_ops_arith_Mul_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            M.call_closure (|
              Ty.path "f64",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_f64_for_f64.
    
    Module Impl_core_ops_arith_Mul_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn mul(self, other: $t) -> $t { self * other } *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            M.call_closure (|
              Ty.path "f128",
              BinOp.Wrap.mul,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'Div' *)
    
    Module Impl_core_ops_arith_Div_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "usize", self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_usize_for_usize.
    
    Module Impl_core_ops_arith_Div_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u8", self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            M.call_closure (|
              Ty.path "u8",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_u8_for_u8.
    
    Module Impl_core_ops_arith_Div_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u16", self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            M.call_closure (|
              Ty.path "u16",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_u16_for_u16.
    
    Module Impl_core_ops_arith_Div_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u32", self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_u32_for_u32.
    
    Module Impl_core_ops_arith_Div_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u64", self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_u64_for_u64.
    
    Module Impl_core_ops_arith_Div_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u128", self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            M.call_closure (|
              Ty.path "u128",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_u128_for_u128.
    
    Module Impl_core_ops_arith_Div_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            M.call_closure (|
              Ty.path "isize",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_isize_for_isize.
    
    Module Impl_core_ops_arith_Div_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            M.call_closure (|
              Ty.path "i8",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_i8_for_i8.
    
    Module Impl_core_ops_arith_Div_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            M.call_closure (|
              Ty.path "i16",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_i16_for_i16.
    
    Module Impl_core_ops_arith_Div_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            M.call_closure (|
              Ty.path "i32",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_i32_for_i32.
    
    Module Impl_core_ops_arith_Div_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            M.call_closure (|
              Ty.path "i64",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_i64_for_i64.
    
    Module Impl_core_ops_arith_Div_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            M.call_closure (|
              Ty.path "i128",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_i128_for_i128.
    
    Module Impl_core_ops_arith_Div_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            M.call_closure (|
              Ty.path "f16",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_f16_for_f16.
    
    Module Impl_core_ops_arith_Div_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_f32_for_f32.
    
    Module Impl_core_ops_arith_Div_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            M.call_closure (|
              Ty.path "f64",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_f64_for_f64.
    
    Module Impl_core_ops_arith_Div_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn div(self, other: $t) -> $t { self / other } *)
      Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            M.call_closure (|
              Ty.path "f128",
              BinOp.Wrap.div,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
    End Impl_core_ops_arith_Div_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'Rem' *)
    
    Module Impl_core_ops_arith_Rem_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "usize", self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_usize_for_usize.
    
    Module Impl_core_ops_arith_Rem_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u8", self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            M.call_closure (|
              Ty.path "u8",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_u8_for_u8.
    
    Module Impl_core_ops_arith_Rem_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u16", self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            M.call_closure (|
              Ty.path "u16",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_u16_for_u16.
    
    Module Impl_core_ops_arith_Rem_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u32", self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_u32_for_u32.
    
    Module Impl_core_ops_arith_Rem_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u64", self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_u64_for_u64.
    
    Module Impl_core_ops_arith_Rem_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "u128", self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            M.call_closure (|
              Ty.path "u128",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_u128_for_u128.
    
    Module Impl_core_ops_arith_Rem_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            M.call_closure (|
              Ty.path "isize",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_isize_for_isize.
    
    Module Impl_core_ops_arith_Rem_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            M.call_closure (|
              Ty.path "i8",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_i8_for_i8.
    
    Module Impl_core_ops_arith_Rem_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            M.call_closure (|
              Ty.path "i16",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_i16_for_i16.
    
    Module Impl_core_ops_arith_Rem_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            M.call_closure (|
              Ty.path "i32",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_i32_for_i32.
    
    Module Impl_core_ops_arith_Rem_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            M.call_closure (|
              Ty.path "i64",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_i64_for_i64.
    
    Module Impl_core_ops_arith_Rem_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            M.call_closure (|
              Ty.path "i128",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_i128_for_i128.
    
    Module Impl_core_ops_arith_Rem_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            M.call_closure (|
              Ty.path "f16",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_f16_for_f16.
    
    Module Impl_core_ops_arith_Rem_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_f32_for_f32.
    
    Module Impl_core_ops_arith_Rem_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            M.call_closure (|
              Ty.path "f64",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_f64_for_f64.
    
    Module Impl_core_ops_arith_Rem_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn rem(self, other: $t) -> $t { self % other } *)
      Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            M.call_closure (|
              Ty.path "f128",
              BinOp.Wrap.rem,
              [ M.read (| self |); M.read (| other |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
    End Impl_core_ops_arith_Rem_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'Neg' *)
    
    Module Impl_core_ops_arith_Neg_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "isize", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_isize.
    
    Module Impl_core_ops_arith_Neg_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i8", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_i8.
    
    Module Impl_core_ops_arith_Neg_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i16", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_i16.
    
    Module Impl_core_ops_arith_Neg_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i32", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_i32.
    
    Module Impl_core_ops_arith_Neg_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i64", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_i64.
    
    Module Impl_core_ops_arith_Neg_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "i128", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_i128.
    
    Module Impl_core_ops_arith_Neg_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f16".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f16", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_f16.
    
    Module Impl_core_ops_arith_Neg_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f32".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f32", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_f32.
    
    Module Impl_core_ops_arith_Neg_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f64".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f64", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_f64.
    
    Module Impl_core_ops_arith_Neg_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "f128".
      
      (*             fn neg(self) -> $t { -self } *)
      Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.path "f128", self |) in
            UnOp.neg (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
    End Impl_core_ops_arith_Neg_for_f128.
    
    (* Trait *)
    (* Empty module 'AddAssign' *)
    
    Module Impl_core_ops_arith_AddAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ], self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_usize_for_usize.
    
    Module Impl_core_ops_arith_AddAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ], self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u8_for_u8.
    
    Module Impl_core_ops_arith_AddAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ], self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u16",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u16_for_u16.
    
    Module Impl_core_ops_arith_AddAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ], self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u32_for_u32.
    
    Module Impl_core_ops_arith_AddAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u64_for_u64.
    
    Module Impl_core_ops_arith_AddAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u128" ], self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_u128_for_u128.
    
    Module Impl_core_ops_arith_AddAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ], self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "isize",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_isize_for_isize.
    
    Module Impl_core_ops_arith_AddAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ], self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i8",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i8_for_i8.
    
    Module Impl_core_ops_arith_AddAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ], self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i16",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i16_for_i16.
    
    Module Impl_core_ops_arith_AddAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ], self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i32",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i32_for_i32.
    
    Module Impl_core_ops_arith_AddAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ], self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i64_for_i64.
    
    Module Impl_core_ops_arith_AddAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i128" ], self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i128",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_i128_for_i128.
    
    Module Impl_core_ops_arith_AddAssign_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f16" ], self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f16",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_f16_for_f16.
    
    Module Impl_core_ops_arith_AddAssign_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f32" ], self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_f32_for_f32.
    
    Module Impl_core_ops_arith_AddAssign_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f64" ], self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_f64_for_f64.
    
    Module Impl_core_ops_arith_AddAssign_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             fn add_assign(&mut self, other: $t) { *self += other } *)
      Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f128" ], self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f128",
                BinOp.Wrap.add,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
    End Impl_core_ops_arith_AddAssign_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'SubAssign' *)
    
    Module Impl_core_ops_arith_SubAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ], self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_usize_for_usize.
    
    Module Impl_core_ops_arith_SubAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ], self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u8_for_u8.
    
    Module Impl_core_ops_arith_SubAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ], self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u16",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u16_for_u16.
    
    Module Impl_core_ops_arith_SubAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ], self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u32_for_u32.
    
    Module Impl_core_ops_arith_SubAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u64_for_u64.
    
    Module Impl_core_ops_arith_SubAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u128" ], self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_u128_for_u128.
    
    Module Impl_core_ops_arith_SubAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ], self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "isize",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_isize_for_isize.
    
    Module Impl_core_ops_arith_SubAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ], self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i8",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i8_for_i8.
    
    Module Impl_core_ops_arith_SubAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ], self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i16",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i16_for_i16.
    
    Module Impl_core_ops_arith_SubAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ], self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i32",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i32_for_i32.
    
    Module Impl_core_ops_arith_SubAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ], self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i64_for_i64.
    
    Module Impl_core_ops_arith_SubAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i128" ], self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i128",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_i128_for_i128.
    
    Module Impl_core_ops_arith_SubAssign_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f16" ], self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f16",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_f16_for_f16.
    
    Module Impl_core_ops_arith_SubAssign_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f32" ], self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_f32_for_f32.
    
    Module Impl_core_ops_arith_SubAssign_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f64" ], self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_f64_for_f64.
    
    Module Impl_core_ops_arith_SubAssign_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             fn sub_assign(&mut self, other: $t) { *self -= other } *)
      Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f128" ], self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f128",
                BinOp.Wrap.sub,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
    End Impl_core_ops_arith_SubAssign_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'MulAssign' *)
    
    Module Impl_core_ops_arith_MulAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ], self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_usize_for_usize.
    
    Module Impl_core_ops_arith_MulAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ], self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u8_for_u8.
    
    Module Impl_core_ops_arith_MulAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ], self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u16",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u16_for_u16.
    
    Module Impl_core_ops_arith_MulAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ], self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u32_for_u32.
    
    Module Impl_core_ops_arith_MulAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u64_for_u64.
    
    Module Impl_core_ops_arith_MulAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u128" ], self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_u128_for_u128.
    
    Module Impl_core_ops_arith_MulAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ], self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "isize",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_isize_for_isize.
    
    Module Impl_core_ops_arith_MulAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ], self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i8",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i8_for_i8.
    
    Module Impl_core_ops_arith_MulAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ], self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i16",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i16_for_i16.
    
    Module Impl_core_ops_arith_MulAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ], self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i32",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i32_for_i32.
    
    Module Impl_core_ops_arith_MulAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ], self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i64_for_i64.
    
    Module Impl_core_ops_arith_MulAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i128" ], self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i128",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_i128_for_i128.
    
    Module Impl_core_ops_arith_MulAssign_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f16" ], self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f16",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_f16_for_f16.
    
    Module Impl_core_ops_arith_MulAssign_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f32" ], self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_f32_for_f32.
    
    Module Impl_core_ops_arith_MulAssign_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f64" ], self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_f64_for_f64.
    
    Module Impl_core_ops_arith_MulAssign_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             fn mul_assign(&mut self, other: $t) { *self *= other } *)
      Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f128" ], self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f128",
                BinOp.Wrap.mul,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
    End Impl_core_ops_arith_MulAssign_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'DivAssign' *)
    
    Module Impl_core_ops_arith_DivAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ], self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_usize_for_usize.
    
    Module Impl_core_ops_arith_DivAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ], self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u8_for_u8.
    
    Module Impl_core_ops_arith_DivAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ], self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u16",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u16_for_u16.
    
    Module Impl_core_ops_arith_DivAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ], self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u32_for_u32.
    
    Module Impl_core_ops_arith_DivAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u64_for_u64.
    
    Module Impl_core_ops_arith_DivAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u128" ], self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_u128_for_u128.
    
    Module Impl_core_ops_arith_DivAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ], self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "isize",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_isize_for_isize.
    
    Module Impl_core_ops_arith_DivAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ], self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i8",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i8_for_i8.
    
    Module Impl_core_ops_arith_DivAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ], self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i16",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i16_for_i16.
    
    Module Impl_core_ops_arith_DivAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ], self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i32",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i32_for_i32.
    
    Module Impl_core_ops_arith_DivAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ], self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i64_for_i64.
    
    Module Impl_core_ops_arith_DivAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i128" ], self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i128",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_i128_for_i128.
    
    Module Impl_core_ops_arith_DivAssign_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f16" ], self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f16",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_f16_for_f16.
    
    Module Impl_core_ops_arith_DivAssign_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f32" ], self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_f32_for_f32.
    
    Module Impl_core_ops_arith_DivAssign_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f64" ], self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_f64_for_f64.
    
    Module Impl_core_ops_arith_DivAssign_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             fn div_assign(&mut self, other: $t) { *self /= other } *)
      Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f128" ], self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f128",
                BinOp.Wrap.div,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
    End Impl_core_ops_arith_DivAssign_f128_for_f128.
    
    (* Trait *)
    (* Empty module 'RemAssign' *)
    
    Module Impl_core_ops_arith_RemAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ], self |) in
            let other := M.alloc (| Ty.path "usize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_usize_for_usize.
    
    Module Impl_core_ops_arith_RemAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ], self |) in
            let other := M.alloc (| Ty.path "u8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u8_for_u8.
    
    Module Impl_core_ops_arith_RemAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ], self |) in
            let other := M.alloc (| Ty.path "u16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u16",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u16_for_u16.
    
    Module Impl_core_ops_arith_RemAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ], self |) in
            let other := M.alloc (| Ty.path "u32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u32_for_u32.
    
    Module Impl_core_ops_arith_RemAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], self |) in
            let other := M.alloc (| Ty.path "u64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u64_for_u64.
    
    Module Impl_core_ops_arith_RemAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u128" ], self |) in
            let other := M.alloc (| Ty.path "u128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_u128_for_u128.
    
    Module Impl_core_ops_arith_RemAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ], self |) in
            let other := M.alloc (| Ty.path "isize", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "isize",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_isize_for_isize.
    
    Module Impl_core_ops_arith_RemAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ], self |) in
            let other := M.alloc (| Ty.path "i8", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i8",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i8_for_i8.
    
    Module Impl_core_ops_arith_RemAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ], self |) in
            let other := M.alloc (| Ty.path "i16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i16",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i16_for_i16.
    
    Module Impl_core_ops_arith_RemAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ], self |) in
            let other := M.alloc (| Ty.path "i32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i32",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i32_for_i32.
    
    Module Impl_core_ops_arith_RemAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ], self |) in
            let other := M.alloc (| Ty.path "i64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i64_for_i64.
    
    Module Impl_core_ops_arith_RemAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "i128" ], self |) in
            let other := M.alloc (| Ty.path "i128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "i128",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_i128_for_i128.
    
    Module Impl_core_ops_arith_RemAssign_f16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f16" ], self |) in
            let other := M.alloc (| Ty.path "f16", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f16",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_f16_for_f16.
    
    Module Impl_core_ops_arith_RemAssign_f32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f32" ], self |) in
            let other := M.alloc (| Ty.path "f32", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_f32_for_f32.
    
    Module Impl_core_ops_arith_RemAssign_f64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f64" ], self |) in
            let other := M.alloc (| Ty.path "f64", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_f64_for_f64.
    
    Module Impl_core_ops_arith_RemAssign_f128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*             fn rem_assign(&mut self, other: $t) { *self %= other } *)
      Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "f128" ], self |) in
            let other := M.alloc (| Ty.path "f128", other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (|
              β,
              M.call_closure (|
                Ty.path "f128",
                BinOp.Wrap.rem,
                [ M.read (| β |); M.read (| other |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f128" ]
          Self
          (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
    End Impl_core_ops_arith_RemAssign_f128_for_f128.
  End arith.
End ops.
