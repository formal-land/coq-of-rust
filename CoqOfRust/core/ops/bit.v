(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ops.
  Module bit.
    (* Trait *)
    (* Empty module 'Not' *)
    
    Module Impl_core_ops_bit_Not_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "bool".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_bool.
    
    Module Impl_core_ops_bit_Not_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_usize.
    
    Module Impl_core_ops_bit_Not_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_u8.
    
    Module Impl_core_ops_bit_Not_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_u16.
    
    Module Impl_core_ops_bit_Not_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_u32.
    
    Module Impl_core_ops_bit_Not_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_u64.
    
    Module Impl_core_ops_bit_Not_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_u128.
    
    Module Impl_core_ops_bit_Not_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_isize.
    
    Module Impl_core_ops_bit_Not_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_i8.
    
    Module Impl_core_ops_bit_Not_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_i16.
    
    Module Impl_core_ops_bit_Not_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_i32.
    
    Module Impl_core_ops_bit_Not_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_i64.
    
    Module Impl_core_ops_bit_Not_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn not(self) -> $t { !self } *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_i128.
    
    Module Impl_core_ops_bit_Not_for_never.
      Definition Self : Ty.t := Ty.path "never".
      
      (*     type Output = !; *)
      Definition _Output : Ty.t := Ty.path "never".
      
      (*
          fn not(self) -> ! {
              match self {}
          }
      *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.match_operator (| Some (Ty.path "never"), self, [] |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_never.
    
    (* Trait *)
    (* Empty module 'BitAnd' *)
    
    Module Impl_core_ops_bit_BitAnd_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "bool".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_bool.
    
    Module Impl_core_ops_bit_BitAnd_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_usize.
    
    Module Impl_core_ops_bit_BitAnd_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_u8.
    
    Module Impl_core_ops_bit_BitAnd_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_u16.
    
    Module Impl_core_ops_bit_BitAnd_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_u32.
    
    Module Impl_core_ops_bit_BitAnd_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_u64.
    
    Module Impl_core_ops_bit_BitAnd_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_u128.
    
    Module Impl_core_ops_bit_BitAnd_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_isize.
    
    Module Impl_core_ops_bit_BitAnd_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_i8.
    
    Module Impl_core_ops_bit_BitAnd_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_i16.
    
    Module Impl_core_ops_bit_BitAnd_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_i32.
    
    Module Impl_core_ops_bit_BitAnd_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_i64.
    
    Module Impl_core_ops_bit_BitAnd_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn bitand(self, rhs: $t) -> $t { self & rhs } *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_and (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_for_i128.
    
    (* Trait *)
    (* Empty module 'BitOr' *)
    
    Module Impl_core_ops_bit_BitOr_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "bool".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_bool.
    
    Module Impl_core_ops_bit_BitOr_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_usize.
    
    Module Impl_core_ops_bit_BitOr_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_u8.
    
    Module Impl_core_ops_bit_BitOr_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_u16.
    
    Module Impl_core_ops_bit_BitOr_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_u32.
    
    Module Impl_core_ops_bit_BitOr_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_u64.
    
    Module Impl_core_ops_bit_BitOr_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_u128.
    
    Module Impl_core_ops_bit_BitOr_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_isize.
    
    Module Impl_core_ops_bit_BitOr_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_i8.
    
    Module Impl_core_ops_bit_BitOr_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_i16.
    
    Module Impl_core_ops_bit_BitOr_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_i32.
    
    Module Impl_core_ops_bit_BitOr_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_i64.
    
    Module Impl_core_ops_bit_BitOr_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn bitor(self, rhs: $t) -> $t { self | rhs } *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            BinOp.bit_or (M.read (| self |)) (M.read (| rhs |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_for_i128.
    
    (* Trait *)
    (* Empty module 'BitXor' *)
    
    Module Impl_core_ops_bit_BitXor_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "bool".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_bool.
    
    Module Impl_core_ops_bit_BitXor_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_usize.
    
    Module Impl_core_ops_bit_BitXor_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_u8.
    
    Module Impl_core_ops_bit_BitXor_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_u16.
    
    Module Impl_core_ops_bit_BitXor_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_u32.
    
    Module Impl_core_ops_bit_BitXor_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_u64.
    
    Module Impl_core_ops_bit_BitXor_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_u128.
    
    Module Impl_core_ops_bit_BitXor_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_isize.
    
    Module Impl_core_ops_bit_BitXor_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_i8.
    
    Module Impl_core_ops_bit_BitXor_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_i16.
    
    Module Impl_core_ops_bit_BitXor_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_i32.
    
    Module Impl_core_ops_bit_BitXor_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_i64.
    
    Module Impl_core_ops_bit_BitXor_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*             fn bitxor(self, other: $t) -> $t { self ^ other } *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.bit_xor (M.read (| self |)) (M.read (| other |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_for_i128.
    
    (* Trait *)
    (* Empty module 'Shl' *)
    
    Module Impl_core_ops_bit_Shl_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_u8.
    
    Module Impl_core_ops_bit_Shl_u16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_u8.
    
    Module Impl_core_ops_bit_Shl_u32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_u8.
    
    Module Impl_core_ops_bit_Shl_u64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_u8.
    
    Module Impl_core_ops_bit_Shl_u128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_u8.
    
    Module Impl_core_ops_bit_Shl_usize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_u8.
    
    Module Impl_core_ops_bit_Shl_i8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_u8.
    
    Module Impl_core_ops_bit_Shl_i16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_u8.
    
    Module Impl_core_ops_bit_Shl_i32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_u8.
    
    Module Impl_core_ops_bit_Shl_i64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_u8.
    
    Module Impl_core_ops_bit_Shl_i128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_u8.
    
    Module Impl_core_ops_bit_Shl_isize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_u8.
    
    Module Impl_core_ops_bit_Shl_u8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_u16.
    
    Module Impl_core_ops_bit_Shl_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_u16.
    
    Module Impl_core_ops_bit_Shl_u32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_u16.
    
    Module Impl_core_ops_bit_Shl_u64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_u16.
    
    Module Impl_core_ops_bit_Shl_u128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_u16.
    
    Module Impl_core_ops_bit_Shl_usize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_u16.
    
    Module Impl_core_ops_bit_Shl_i8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_u16.
    
    Module Impl_core_ops_bit_Shl_i16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_u16.
    
    Module Impl_core_ops_bit_Shl_i32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_u16.
    
    Module Impl_core_ops_bit_Shl_i64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_u16.
    
    Module Impl_core_ops_bit_Shl_i128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_u16.
    
    Module Impl_core_ops_bit_Shl_isize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_u16.
    
    Module Impl_core_ops_bit_Shl_u8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_u32.
    
    Module Impl_core_ops_bit_Shl_u16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_u32.
    
    Module Impl_core_ops_bit_Shl_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_u32.
    
    Module Impl_core_ops_bit_Shl_u64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_u32.
    
    Module Impl_core_ops_bit_Shl_u128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_u32.
    
    Module Impl_core_ops_bit_Shl_usize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_u32.
    
    Module Impl_core_ops_bit_Shl_i8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_u32.
    
    Module Impl_core_ops_bit_Shl_i16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_u32.
    
    Module Impl_core_ops_bit_Shl_i32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_u32.
    
    Module Impl_core_ops_bit_Shl_i64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_u32.
    
    Module Impl_core_ops_bit_Shl_i128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_u32.
    
    Module Impl_core_ops_bit_Shl_isize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_u32.
    
    Module Impl_core_ops_bit_Shl_u8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_u64.
    
    Module Impl_core_ops_bit_Shl_u16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_u64.
    
    Module Impl_core_ops_bit_Shl_u32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_u64.
    
    Module Impl_core_ops_bit_Shl_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_u64.
    
    Module Impl_core_ops_bit_Shl_u128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_u64.
    
    Module Impl_core_ops_bit_Shl_usize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_u64.
    
    Module Impl_core_ops_bit_Shl_i8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_u64.
    
    Module Impl_core_ops_bit_Shl_i16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_u64.
    
    Module Impl_core_ops_bit_Shl_i32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_u64.
    
    Module Impl_core_ops_bit_Shl_i64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_u64.
    
    Module Impl_core_ops_bit_Shl_i128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_u64.
    
    Module Impl_core_ops_bit_Shl_isize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_u64.
    
    Module Impl_core_ops_bit_Shl_u8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_u128.
    
    Module Impl_core_ops_bit_Shl_u16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_u128.
    
    Module Impl_core_ops_bit_Shl_u32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_u128.
    
    Module Impl_core_ops_bit_Shl_u64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_u128.
    
    Module Impl_core_ops_bit_Shl_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_u128.
    
    Module Impl_core_ops_bit_Shl_usize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_u128.
    
    Module Impl_core_ops_bit_Shl_i8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_u128.
    
    Module Impl_core_ops_bit_Shl_i16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_u128.
    
    Module Impl_core_ops_bit_Shl_i32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_u128.
    
    Module Impl_core_ops_bit_Shl_i64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_u128.
    
    Module Impl_core_ops_bit_Shl_i128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_u128.
    
    Module Impl_core_ops_bit_Shl_isize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_u128.
    
    Module Impl_core_ops_bit_Shl_u8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_usize.
    
    Module Impl_core_ops_bit_Shl_u16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_usize.
    
    Module Impl_core_ops_bit_Shl_u32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_usize.
    
    Module Impl_core_ops_bit_Shl_u64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_usize.
    
    Module Impl_core_ops_bit_Shl_u128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_usize.
    
    Module Impl_core_ops_bit_Shl_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_usize.
    
    Module Impl_core_ops_bit_Shl_i8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_usize.
    
    Module Impl_core_ops_bit_Shl_i16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_usize.
    
    Module Impl_core_ops_bit_Shl_i32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_usize.
    
    Module Impl_core_ops_bit_Shl_i64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_usize.
    
    Module Impl_core_ops_bit_Shl_i128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_usize.
    
    Module Impl_core_ops_bit_Shl_isize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_usize.
    
    Module Impl_core_ops_bit_Shl_u8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_i8.
    
    Module Impl_core_ops_bit_Shl_u16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_i8.
    
    Module Impl_core_ops_bit_Shl_u32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_i8.
    
    Module Impl_core_ops_bit_Shl_u64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_i8.
    
    Module Impl_core_ops_bit_Shl_u128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_i8.
    
    Module Impl_core_ops_bit_Shl_usize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_i8.
    
    Module Impl_core_ops_bit_Shl_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_i8.
    
    Module Impl_core_ops_bit_Shl_i16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_i8.
    
    Module Impl_core_ops_bit_Shl_i32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_i8.
    
    Module Impl_core_ops_bit_Shl_i64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_i8.
    
    Module Impl_core_ops_bit_Shl_i128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_i8.
    
    Module Impl_core_ops_bit_Shl_isize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_i8.
    
    Module Impl_core_ops_bit_Shl_u8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_i16.
    
    Module Impl_core_ops_bit_Shl_u16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_i16.
    
    Module Impl_core_ops_bit_Shl_u32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_i16.
    
    Module Impl_core_ops_bit_Shl_u64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_i16.
    
    Module Impl_core_ops_bit_Shl_u128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_i16.
    
    Module Impl_core_ops_bit_Shl_usize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_i16.
    
    Module Impl_core_ops_bit_Shl_i8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_i16.
    
    Module Impl_core_ops_bit_Shl_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_i16.
    
    Module Impl_core_ops_bit_Shl_i32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_i16.
    
    Module Impl_core_ops_bit_Shl_i64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_i16.
    
    Module Impl_core_ops_bit_Shl_i128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_i16.
    
    Module Impl_core_ops_bit_Shl_isize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_i16.
    
    Module Impl_core_ops_bit_Shl_u8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_i32.
    
    Module Impl_core_ops_bit_Shl_u16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_i32.
    
    Module Impl_core_ops_bit_Shl_u32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_i32.
    
    Module Impl_core_ops_bit_Shl_u64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_i32.
    
    Module Impl_core_ops_bit_Shl_u128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_i32.
    
    Module Impl_core_ops_bit_Shl_usize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_i32.
    
    Module Impl_core_ops_bit_Shl_i8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_i32.
    
    Module Impl_core_ops_bit_Shl_i16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_i32.
    
    Module Impl_core_ops_bit_Shl_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_i32.
    
    Module Impl_core_ops_bit_Shl_i64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_i32.
    
    Module Impl_core_ops_bit_Shl_i128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_i32.
    
    Module Impl_core_ops_bit_Shl_isize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_i32.
    
    Module Impl_core_ops_bit_Shl_u8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_i64.
    
    Module Impl_core_ops_bit_Shl_u16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_i64.
    
    Module Impl_core_ops_bit_Shl_u32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_i64.
    
    Module Impl_core_ops_bit_Shl_u64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_i64.
    
    Module Impl_core_ops_bit_Shl_u128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_i64.
    
    Module Impl_core_ops_bit_Shl_usize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_i64.
    
    Module Impl_core_ops_bit_Shl_i8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_i64.
    
    Module Impl_core_ops_bit_Shl_i16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_i64.
    
    Module Impl_core_ops_bit_Shl_i32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_i64.
    
    Module Impl_core_ops_bit_Shl_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_i64.
    
    Module Impl_core_ops_bit_Shl_i128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_i64.
    
    Module Impl_core_ops_bit_Shl_isize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_i64.
    
    Module Impl_core_ops_bit_Shl_u8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_isize.
    
    Module Impl_core_ops_bit_Shl_u16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_isize.
    
    Module Impl_core_ops_bit_Shl_u32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_isize.
    
    Module Impl_core_ops_bit_Shl_u64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_isize.
    
    Module Impl_core_ops_bit_Shl_u128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_isize.
    
    Module Impl_core_ops_bit_Shl_usize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_isize.
    
    Module Impl_core_ops_bit_Shl_i8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_isize.
    
    Module Impl_core_ops_bit_Shl_i16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_isize.
    
    Module Impl_core_ops_bit_Shl_i32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_isize.
    
    Module Impl_core_ops_bit_Shl_i64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_isize.
    
    Module Impl_core_ops_bit_Shl_i128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_isize.
    
    Module Impl_core_ops_bit_Shl_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_isize.
    
    Module Impl_core_ops_bit_Shl_u8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u8_for_i128.
    
    Module Impl_core_ops_bit_Shl_u16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u16_for_i128.
    
    Module Impl_core_ops_bit_Shl_u32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u32_for_i128.
    
    Module Impl_core_ops_bit_Shl_u64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u64_for_i128.
    
    Module Impl_core_ops_bit_Shl_u128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_u128_for_i128.
    
    Module Impl_core_ops_bit_Shl_usize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_usize_for_i128.
    
    Module Impl_core_ops_bit_Shl_i8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i8_for_i128.
    
    Module Impl_core_ops_bit_Shl_i16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i16_for_i128.
    
    Module Impl_core_ops_bit_Shl_i32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i32_for_i128.
    
    Module Impl_core_ops_bit_Shl_i64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i64_for_i128.
    
    Module Impl_core_ops_bit_Shl_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_i128_for_i128.
    
    Module Impl_core_ops_bit_Shl_isize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shl(self, other: $f) -> $t {
                      self << other
                  }
      *)
      Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shl (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
    End Impl_core_ops_bit_Shl_isize_for_i128.
    
    (* Trait *)
    (* Empty module 'Shr' *)
    
    Module Impl_core_ops_bit_Shr_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_u8.
    
    Module Impl_core_ops_bit_Shr_u16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_u8.
    
    Module Impl_core_ops_bit_Shr_u32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_u8.
    
    Module Impl_core_ops_bit_Shr_u64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_u8.
    
    Module Impl_core_ops_bit_Shr_u128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_u8.
    
    Module Impl_core_ops_bit_Shr_usize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_u8.
    
    Module Impl_core_ops_bit_Shr_i8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_u8.
    
    Module Impl_core_ops_bit_Shr_i16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_u8.
    
    Module Impl_core_ops_bit_Shr_i32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_u8.
    
    Module Impl_core_ops_bit_Shr_i64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_u8.
    
    Module Impl_core_ops_bit_Shr_i128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_u8.
    
    Module Impl_core_ops_bit_Shr_isize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_u8.
    
    Module Impl_core_ops_bit_Shr_u8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_u16.
    
    Module Impl_core_ops_bit_Shr_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_u16.
    
    Module Impl_core_ops_bit_Shr_u32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_u16.
    
    Module Impl_core_ops_bit_Shr_u64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_u16.
    
    Module Impl_core_ops_bit_Shr_u128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_u16.
    
    Module Impl_core_ops_bit_Shr_usize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_u16.
    
    Module Impl_core_ops_bit_Shr_i8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_u16.
    
    Module Impl_core_ops_bit_Shr_i16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_u16.
    
    Module Impl_core_ops_bit_Shr_i32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_u16.
    
    Module Impl_core_ops_bit_Shr_i64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_u16.
    
    Module Impl_core_ops_bit_Shr_i128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_u16.
    
    Module Impl_core_ops_bit_Shr_isize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_u16.
    
    Module Impl_core_ops_bit_Shr_u8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_u32.
    
    Module Impl_core_ops_bit_Shr_u16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_u32.
    
    Module Impl_core_ops_bit_Shr_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_u32.
    
    Module Impl_core_ops_bit_Shr_u64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_u32.
    
    Module Impl_core_ops_bit_Shr_u128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_u32.
    
    Module Impl_core_ops_bit_Shr_usize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_u32.
    
    Module Impl_core_ops_bit_Shr_i8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_u32.
    
    Module Impl_core_ops_bit_Shr_i16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_u32.
    
    Module Impl_core_ops_bit_Shr_i32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_u32.
    
    Module Impl_core_ops_bit_Shr_i64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_u32.
    
    Module Impl_core_ops_bit_Shr_i128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_u32.
    
    Module Impl_core_ops_bit_Shr_isize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_u32.
    
    Module Impl_core_ops_bit_Shr_u8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_u64.
    
    Module Impl_core_ops_bit_Shr_u16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_u64.
    
    Module Impl_core_ops_bit_Shr_u32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_u64.
    
    Module Impl_core_ops_bit_Shr_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_u64.
    
    Module Impl_core_ops_bit_Shr_u128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_u64.
    
    Module Impl_core_ops_bit_Shr_usize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_u64.
    
    Module Impl_core_ops_bit_Shr_i8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_u64.
    
    Module Impl_core_ops_bit_Shr_i16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_u64.
    
    Module Impl_core_ops_bit_Shr_i32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_u64.
    
    Module Impl_core_ops_bit_Shr_i64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_u64.
    
    Module Impl_core_ops_bit_Shr_i128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_u64.
    
    Module Impl_core_ops_bit_Shr_isize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_u64.
    
    Module Impl_core_ops_bit_Shr_u8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_u128.
    
    Module Impl_core_ops_bit_Shr_u16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_u128.
    
    Module Impl_core_ops_bit_Shr_u32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_u128.
    
    Module Impl_core_ops_bit_Shr_u64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_u128.
    
    Module Impl_core_ops_bit_Shr_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_u128.
    
    Module Impl_core_ops_bit_Shr_usize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_u128.
    
    Module Impl_core_ops_bit_Shr_i8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_u128.
    
    Module Impl_core_ops_bit_Shr_i16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_u128.
    
    Module Impl_core_ops_bit_Shr_i32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_u128.
    
    Module Impl_core_ops_bit_Shr_i64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_u128.
    
    Module Impl_core_ops_bit_Shr_i128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_u128.
    
    Module Impl_core_ops_bit_Shr_isize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "u128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_u128.
    
    Module Impl_core_ops_bit_Shr_u8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_usize.
    
    Module Impl_core_ops_bit_Shr_u16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_usize.
    
    Module Impl_core_ops_bit_Shr_u32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_usize.
    
    Module Impl_core_ops_bit_Shr_u64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_usize.
    
    Module Impl_core_ops_bit_Shr_u128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_usize.
    
    Module Impl_core_ops_bit_Shr_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_usize.
    
    Module Impl_core_ops_bit_Shr_i8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_usize.
    
    Module Impl_core_ops_bit_Shr_i16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_usize.
    
    Module Impl_core_ops_bit_Shr_i32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_usize.
    
    Module Impl_core_ops_bit_Shr_i64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_usize.
    
    Module Impl_core_ops_bit_Shr_i128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_usize.
    
    Module Impl_core_ops_bit_Shr_isize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "usize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_usize.
    
    Module Impl_core_ops_bit_Shr_u8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_i8.
    
    Module Impl_core_ops_bit_Shr_u16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_i8.
    
    Module Impl_core_ops_bit_Shr_u32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_i8.
    
    Module Impl_core_ops_bit_Shr_u64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_i8.
    
    Module Impl_core_ops_bit_Shr_u128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_i8.
    
    Module Impl_core_ops_bit_Shr_usize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_i8.
    
    Module Impl_core_ops_bit_Shr_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_i8.
    
    Module Impl_core_ops_bit_Shr_i16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_i8.
    
    Module Impl_core_ops_bit_Shr_i32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_i8.
    
    Module Impl_core_ops_bit_Shr_i64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_i8.
    
    Module Impl_core_ops_bit_Shr_i128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_i8.
    
    Module Impl_core_ops_bit_Shr_isize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i8".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_i8.
    
    Module Impl_core_ops_bit_Shr_u8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_i16.
    
    Module Impl_core_ops_bit_Shr_u16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_i16.
    
    Module Impl_core_ops_bit_Shr_u32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_i16.
    
    Module Impl_core_ops_bit_Shr_u64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_i16.
    
    Module Impl_core_ops_bit_Shr_u128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_i16.
    
    Module Impl_core_ops_bit_Shr_usize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_i16.
    
    Module Impl_core_ops_bit_Shr_i8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_i16.
    
    Module Impl_core_ops_bit_Shr_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_i16.
    
    Module Impl_core_ops_bit_Shr_i32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_i16.
    
    Module Impl_core_ops_bit_Shr_i64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_i16.
    
    Module Impl_core_ops_bit_Shr_i128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_i16.
    
    Module Impl_core_ops_bit_Shr_isize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i16".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_i16.
    
    Module Impl_core_ops_bit_Shr_u8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_i32.
    
    Module Impl_core_ops_bit_Shr_u16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_i32.
    
    Module Impl_core_ops_bit_Shr_u32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_i32.
    
    Module Impl_core_ops_bit_Shr_u64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_i32.
    
    Module Impl_core_ops_bit_Shr_u128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_i32.
    
    Module Impl_core_ops_bit_Shr_usize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_i32.
    
    Module Impl_core_ops_bit_Shr_i8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_i32.
    
    Module Impl_core_ops_bit_Shr_i16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_i32.
    
    Module Impl_core_ops_bit_Shr_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_i32.
    
    Module Impl_core_ops_bit_Shr_i64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_i32.
    
    Module Impl_core_ops_bit_Shr_i128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_i32.
    
    Module Impl_core_ops_bit_Shr_isize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i32".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_i32.
    
    Module Impl_core_ops_bit_Shr_u8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_i64.
    
    Module Impl_core_ops_bit_Shr_u16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_i64.
    
    Module Impl_core_ops_bit_Shr_u32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_i64.
    
    Module Impl_core_ops_bit_Shr_u64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_i64.
    
    Module Impl_core_ops_bit_Shr_u128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_i64.
    
    Module Impl_core_ops_bit_Shr_usize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_i64.
    
    Module Impl_core_ops_bit_Shr_i8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_i64.
    
    Module Impl_core_ops_bit_Shr_i16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_i64.
    
    Module Impl_core_ops_bit_Shr_i32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_i64.
    
    Module Impl_core_ops_bit_Shr_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_i64.
    
    Module Impl_core_ops_bit_Shr_i128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_i64.
    
    Module Impl_core_ops_bit_Shr_isize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i64".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_i64.
    
    Module Impl_core_ops_bit_Shr_u8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_i128.
    
    Module Impl_core_ops_bit_Shr_u16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_i128.
    
    Module Impl_core_ops_bit_Shr_u32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_i128.
    
    Module Impl_core_ops_bit_Shr_u64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_i128.
    
    Module Impl_core_ops_bit_Shr_u128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_i128.
    
    Module Impl_core_ops_bit_Shr_usize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_i128.
    
    Module Impl_core_ops_bit_Shr_i8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_i128.
    
    Module Impl_core_ops_bit_Shr_i16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_i128.
    
    Module Impl_core_ops_bit_Shr_i32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_i128.
    
    Module Impl_core_ops_bit_Shr_i64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_i128.
    
    Module Impl_core_ops_bit_Shr_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_i128.
    
    Module Impl_core_ops_bit_Shr_isize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "i128".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_i128.
    
    Module Impl_core_ops_bit_Shr_u8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u8_for_isize.
    
    Module Impl_core_ops_bit_Shr_u16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u16_for_isize.
    
    Module Impl_core_ops_bit_Shr_u32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u32_for_isize.
    
    Module Impl_core_ops_bit_Shr_u64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u64_for_isize.
    
    Module Impl_core_ops_bit_Shr_u128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_u128_for_isize.
    
    Module Impl_core_ops_bit_Shr_usize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_usize_for_isize.
    
    Module Impl_core_ops_bit_Shr_i8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i8_for_isize.
    
    Module Impl_core_ops_bit_Shr_i16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i16_for_isize.
    
    Module Impl_core_ops_bit_Shr_i32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i32_for_isize.
    
    Module Impl_core_ops_bit_Shr_i64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i64_for_isize.
    
    Module Impl_core_ops_bit_Shr_i128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_i128_for_isize.
    
    Module Impl_core_ops_bit_Shr_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Output = $t; *)
      Definition _Output : Ty.t := Ty.path "isize".
      
      (*
                  fn shr(self, other: $f) -> $t {
                      self >> other
                  }
      *)
      Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Wrap.shr (| M.read (| self |), M.read (| other |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
    End Impl_core_ops_bit_Shr_isize_for_isize.
    
    (* Trait *)
    (* Empty module 'BitAndAssign' *)
    
    Module Impl_core_ops_bit_BitAndAssign_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_bool.
    
    Module Impl_core_ops_bit_BitAndAssign_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_usize.
    
    Module Impl_core_ops_bit_BitAndAssign_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_u8.
    
    Module Impl_core_ops_bit_BitAndAssign_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_u16.
    
    Module Impl_core_ops_bit_BitAndAssign_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_u32.
    
    Module Impl_core_ops_bit_BitAndAssign_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_u64.
    
    Module Impl_core_ops_bit_BitAndAssign_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_u128.
    
    Module Impl_core_ops_bit_BitAndAssign_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_isize.
    
    Module Impl_core_ops_bit_BitAndAssign_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_i8.
    
    Module Impl_core_ops_bit_BitAndAssign_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_i16.
    
    Module Impl_core_ops_bit_BitAndAssign_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_i32.
    
    Module Impl_core_ops_bit_BitAndAssign_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_i64.
    
    Module Impl_core_ops_bit_BitAndAssign_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn bitand_assign(&mut self, other: $t) { *self &= other } *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_and (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_for_i128.
    
    (* Trait *)
    (* Empty module 'BitOrAssign' *)
    
    Module Impl_core_ops_bit_BitOrAssign_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_bool.
    
    Module Impl_core_ops_bit_BitOrAssign_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_usize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_u8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_u16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_u32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_u64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_u128.
    
    Module Impl_core_ops_bit_BitOrAssign_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_isize.
    
    Module Impl_core_ops_bit_BitOrAssign_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_i8.
    
    Module Impl_core_ops_bit_BitOrAssign_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_i16.
    
    Module Impl_core_ops_bit_BitOrAssign_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_i32.
    
    Module Impl_core_ops_bit_BitOrAssign_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_i64.
    
    Module Impl_core_ops_bit_BitOrAssign_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn bitor_assign(&mut self, other: $t) { *self |= other } *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_or (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_for_i128.
    
    (* Trait *)
    (* Empty module 'BitXorAssign' *)
    
    Module Impl_core_ops_bit_BitXorAssign_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_bool.
    
    Module Impl_core_ops_bit_BitXorAssign_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_usize.
    
    Module Impl_core_ops_bit_BitXorAssign_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_u8.
    
    Module Impl_core_ops_bit_BitXorAssign_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_u16.
    
    Module Impl_core_ops_bit_BitXorAssign_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_u32.
    
    Module Impl_core_ops_bit_BitXorAssign_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_u64.
    
    Module Impl_core_ops_bit_BitXorAssign_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_u128.
    
    Module Impl_core_ops_bit_BitXorAssign_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_isize.
    
    Module Impl_core_ops_bit_BitXorAssign_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_i8.
    
    Module Impl_core_ops_bit_BitXorAssign_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_i16.
    
    Module Impl_core_ops_bit_BitXorAssign_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_i32.
    
    Module Impl_core_ops_bit_BitXorAssign_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_i64.
    
    Module Impl_core_ops_bit_BitXorAssign_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             fn bitxor_assign(&mut self, other: $t) { *self ^= other } *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.bit_xor (M.read (| β |)) (M.read (| other |)) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_for_i128.
    
    (* Trait *)
    (* Empty module 'ShlAssign' *)
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_u8.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_u16.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_u32.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_u64.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_u128.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_usize.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_i8.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_i16.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_i32.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_i64.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_i128.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_u128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_u128_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_i128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_i128_for_isize.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shl_assign(&mut self, other: $f) {
                      *self <<= other
                  }
      *)
      Definition shl_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shl (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shl_assign", InstanceField.Method shl_assign) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_isize.
    
    (* Trait *)
    (* Empty module 'ShrAssign' *)
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_u8.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_u16.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_u32.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_u64.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_u128.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_usize.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_i8.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_i16.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_i32.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_i64.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_i128.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_u128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_u128_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_i128_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_i128_for_isize.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn shr_assign(&mut self, other: $f) {
                      *self >>= other
                  }
      *)
      Definition shr_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            let β := M.deref (| M.read (| self |) |) in
            M.write (| β, BinOp.Wrap.shr (| M.read (| β |), M.read (| other |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("shr_assign", InstanceField.Method shr_assign) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_isize.
  End bit.
End ops.
