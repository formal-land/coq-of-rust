(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ops.
  Module range.
    (* StructTuple
      {
        name := "RangeFull";
        const_params := [];
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_marker_Copy_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_ops_range_RangeFull.
    
    Module Impl_core_clone_Clone_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_ops_range_RangeFull.
    
    Module Impl_core_default_Default_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.StructTuple "core::ops::range::RangeFull" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_ops_range_RangeFull.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFull.
    
    Module Impl_core_cmp_PartialEq_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_ops_range_RangeFull.
    
    Module Impl_core_cmp_Eq_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_ops_range_RangeFull.
    
    Module Impl_core_hash_Hash_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_ops_range_RangeFull.
    
    Module Impl_core_fmt_Debug_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..")
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
              [
                M.read (| fmt |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
                  [ M.alloc (| Value.Array [ M.read (| Value.String ".." |) ] |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_ops_range_RangeFull.
    
    (* StructRecord
      {
        name := "Range";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx); ("end_", Idx) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::Range"
              [
                ("start",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "start"
                      |)
                    ]
                  |));
                ("end_",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_default_Default_where_core_default_Default_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Default *)
      Definition default (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "core::ops::range::Range"
              [
                ("start",
                  M.call_closure (|
                    M.get_trait_method (| "core::default::Default", Idx, [], "default", [] |),
                    []
                  |));
                ("end_",
                  M.call_closure (|
                    M.get_trait_method (| "core::default::Default", Idx, [], "default", [] |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default Idx)) ].
    End Impl_core_default_Default_where_core_default_Default_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_Range_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "start"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "core::ops::range::Range",
                    "start"
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::Range",
                      "end"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "core::ops::range::Range",
                      "end"
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "start"
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::Range",
                      "end"
                    |);
                    M.read (| state |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                []
                              |),
                              [
                                M.read (| fmt |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [ M.alloc (| Value.Array [ M.read (| Value.String ".." |) ] |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ],
                [ Idx ],
                "contains",
                [ U ]
              |),
              [ M.read (| self |); M.read (| item |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "contains" (contains Idx).
      
      (*
          pub fn is_empty(&self) -> bool {
              !(self.start < self.end)
          }
      *)
      Definition is_empty (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (|
              M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialOrd", Idx, [ Idx ], "lt", [] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "start"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "end"
                  |)
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "is_empty" (is_empty Idx).
    End Impl_core_ops_range_Range_Idx.
    
    (* StructRecord
      {
        name := "RangeFrom";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeFrom"
              [
                ("start",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeFrom",
                        "start"
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeFrom",
                  "start"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "core::ops::range::RangeFrom",
                  "start"
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeFrom",
                  "start"
                |);
                M.read (| state |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..")?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeFrom",
                                  "start"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                []
                              |),
                              [
                                M.read (| fmt |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [ M.alloc (| Value.Array [ M.read (| Value.String ".." |) ] |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ],
                [ Idx ],
                "contains",
                [ U ]
              |),
              [ M.read (| self |); M.read (| item |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "contains" (contains Idx).
    End Impl_core_ops_range_RangeFrom_Idx.
    
    (* StructRecord
      {
        name := "RangeTo";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("end_", Idx) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeTo"
              [
                ("end_",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeTo",
                        "end"
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeTo",
                  "end"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "core::ops::range::RangeTo",
                  "end"
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeTo",
                  "end"
                |);
                M.read (| state |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                []
                              |),
                              [
                                M.read (| fmt |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [ M.alloc (| Value.Array [ M.read (| Value.String ".." |) ] |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeTo",
                                  "end"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ],
                [ Idx ],
                "contains",
                [ U ]
              |),
              [ M.read (| self |); M.read (| item |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "contains" (contains Idx).
    End Impl_core_ops_range_RangeTo_Idx.
    
    (* StructRecord
      {
        name := "RangeInclusive";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx); ("end_", Idx); ("exhausted", Ty.path "bool") ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeInclusive"
              [
                ("start",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |)
                    ]
                  |));
                ("end_",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    ]
                  |));
                ("exhausted",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "bool", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::RangeInclusive",
                      "start"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "core::ops::range::RangeInclusive",
                      "start"
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::RangeInclusive",
                      "exhausted"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "core::ops::range::RangeInclusive",
                      "exhausted"
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "bool", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::RangeInclusive",
                      "exhausted"
                    |);
                    M.read (| state |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (*
          pub const fn new(start: Idx, end: Idx) -> Self {
              Self { start, end, exhausted: false }
          }
      *)
      Definition new (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            Value.StructRecord
              "core::ops::range::RangeInclusive"
              [
                ("start", M.read (| start |));
                ("end_", M.read (| end_ |));
                ("exhausted", Value.Bool false)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "new" (new Idx).
      
      (*
          pub const fn start(&self) -> &Idx {
              &self.start
          }
      *)
      Definition start (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "core::ops::range::RangeInclusive",
              "start"
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_start :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "start" (start Idx).
      
      (*
          pub const fn end(&self) -> &Idx {
              &self.end
          }
      *)
      Definition end_ (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "core::ops::range::RangeInclusive",
              "end"
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_end_ :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "end_" (end_ Idx).
      
      (*
          pub const fn into_inner(self) -> (Idx, Idx) {
              (self.start, self.end)
          }
      *)
      Definition into_inner
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::ops::range::RangeInclusive",
                    "start"
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::ops::range::RangeInclusive",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "into_inner" (into_inner Idx).
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ],
                [ Idx ],
                "contains",
                [ U ]
              |),
              [ M.read (| self |); M.read (| item |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "contains" (contains Idx).
      
      (*
          pub fn is_empty(&self) -> bool {
              self.exhausted || !(self.start <= self.end)
          }
      *)
      Definition is_empty (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            LogicalOp.or (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeInclusive",
                  "exhausted"
                |)
              |),
              ltac:(M.monadic
                (UnOp.not (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::PartialOrd", Idx, [ Idx ], "le", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "is_empty" (is_empty Idx).
    End Impl_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_ops_range_RangeInclusive_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "usize" ].
      
      (*
          pub(crate) const fn into_slice_range(self) -> Range<usize> {
              // If we're not exhausted, we want to simply slice `start..end + 1`.
              // If we are exhausted, then slicing with `end + 1..end + 1` gives us an
              // empty range that is still subject to bounds-checks for that endpoint.
              let exclusive_end = self.end + 1;
              let start = if self.exhausted { exclusive_end } else { self.start };
              start..exclusive_end
          }
      *)
      Definition into_slice_range (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ exclusive_end :=
                M.alloc (|
                  BinOp.Wrap.add (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    |),
                    Value.Integer IntegerKind.Usize 1
                  |)
                |) in
              let~ start :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.SubPointer.get_struct_record_field (|
                                self,
                                "core::ops::range::RangeInclusive",
                                "exhausted"
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          exclusive_end));
                      fun γ =>
                        ltac:(M.monadic
                          (M.SubPointer.get_struct_record_field (|
                            self,
                            "core::ops::range::RangeInclusive",
                            "start"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::ops::range::Range"
                  [ ("start", M.read (| start |)); ("end_", M.read (| exclusive_end |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_slice_range :
        M.IsAssociatedFunction Self "into_slice_range" into_slice_range.
    End Impl_core_ops_range_RangeInclusive_usize.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..=")?;
              self.end.fmt(fmt)?;
              if self.exhausted {
                  write!(fmt, " (exhausted)")?;
              }
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeInclusive",
                                  "start"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                []
                              |),
                              [
                                M.read (| fmt |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [ M.alloc (| Value.Array [ M.read (| Value.String "..=" |) ] |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeInclusive",
                                  "end"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeInclusive",
                                  "exhausted"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      [],
                                      "branch",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Formatter",
                                          "write_fmt",
                                          []
                                        |),
                                        [
                                          M.read (| fmt |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [ M.read (| Value.String " (exhausted)" |) ]
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path "core::fmt::Error"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    
    (* StructRecord
      {
        name := "RangeToInclusive";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("end_", Idx) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeToInclusive"
              [
                ("end_",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Idx, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeToInclusive",
                        "end"
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [ Idx ], "eq", [] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeToInclusive",
                  "end"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "core::ops::range::RangeToInclusive",
                  "end"
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hash", Idx, [], "hash", [ __H ] |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeToInclusive",
                  "end"
                |);
                M.read (| state |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..=")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                []
                              |),
                              [
                                M.read (| fmt |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [ M.alloc (| Value.Array [ M.read (| Value.String "..=" |) ] |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::fmt::Debug", Idx, [], "fmt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::RangeToInclusive",
                                  "end"
                                |);
                                M.read (| fmt |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self Idx)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ],
                [ Idx ],
                "contains",
                [ U ]
              |),
              [ M.read (| self |); M.read (| item |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction (Self Idx) "contains" (contains Idx).
    End Impl_core_ops_range_RangeToInclusive_Idx.
    
    (*
    Enum Bound
    {
      const_params := [];
      ty_params := [ "T" ];
      variants :=
        [
          {
            name := "Included";
            item := StructTuple [ T ];
            discriminant := None;
          };
          {
            name := "Excluded";
            item := StructTuple [ T ];
            discriminant := None;
          };
          {
            name := "Unbounded";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Included" |); __self_0 ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Excluded" |); __self_0 ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Unbounded" |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Hash *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ __self_discr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "isize",
                      [],
                      "hash",
                      [ __H ]
                    |),
                    [ __self_discr; M.read (| state |) ]
                  |)
                |) in
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ __H ] |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ __H ] |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_Bound_T.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* PartialEq *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_discr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ __arg1_discr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              M.alloc (|
                LogicalOp.and (|
                  BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                  ltac:(M.monadic
                    (M.read (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::ops::range::Bound::Included",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::ops::range::Bound::Included",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::ops::range::Bound::Excluded",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::ops::range::Bound::Excluded",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                        ]
                      |)
                    |)))
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (*
          pub fn as_ref(&self) -> Bound<&T> {
              match *self {
                  Included(ref x) => Included(x),
                  Excluded(ref x) => Excluded(x),
                  Unbounded => Unbounded,
              }
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Included" [ M.read (| x |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Excluded" [ M.read (| x |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ref" (as_ref T).
      
      (*
          pub fn as_mut(&mut self) -> Bound<&mut T> {
              match *self {
                  Included(ref mut x) => Included(x),
                  Excluded(ref mut x) => Excluded(x),
                  Unbounded => Unbounded,
              }
          }
      *)
      Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Included" [ M.read (| x |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Excluded" [ M.read (| x |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut" (as_mut T).
      
      (*
          pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Bound<U> {
              match self {
                  Unbounded => Unbounded,
                  Included(x) => Included(f(x)),
                  Excluded(x) => Excluded(f(x)),
              }
          }
      *)
      Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U; F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                F,
                                [ Ty.tuple [ T ] ],
                                "call_once",
                                []
                              |),
                              [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                F,
                                [ Ty.tuple [ T ] ],
                                "call_once",
                                []
                              |),
                              [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_map :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "map" (map T).
    End Impl_core_ops_range_Bound_T.
    
    Module Impl_core_ops_range_Bound_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          pub fn cloned(self) -> Bound<T> {
              match self {
                  Bound::Unbounded => Bound::Unbounded,
                  Bound::Included(x) => Bound::Included(x.clone()),
                  Bound::Excluded(x) => Bound::Excluded(x.clone()),
              }
          }
      *)
      Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                              [ M.read (| x |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                              [ M.read (| x |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_cloned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "cloned" (cloned T).
    End Impl_core_ops_range_Bound_ref__T.
    
    (* Trait *)
    Module RangeBounds.
      Definition contains
          (T Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            LogicalOp.and (|
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::range::RangeBounds",
                        Self,
                        [ T ],
                        "start_bound",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::range::Bound::Included",
                            0
                          |) in
                        let start := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.apply (Ty.path "&") [] [ T ],
                              [ Ty.apply (Ty.path "&") [] [ U ] ],
                              "le",
                              []
                            |),
                            [ start; M.alloc (| M.read (| item |) |) ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::range::Bound::Excluded",
                            0
                          |) in
                        let start := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.apply (Ty.path "&") [] [ T ],
                              [ Ty.apply (Ty.path "&") [] [ U ] ],
                              "lt",
                              []
                            |),
                            [ start; M.alloc (| M.read (| item |) |) ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                        M.alloc (| Value.Bool true |)))
                  ]
                |)
              |),
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::range::RangeBounds",
                          Self,
                          [ T ],
                          "end_bound",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::range::Bound::Included",
                              0
                            |) in
                          let end_ := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ U ],
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                "le",
                                []
                              |),
                              [ item; M.alloc (| M.read (| end_ |) |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::range::Bound::Excluded",
                              0
                            |) in
                          let end_ := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ U ],
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                "lt",
                                []
                              |),
                              [ item; M.alloc (| M.read (| end_ |) |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                          M.alloc (| Value.Bool true |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_contains :
        forall (T : Ty.t),
        M.IsProvidedMethod "core::ops::range::RangeBounds" "contains" (contains T).
    End RangeBounds.
    
    Module Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_core_ops_range_RangeFull.
      Definition Self (T : Ty.t) : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_core_ops_range_RangeFull.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeFrom",
                  "start"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeTo",
                  "end"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::Range",
                  "start"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::Range",
                  "end"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeInclusive",
                  "start"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              if self.exhausted {
                  // When the iterator is exhausted, we usually have start == end,
                  // but we want the range to appear empty, containing nothing.
                  Excluded(&self.end)
              } else {
                  Included(&self.end)
              }
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "exhausted"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::ops::range::RangeToInclusive",
                  "end"
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_Tuple_core_ops_range_Bound_T_core_ops_range_Bound_T_.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.tuple
          [
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ];
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ]
          ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              match *self {
                  (Included(ref start), _) => Included(start),
                  (Excluded(ref start), _) => Excluded(start),
                  (Unbounded, _) => Unbounded,
              }
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let start := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Included" [ M.read (| start |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let start := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Excluded" [ M.read (| start |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ := M.is_struct_tuple (| γ0_0, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              match *self {
                  (_, Included(ref end)) => Included(end),
                  (_, Excluded(ref end)) => Excluded(end),
                  (_, Unbounded) => Unbounded,
              }
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let end_ := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Included" [ M.read (| end_ |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let end_ := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple "core::ops::range::Bound::Excluded" [ M.read (| end_ |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ := M.is_struct_tuple (| γ0_1, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_Tuple_core_ops_range_Bound_T_core_ops_range_Bound_T_.
    
    Module Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_Tuple_core_ops_range_Bound_ref__T_core_ops_range_Bound_ref__T_.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.tuple
          [
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ];
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
          ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              self.0
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.SubPointer.get_tuple_field (| M.read (| self |), 0 |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              self.1
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.SubPointer.get_tuple_field (| M.read (| self |), 1 |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_Tuple_core_ops_range_Bound_ref__T_core_ops_range_Bound_ref__T_.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeFrom",
                    "start"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeTo",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "start"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::ops::range::RangeInclusive")
          []
          [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeInclusive",
                    "start"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeInclusive",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::ops::range::RangeToInclusive")
          []
          [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeToInclusive",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_ref__T.
    
    (* Trait *)
    (* Empty module 'OneSidedRange' *)
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeTo_T_T_T_for_core_ops_range_RangeTo_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeTo_T_T_T_for_core_ops_range_RangeTo_T.
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeFrom_T_T_T_for_core_ops_range_RangeFrom_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeFrom_T_T_T_for_core_ops_range_RangeFrom_T.
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeToInclusive_T_T_T_for_core_ops_range_RangeToInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) T ]
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeToInclusive_T_T_T_for_core_ops_range_RangeToInclusive_T.
  End range.
End ops.
