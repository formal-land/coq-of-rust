(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ops.
  Module range.
    (* StructTuple
      {
        name := "RangeFull";
        const_params := [];
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_marker_Copy_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_ops_range_RangeFull.
    
    Module Impl_core_clone_Clone_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.deref (| M.read (| self |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_ops_range_RangeFull.
    
    Module Impl_core_default_Default_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.StructTuple "core::ops::range::RangeFull" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_ops_range_RangeFull.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFull.
    
    Module Impl_core_cmp_PartialEq_core_ops_range_RangeFull_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::ops::range::RangeFull" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_core_ops_range_RangeFull_for_core_ops_range_RangeFull.
    
    Module Impl_core_cmp_Eq_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_ops_range_RangeFull.
    
    Module Impl_core_hash_Hash_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_ops_range_RangeFull.
    
    Module Impl_core_fmt_Debug_for_core_ops_range_RangeFull.
      Definition Self : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..")
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                M.call_closure (|
                  Ty.path "core::fmt::Arguments",
                  M.get_associated_function (|
                    Ty.path "core::fmt::Arguments",
                    "new_const",
                    [ Value.Integer IntegerKind.Usize 1 ],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Array [ mk_str (| ".." |) ] |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_ops_range_RangeFull.
    
    (* StructRecord
      {
        name := "Range";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx); ("end_", Idx) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::Range"
              [
                ("start",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("end_",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_default_Default_where_core_default_Default_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Default *)
      Definition default (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "core::ops::range::Range"
              [
                ("start",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (|
                      "core::default::Default",
                      Idx,
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |));
                ("end_",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (|
                      "core::default::Default",
                      Idx,
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("default", InstanceField.Method (default Idx)) ].
    End Impl_core_default_Default_where_core_default_Default_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_Range_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_Range_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "start"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "core::ops::range::Range",
                      "start"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ] ]
          (Self Idx)
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_Range_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "end"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| ".." |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_Range_Idx.
    
    Module Impl_core_ops_range_Range_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Idx ],
                [],
                [ Idx ],
                "contains",
                [],
                [ U ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "contains" (contains Idx).
      Admitted.
      Global Typeclasses Opaque contains.
      
      (*
          pub fn is_empty(&self) -> bool {
              !(self.start < self.end)
          }
      *)
      Definition is_empty (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialOrd", Idx, [], [ Idx ], "lt", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "start"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "end"
                    |)
                  |)
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "is_empty" (is_empty Idx).
      Admitted.
      Global Typeclasses Opaque is_empty.
    End Impl_core_ops_range_Range_Idx.
    
    (* StructRecord
      {
        name := "RangeFrom";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeFrom"
              [
                ("start",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeFrom",
                              "start"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeFrom_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ops::range::RangeFrom",
                    "start"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "core::ops::range::RangeFrom",
                    "start"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ] ]
          (Self Idx)
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeFrom_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeFrom",
                        "start"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..")?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeFrom",
                                    "start"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| ".." |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeFrom_Idx.
    
    Module Impl_core_ops_range_RangeFrom_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Idx ],
                [],
                [ Idx ],
                "contains",
                [],
                [ U ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "contains" (contains Idx).
      Admitted.
      Global Typeclasses Opaque contains.
    End Impl_core_ops_range_RangeFrom_Idx.
    
    (* StructRecord
      {
        name := "RangeTo";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("end_", Idx) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeTo"
              [
                ("end_",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeTo",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeTo_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ops::range::RangeTo",
                    "end"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "core::ops::range::RangeTo",
                    "end"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ] ]
          (Self Idx)
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeTo_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeTo",
                        "end"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| ".." |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeTo",
                                    "end"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeTo_Idx.
    
    Module Impl_core_ops_range_RangeTo_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Idx ],
                [],
                [ Idx ],
                "contains",
                [],
                [ U ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "contains" (contains Idx).
      Admitted.
      Global Typeclasses Opaque contains.
    End Impl_core_ops_range_RangeTo_Idx.
    
    (* StructRecord
      {
        name := "RangeInclusive";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("start", Idx); ("end_", Idx); ("exhausted", Ty.path "bool") ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeInclusive"
              [
                ("start",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("end_",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("exhausted",
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "bool",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "exhausted"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeInclusive_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "end"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "core::ops::range::RangeInclusive",
                          "end"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::RangeInclusive",
                      "exhausted"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "core::ops::range::RangeInclusive",
                      "exhausted"
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ] ]
          (Self Idx)
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeInclusive_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "bool",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::RangeInclusive",
                            "exhausted"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (*
          pub const fn new(start: Idx, end: Idx) -> Self {
              Self { start, end, exhausted: false }
          }
      *)
      Definition new (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            Value.StructRecord
              "core::ops::range::RangeInclusive"
              [
                ("start", M.read (| start |));
                ("end_", M.read (| end_ |));
                ("exhausted", Value.Bool false)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "new" (new Idx).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub const fn start(&self) -> &Idx {
              &self.start
          }
      *)
      Definition start (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ops::range::RangeInclusive",
                    "start"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_start :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "start" (start Idx).
      Admitted.
      Global Typeclasses Opaque start.
      
      (*
          pub const fn end(&self) -> &Idx {
              &self.end
          }
      *)
      Definition end_ (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ops::range::RangeInclusive",
                    "end"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_end_ :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "end" (end_ Idx).
      Admitted.
      Global Typeclasses Opaque end_.
      
      (*
          pub const fn into_inner(self) -> (Idx, Idx) {
              (self.start, self.end)
          }
      *)
      Definition into_inner
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::ops::range::RangeInclusive",
                    "start"
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::ops::range::RangeInclusive",
                    "end"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_inner :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "into_inner" (into_inner Idx).
      Admitted.
      Global Typeclasses Opaque into_inner.
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ],
                [],
                [ Idx ],
                "contains",
                [],
                [ U ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "contains" (contains Idx).
      Admitted.
      Global Typeclasses Opaque contains.
      
      (*
          pub fn is_empty(&self) -> bool {
              self.exhausted || !(self.start <= self.end)
          }
      *)
      Definition is_empty (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            LogicalOp.or (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::ops::range::RangeInclusive",
                  "exhausted"
                |)
              |),
              ltac:(M.monadic
                (UnOp.not (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialOrd",
                      Idx,
                      [],
                      [ Idx ],
                      "le",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "start"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "end"
                        |)
                      |)
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "is_empty" (is_empty Idx).
      Admitted.
      Global Typeclasses Opaque is_empty.
    End Impl_core_ops_range_RangeInclusive_Idx.
    
    Module Impl_core_ops_range_RangeInclusive_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "usize" ].
      
      (*
          pub(crate) const fn into_slice_range(self) -> Range<usize> {
              // If we're not exhausted, we want to simply slice `start..end + 1`.
              // If we are exhausted, then slicing with `end + 1..end + 1` gives us an
              // empty range that is still subject to bounds-checks for that endpoint.
              let exclusive_end = self.end + 1;
              let start = if self.exhausted { exclusive_end } else { self.start };
              start..exclusive_end
          }
      *)
      Definition into_slice_range (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ exclusive_end : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.add (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    |),
                    Value.Integer IntegerKind.Usize 1
                  |)
                |) in
              let~ start : Ty.path "usize" :=
                M.copy (|
                  M.match_operator (|
                    Some (Ty.path "usize"),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.SubPointer.get_struct_record_field (|
                                self,
                                "core::ops::range::RangeInclusive",
                                "exhausted"
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          exclusive_end));
                      fun γ =>
                        ltac:(M.monadic
                          (M.SubPointer.get_struct_record_field (|
                            self,
                            "core::ops::range::RangeInclusive",
                            "start"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::ops::range::Range"
                  [ ("start", M.read (| start |)); ("end_", M.read (| exclusive_end |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_slice_range :
        M.IsAssociatedFunction.C Self "into_slice_range" into_slice_range.
      Admitted.
      Global Typeclasses Opaque into_slice_range.
    End Impl_core_ops_range_RangeInclusive_usize.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.start.fmt(fmt)?;
              write!(fmt, "..=")?;
              self.end.fmt(fmt)?;
              if self.exhausted {
                  write!(fmt, " (exhausted)")?;
              }
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "start"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| "..=" |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "end"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::ops::range::RangeInclusive",
                                  "exhausted"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::ops::control_flow::ControlFlow")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "core::fmt::Error"
                                          ];
                                        Ty.tuple []
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      [],
                                      [],
                                      "branch",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Formatter",
                                          "write_fmt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| fmt |) |)
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::Arguments",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              [ Value.Integer IntegerKind.Usize 1 ],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.alloc (|
                                                      Value.Array [ mk_str (| " (exhausted)" |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path "core::fmt::Error"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeInclusive_Idx.
    
    
    (* StructRecord
      {
        name := "RangeToInclusive";
        const_params := [];
        ty_params := [ "Idx" ];
        fields := [ ("end_", Idx) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Clone *)
      Definition clone (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::ops::range::RangeToInclusive"
              [
                ("end_",
                  M.call_closure (|
                    Idx,
                    M.get_trait_method (| "core::clone::Clone", Idx, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeToInclusive",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("clone", InstanceField.Method (clone Idx)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeToInclusive_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* PartialEq *)
      Definition eq (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (| "core::cmp::PartialEq", Idx, [], [ Idx ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ops::range::RangeToInclusive",
                    "end"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "core::ops::range::RangeToInclusive",
                    "end"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ] ]
          (Self Idx)
          (* Instance *) [ ("eq", InstanceField.Method (eq Idx)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_Idx_core_ops_range_RangeToInclusive_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (Idx : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq Idx))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (* Hash *)
      Definition hash (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hash", Idx, [], [], "hash", [], [ __H ] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeToInclusive",
                        "end"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("hash", InstanceField.Method (hash Idx)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (*
          fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(fmt, "..=")?;
              self.end.fmt(fmt)?;
              Ok(())
          }
      *)
      Definition fmt (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [], [ self; fmt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let fmt := M.alloc (| fmt |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| "..=" |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_trait_method (|
                                "core::fmt::Debug",
                                Idx,
                                [],
                                [],
                                "fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeToInclusive",
                                    "end"
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Idx : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Idx)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt Idx)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_Idx_for_core_ops_range_RangeToInclusive_Idx.
    
    Module Impl_core_ops_range_RangeToInclusive_Idx.
      Definition Self (Idx : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ].
      
      (*
          pub fn contains<U>(&self, item: &U) -> bool
          where
              Idx: PartialOrd<U>,
              U: ?Sized + PartialOrd<Idx>,
          {
              <Self as RangeBounds<Idx>>::contains(self, item)
          }
      *)
      Definition contains (Idx : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Idx in
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::ops::range::RangeBounds",
                Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ Idx ],
                [],
                [ Idx ],
                "contains",
                [],
                [ U ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (Idx : Ty.t),
        M.IsAssociatedFunction.C (Self Idx) "contains" (contains Idx).
      Admitted.
      Global Typeclasses Opaque contains.
    End Impl_core_ops_range_RangeToInclusive_Idx.
    
    (*
    Enum Bound
    {
      const_params := [];
      ty_params := [ "T" ];
      variants :=
        [
          {
            name := "Included";
            item := StructTuple [ T ];
          };
          {
            name := "Excluded";
            item := StructTuple [ T ];
          };
          {
            name := "Unbounded";
            item := StructTuple [];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_Bound_Included : M.IsDiscriminant "core::ops::range::Bound::Included" 0.
    Axiom IsDiscriminant_Bound_Excluded : M.IsDiscriminant "core::ops::range::Bound::Excluded" 1.
    Axiom IsDiscriminant_Bound_Unbounded : M.IsDiscriminant "core::ops::range::Bound::Unbounded" 2.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                T,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                T,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Included" |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Excluded" |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Unbounded" |) |) |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Hash *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "isize",
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.match_operator (|
                Some (Ty.tuple []),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            T,
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            T,
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ops_range_Bound_T.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_ops_range_Bound_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* PartialEq *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ __arg1_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |) in
              M.alloc (|
                LogicalOp.and (|
                  BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                  ltac:(M.monadic
                    (M.read (|
                      M.match_operator (|
                        Some (Ty.path "bool"),
                        M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::ops::range::Bound::Included",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::ops::range::Bound::Included",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::ops::range::Bound::Excluded",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::ops::range::Bound::Excluded",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                        ]
                      |)
                    |)))
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_ops_range_Bound_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_ops_range_Bound_T.
    
    Module Impl_core_ops_range_Bound_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ].
      
      (*
          pub fn as_ref(&self) -> Bound<&T> {
              match *self {
                  Included(ref x) => Included(x),
                  Excluded(ref x) => Excluded(x),
                  Unbounded => Unbounded,
              }
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::ops::range::Bound")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_ref" (as_ref T).
      Admitted.
      Global Typeclasses Opaque as_ref.
      
      (*
          pub fn as_mut(&mut self) -> Bound<&mut T> {
              match *self {
                  Included(ref mut x) => Included(x),
                  Excluded(ref mut x) => Excluded(x),
                  Unbounded => Unbounded,
              }
          }
      *)
      Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::ops::range::Bound")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_mut" (as_mut T).
      Admitted.
      Global Typeclasses Opaque as_mut.
      
      (*
          pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Bound<U> {
              match self {
                  Unbounded => Unbounded,
                  Included(x) => Included(f(x)),
                  Excluded(x) => Excluded(f(x)),
              }
          }
      *)
      Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U; F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::ops::range::Bound") [] [ U ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              U,
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                F,
                                [],
                                [ Ty.tuple [ T ] ],
                                "call_once",
                                [],
                                []
                              |),
                              [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              U,
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                F,
                                [],
                                [ Ty.tuple [ T ] ],
                                "call_once",
                                [],
                                []
                              |),
                              [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_map :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "map" (map T).
      Admitted.
      Global Typeclasses Opaque map.
    End Impl_core_ops_range_Bound_T.
    
    Module Impl_core_ops_range_Bound_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          pub fn cloned(self) -> Bound<T> {
              match self {
                  Bound::Unbounded => Bound::Unbounded,
                  Bound::Included(x) => Bound::Included(x.clone()),
                  Bound::Excluded(x) => Bound::Excluded(x.clone()),
              }
          }
      *)
      Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                T,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                T,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cloned :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "cloned" (cloned T).
      Admitted.
      Global Typeclasses Opaque cloned.
    End Impl_core_ops_range_Bound_ref__T.
    
    (* Trait *)
    Module RangeBounds.
      Definition contains
          (T Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [ U ], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            LogicalOp.and (|
              M.read (|
                M.match_operator (|
                  Some (Ty.path "bool"),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::range::Bound")
                        []
                        [ Ty.apply (Ty.path "&") [] [ T ] ],
                      M.get_trait_method (|
                        "core::ops::range::RangeBounds",
                        Self,
                        [],
                        [ T ],
                        "start_bound",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::range::Bound::Included",
                            0
                          |) in
                        let start := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.apply (Ty.path "&") [] [ T ],
                              [],
                              [ Ty.apply (Ty.path "&") [] [ U ] ],
                              "le",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, start |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::range::Bound::Excluded",
                            0
                          |) in
                        let start := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.apply (Ty.path "&") [] [ T ],
                              [],
                              [ Ty.apply (Ty.path "&") [] [ U ] ],
                              "lt",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, start |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| item |) |) |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                        M.alloc (| Value.Bool true |)))
                  ]
                |)
              |),
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    Some (Ty.path "bool"),
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::range::Bound")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                        M.get_trait_method (|
                          "core::ops::range::RangeBounds",
                          Self,
                          [],
                          [ T ],
                          "end_bound",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::range::Bound::Included",
                              0
                            |) in
                          let end_ := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ U ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                "le",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, item |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| end_ |) |) |)
                                  |)
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::range::Bound::Excluded",
                              0
                            |) in
                          let end_ := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ U ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, item |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| end_ |) |) |)
                                  |)
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                          M.alloc (| Value.Bool true |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_contains :
        forall (T : Ty.t),
        M.IsProvidedMethod "core::ops::range::RangeBounds" "contains" (contains T).
    End RangeBounds.
    
    Module Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_core_ops_range_RangeFull.
      Definition Self (T : Ty.t) : Ty.t := Ty.path "core::ops::range::RangeFull".
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_core_ops_range_RangeFull.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeFrom",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeTo",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(&self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              if self.exhausted {
                  // When the iterator is exhausted, we usually have start == end,
                  // but we want the range to appear empty, containing nothing.
                  Excluded(&self.end)
              } else {
                  Included(&self.end)
              }
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::ops::range::Bound")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::RangeInclusive",
                            "exhausted"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "end"
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "end"
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ T ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(&self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeToInclusive",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_Tuple_core_ops_range_Bound_T_core_ops_range_Bound_T_.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.tuple
          [
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ];
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ T ]
          ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              match *self {
                  (Included(ref start), _) => Included(start),
                  (Excluded(ref start), _) => Excluded(start),
                  (Unbounded, _) => Unbounded,
              }
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::ops::range::Bound")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let start := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| start |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let start := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| start |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ := M.is_struct_tuple (| γ0_0, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              match *self {
                  (_, Included(ref end)) => Included(end),
                  (_, Excluded(ref end)) => Excluded(end),
                  (_, Unbounded) => Unbounded,
              }
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::ops::range::Bound")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "core::ops::range::Bound::Included",
                          0
                        |) in
                      let end_ := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Included"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| end_ |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "core::ops::range::Bound::Excluded",
                          0
                        |) in
                      let end_ := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::ops::range::Bound::Excluded"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| end_ |) |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ := M.is_struct_tuple (| γ0_1, "core::ops::range::Bound::Unbounded" |) in
                      M.alloc (| Value.StructTuple "core::ops::range::Bound::Unbounded" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_Tuple_core_ops_range_Bound_T_core_ops_range_Bound_T_.
    
    Module Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_Tuple_core_ops_range_Bound_ref__T_core_ops_range_Bound_ref__T_.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.tuple
          [
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ];
            Ty.apply (Ty.path "core::ops::range::Bound") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
          ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              self.0
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.SubPointer.get_tuple_field (| M.deref (| M.read (| self |) |), 0 |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              self.1
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.SubPointer.get_tuple_field (| M.deref (| M.read (| self |) |), 1 |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_where_core_marker_Sized_T_T_for_Tuple_core_ops_range_Bound_ref__T_core_ops_range_Bound_ref__T_.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeFrom",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeFrom_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeTo",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeTo_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Excluded(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Excluded"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_Range_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::ops::range::RangeInclusive")
          []
          [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Included(self.start)
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeInclusive_ref__T.
    
    Module Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_ref__T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::ops::range::RangeToInclusive")
          []
          [ Ty.apply (Ty.path "&") [] [ T ] ].
      
      (*
          fn start_bound(&self) -> Bound<&T> {
              Unbounded
          }
      *)
      Definition start_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::ops::range::Bound::Unbounded" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn end_bound(&self) -> Bound<&T> {
              Included(self.end)
          }
      *)
      Definition end_bound (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::ops::range::Bound::Included"
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::RangeToInclusive",
                        "end"
                      |)
                    |)
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::RangeBounds"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("start_bound", InstanceField.Method (start_bound T));
            ("end_bound", InstanceField.Method (end_bound T))
          ].
    End Impl_core_ops_range_RangeBounds_T_for_core_ops_range_RangeToInclusive_ref__T.
    
    (* Trait *)
    (* Empty module 'OneSidedRange' *)
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeTo_T_T_T_for_core_ops_range_RangeTo_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeTo_T_T_T_for_core_ops_range_RangeTo_T.
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeFrom_T_T_T_for_core_ops_range_RangeFrom_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeFrom_T_T_T_for_core_ops_range_RangeFrom_T.
    
    Module Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeToInclusive_T_T_T_for_core_ops_range_RangeToInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeToInclusive") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::range::OneSidedRange"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [].
    End Impl_core_ops_range_OneSidedRange_where_core_ops_range_RangeBounds_core_ops_range_RangeToInclusive_T_T_T_for_core_ops_range_RangeToInclusive_T.
  End range.
End ops.
