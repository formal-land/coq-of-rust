(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module option.
  (*
  Enum Option
  {
    const_params := [];
    ty_params := [ "T" ];
    variants :=
      [
        {
          name := "None";
          item := StructTuple [];
        };
        {
          name := "Some";
          item := StructTuple [ T ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Option_None : M.IsDiscriminant "core::option::Option::None" 0.
  Axiom IsDiscriminant_Option_Some : M.IsDiscriminant "core::option::Option::Some" 1.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_option_Option_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.tuple [],
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_core_option_Option_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_str",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "None" |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_tuple_field1_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Some" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_option_Option_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (* Hash *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              Ty.tuple [],
              M.match_operator (|
                Ty.tuple [],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_for_core_option_Option_T.
  
  Module Impl_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        pub const fn is_some(&self) -> bool {
            matches!( *self, Some(_))
        }
    *)
    Definition is_some (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.path "bool",
            M.deref (| M.read (| self |) |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  Value.Bool true));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_some :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "is_some" (is_some T).
    Admitted.
    Global Typeclasses Opaque is_some.
    
    (*
        pub fn is_some_and(self, f: impl FnOnce(T) -> bool) -> bool {
            match self {
                None => false,
                Some(x) => f(x),
            }
        }
    *)
    Definition is_some_and (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ impl_FnOnce_T__arrow_bool ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| impl_FnOnce_T__arrow_bool, f |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.Bool false));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      impl_FnOnce_T__arrow_bool,
                      [],
                      [ Ty.tuple [ T ] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_some_and :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "is_some_and" (is_some_and T).
    Admitted.
    Global Typeclasses Opaque is_some_and.
    
    (*
        pub const fn is_none(&self) -> bool {
            !self.is_some()
        }
    *)
    Definition is_none (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          UnOp.not (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                "is_some",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_none :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "is_none" (is_none T).
    Admitted.
    Global Typeclasses Opaque is_none.
    
    (*
        pub fn is_none_or(self, f: impl FnOnce(T) -> bool) -> bool {
            match self {
                None => true,
                Some(x) => f(x),
            }
        }
    *)
    Definition is_none_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ impl_FnOnce_T__arrow_bool ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| impl_FnOnce_T__arrow_bool, f |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.Bool true));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      impl_FnOnce_T__arrow_bool,
                      [],
                      [ Ty.tuple [ T ] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_none_or :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "is_none_or" (is_none_or T).
    Admitted.
    Global Typeclasses Opaque is_none_or.
    
    (*
        pub const fn as_ref(&self) -> Option<&T> {
            match *self {
                Some(ref x) => Some(x),
                None => None,
            }
        }
    *)
    Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
            M.deref (| M.read (| self |) |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_ref" (as_ref T).
    Admitted.
    Global Typeclasses Opaque as_ref.
    
    (*
        pub const fn as_mut(&mut self) -> Option<&mut T> {
            match *self {
                Some(ref mut x) => Some(x),
                None => None,
            }
        }
    *)
    Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            M.deref (| M.read (| self |) |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_mut" (as_mut T).
    Admitted.
    Global Typeclasses Opaque as_mut.
    
    (*
        pub const fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {
            // FIXME(const-hack): use `map` once that is possible
            match Pin::get_ref(self).as_ref() {
                // SAFETY: `x` is guaranteed to be pinned because it comes from `self`
                // which is pinned.
                Some(x) => unsafe { Some(Pin::new_unchecked(x)) },
                None => None,
            }
        }
    *)
    Definition as_pin_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              self
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ] ],
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  "as_ref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::pin::Pin")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                            ],
                          "get_ref",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |)
                  |)
                ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| Ty.apply (Ty.path "&") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::pin::Pin")
                            []
                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                          "new_unchecked",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_pin_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_pin_ref" (as_pin_ref T).
    Admitted.
    Global Typeclasses Opaque as_pin_ref.
    
    (*
        pub const fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {
            // SAFETY: `get_unchecked_mut` is never used to move the `Option` inside `self`.
            // `x` is guaranteed to be pinned because it comes from `self` which is pinned.
            unsafe {
                // FIXME(const-hack): use `map` once that is possible
                match Pin::get_unchecked_mut(self).as_mut() {
                    Some(x) => Some(Pin::new_unchecked(x)),
                    None => None,
                }
            }
        }
    *)
    Definition as_pin_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              self
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ] ],
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  "as_mut",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::pin::Pin")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                            ],
                          "get_unchecked_mut",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |)
                  |)
                ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                    ]
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::pin::Pin")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                          "new_unchecked",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                    ]
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_pin_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_pin_mut" (as_pin_mut T).
    Admitted.
    Global Typeclasses Opaque as_pin_mut.
    
    (*
        const fn len(&self) -> usize {
            // Using the intrinsic avoids emitting a branch to get the 0 or 1.
            let discriminant: isize = crate::intrinsics::discriminant_value(self);
            discriminant as usize
        }
    *)
    Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.read (|
            let~ discriminant : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (| Ty.path "usize", M.cast (Ty.path "usize") (M.read (| discriminant |)) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "len" (len T).
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub const fn as_slice(&self) -> &[T] {
            // SAFETY: When the `Option` is `Some`, we're using the actual pointer
            // to the payload, with a length of 1, so this is equivalent to
            // `slice::from_ref`, and thus is safe.
            // When the `Option` is `None`, the length used is 0, so to be safe it
            // just needs to be aligned, which it is because `&self` is aligned and
            // the offset used is a multiple of alignment.
            //
            // In the new version, the intrinsic always returns a pointer to an
            // in-bounds and correctly aligned position for a `T` (even if in the
            // `None` case it's just padding).
            unsafe {
                slice::from_raw_parts(
                    (self as *const Self).byte_add(core::mem::offset_of!(Self, Some.0)).cast(),
                    self.len(),
                )
            }
        }
    *)
    Definition as_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "*const")
                        []
                        [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                      "cast",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "*const")
                          []
                          [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*const")
                            []
                            [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                          "byte_add",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.use
                              (M.alloc (|
                                Ty.apply
                                  (Ty.path "*const")
                                  []
                                  [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                                M.borrow (|
                                  Pointer.Kind.ConstPointer,
                                  M.deref (| M.read (| self |) |)
                                |)
                              |))
                          |);
                          M.read (|
                            (* `OffsetOf` expression are not handled yet *)
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_slice" (as_slice T).
    Admitted.
    Global Typeclasses Opaque as_slice.
    
    (*
        pub const fn as_mut_slice(&mut self) -> &mut [T] {
            // SAFETY: When the `Option` is `Some`, we're using the actual pointer
            // to the payload, with a length of 1, so this is equivalent to
            // `slice::from_mut`, and thus is safe.
            // When the `Option` is `None`, the length used is 0, so to be safe it
            // just needs to be aligned, which it is because `&self` is aligned and
            // the offset used is a multiple of alignment.
            //
            // In the new version, the intrinsic creates a `*const T` from a
            // mutable reference  so it is safe to cast back to a mutable pointer
            // here. As with `as_slice`, the intrinsic always returns a pointer to
            // an in-bounds and correctly aligned position for a `T` (even if in
            // the `None` case it's just padding).
            unsafe {
                slice::from_raw_parts_mut(
                    (self as *mut Self).byte_add(core::mem::offset_of!(Self, Some.0)).cast(),
                    self.len(),
                )
            }
        }
    *)
    Definition as_mut_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        M.get_function (| "core::slice::raw::from_raw_parts_mut", [], [ T ] |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                              "cast",
                              [],
                              [ T ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                                  "byte_add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.use
                                      (M.alloc (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                                        M.borrow (|
                                          Pointer.Kind.MutPointer,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      |))
                                  |);
                                  M.read (|
                                    (* `OffsetOf` expression are not handled yet *)
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_mut_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_mut_slice" (as_mut_slice T).
    Admitted.
    Global Typeclasses Opaque as_mut_slice.
    
    (*
        pub const fn expect(self, msg: &str) -> T {
            match self {
                Some(val) => val,
                None => expect_failed(msg),
            }
        }
    *)
    Definition expect (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; msg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let msg := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "str" ], msg |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let val := M.copy (| T, γ0_0 |) in
                  M.read (| val |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::option::expect_failed", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| msg |) |) |) ]
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_expect :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "expect" (expect T).
    Admitted.
    Global Typeclasses Opaque expect.
    
    (*
        pub const fn unwrap(self) -> T {
            match self {
                Some(val) => val,
                None => unwrap_failed(),
            }
        }
    *)
    Definition unwrap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let val := M.copy (| T, γ0_0 |) in
                  M.read (| val |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::option::unwrap_failed", [], [] |),
                      []
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unwrap" (unwrap T).
    Admitted.
    Global Typeclasses Opaque unwrap.
    
    (*
        pub fn unwrap_or(self, default: T) -> T {
            match self {
                Some(x) => x,
                None => default,
            }
        }
    *)
    Definition unwrap_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; default ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let default := M.alloc (| T, default |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.read (| x |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.read (| default |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_or :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unwrap_or" (unwrap_or T).
    Admitted.
    Global Typeclasses Opaque unwrap_or.
    
    (*
        pub fn unwrap_or_else<F>(self, f: F) -> T
        where
            F: FnOnce() -> T,
        {
            match self {
                Some(x) => x,
                None => f(),
            }
        }
    *)
    Definition unwrap_or_else
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.read (| x |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.call_closure (|
                    T,
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      F,
                      [],
                      [ Ty.tuple [] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [] ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_or_else :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unwrap_or_else" (unwrap_or_else T).
    Admitted.
    Global Typeclasses Opaque unwrap_or_else.
    
    (*
        pub fn unwrap_or_default(self) -> T
        where
            T: Default,
        {
            match self {
                Some(x) => x,
                None => T::default(),
            }
        }
    *)
    Definition unwrap_or_default
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.read (| x |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                    []
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_or_default :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unwrap_or_default" (unwrap_or_default T).
    Admitted.
    Global Typeclasses Opaque unwrap_or_default.
    
    (*
        pub const unsafe fn unwrap_unchecked(self) -> T {
            match self {
                Some(val) => val,
                // SAFETY: the safety contract must be upheld by the caller.
                None => unsafe { hint::unreachable_unchecked() },
            }
        }
    *)
    Definition unwrap_unchecked
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          M.match_operator (|
            T,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let val := M.copy (| T, γ0_0 |) in
                  M.read (| val |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::hint::unreachable_unchecked", [], [] |),
                      []
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_unchecked :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unwrap_unchecked" (unwrap_unchecked T).
    Admitted.
    Global Typeclasses Opaque unwrap_unchecked.
    
    (*
        pub fn map<U, F>(self, f: F) -> Option<U>
        where
            F: FnOnce(T) -> U,
        {
            match self {
                Some(x) => Some(f(x)),
                None => None,
            }
        }
    *)
    Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ U ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ U ]
                    [
                      M.call_closure (|
                        U,
                        M.get_trait_method (|
                          "core::ops::function::FnOnce",
                          F,
                          [],
                          [ Ty.tuple [ T ] ],
                          "call_once",
                          [],
                          []
                        |),
                        [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ U ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_map :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "map" (map T).
    Admitted.
    Global Typeclasses Opaque map.
    
    (*
        pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {
            if let Some(ref x) = self {
                f(x);
            }
    
            self
        }
    *)
    Definition inspect (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| F, f |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := self in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let x := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ0_0 |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [],
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                              "call_once",
                              [],
                              []
                            |),
                            [
                              M.read (| f |);
                              Value.Tuple
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                            ]
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inspect :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "inspect" (inspect T).
    Admitted.
    Global Typeclasses Opaque inspect.
    
    (*
        pub fn map_or<U, F>(self, default: U, f: F) -> U
        where
            F: FnOnce(T) -> U,
        {
            match self {
                Some(t) => f(t),
                None => default,
            }
        }
    *)
    Definition map_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; default; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let default := M.alloc (| U, default |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            U,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let t := M.copy (| T, γ0_0 |) in
                  M.call_closure (|
                    U,
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      F,
                      [],
                      [ Ty.tuple [ T ] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [ M.read (| t |) ] ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.read (| default |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_map_or :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "map_or" (map_or T).
    Admitted.
    Global Typeclasses Opaque map_or.
    
    (*
        pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U
        where
            D: FnOnce() -> U,
            F: FnOnce(T) -> U,
        {
            match self {
                Some(t) => f(t),
                None => default(),
            }
        }
    *)
    Definition map_or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; D; F ], [ self; default; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let default := M.alloc (| D, default |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            U,
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let t := M.copy (| T, γ0_0 |) in
                  M.call_closure (|
                    U,
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      F,
                      [],
                      [ Ty.tuple [ T ] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [ M.read (| t |) ] ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.call_closure (|
                    U,
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      D,
                      [],
                      [ Ty.tuple [] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| default |); Value.Tuple [] ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_map_or_else :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "map_or_else" (map_or_else T).
    Admitted.
    Global Typeclasses Opaque map_or_else.
    
    (*
        pub fn ok_or<E>(self, err: E) -> Result<T, E> {
            match self {
                Some(v) => Ok(v),
                None => Err(err),
            }
        }
    *)
    Definition ok_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ E ], [ self; err ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let err := M.alloc (| E, err |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::result::Result") [] [ T; E ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let v := M.copy (| T, γ0_0 |) in
                  Value.StructTuple "core::result::Result::Ok" [] [ T; E ] [ M.read (| v |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::result::Result::Err" [] [ T; E ] [ M.read (| err |) ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ok_or :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "ok_or" (ok_or T).
    Admitted.
    Global Typeclasses Opaque ok_or.
    
    (*
        pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
        where
            F: FnOnce() -> E,
        {
            match self {
                Some(v) => Ok(v),
                None => Err(err()),
            }
        }
    *)
    Definition ok_or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ E; F ], [ self; err ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let err := M.alloc (| F, err |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::result::Result") [] [ T; E ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let v := M.copy (| T, γ0_0 |) in
                  Value.StructTuple "core::result::Result::Ok" [] [ T; E ] [ M.read (| v |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::result::Result::Err"
                    []
                    [ T; E ]
                    [
                      M.call_closure (|
                        E,
                        M.get_trait_method (|
                          "core::ops::function::FnOnce",
                          F,
                          [],
                          [ Ty.tuple [] ],
                          "call_once",
                          [],
                          []
                        |),
                        [ M.read (| err |); Value.Tuple [] ]
                      |)
                    ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ok_or_else :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "ok_or_else" (ok_or_else T).
    Admitted.
    Global Typeclasses Opaque ok_or_else.
    
    (*
        pub fn as_deref(&self) -> Option<&T::Target>
        where
            T: Deref,
        {
            self.as_ref().map(|t| t.deref())
        }
    *)
    Definition as_deref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ]
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              "map",
              [],
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ];
                Ty.function
                  [ Ty.apply (Ty.path "&") [] [ T ] ]
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  "as_ref",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ],
                          M.alloc (| Ty.apply (Ty.path "&") [] [ T ], α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let t := M.copy (| Ty.apply (Ty.path "&") [] [ T ], γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "core::ops::deref::Deref"
                                        []
                                        []
                                        T
                                        "Target"
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    T,
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_deref :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_deref" (as_deref T).
    Admitted.
    Global Typeclasses Opaque as_deref.
    
    (*
        pub fn as_deref_mut(&mut self) -> Option<&mut T::Target>
        where
            T: DerefMut,
        {
            self.as_mut().map(|t| t.deref_mut())
        }
    *)
    Definition as_deref_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ]
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              "map",
              [],
              [
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ];
                Ty.function
                  [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                  (Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  "as_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ],
                          M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let t := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "core::ops::deref::Deref"
                                        []
                                        []
                                        T
                                        "Target"
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    T,
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| t |) |) |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_deref_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "as_deref_mut" (as_deref_mut T).
    Admitted.
    Global Typeclasses Opaque as_deref_mut.
    
    (*
        pub fn iter(&self) -> Iter<'_, T> {
            Iter { inner: Item { opt: self.as_ref() } }
        }
    *)
    Definition iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          Value.mkStructRecord
            "core::option::Iter"
            []
            [ T ]
            [
              ("inner",
                Value.mkStructRecord
                  "core::option::Item"
                  []
                  [ Ty.apply (Ty.path "&") [] [ T ] ]
                  [
                    ("opt",
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          "as_ref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |))
                  ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_iter :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "iter" (iter T).
    Admitted.
    Global Typeclasses Opaque iter.
    
    (*
        pub fn iter_mut(&mut self) -> IterMut<'_, T> {
            IterMut { inner: Item { opt: self.as_mut() } }
        }
    *)
    Definition iter_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          Value.mkStructRecord
            "core::option::IterMut"
            []
            [ T ]
            [
              ("inner",
                Value.mkStructRecord
                  "core::option::Item"
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                  [
                    ("opt",
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          "as_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                      |))
                  ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_iter_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "iter_mut" (iter_mut T).
    Admitted.
    Global Typeclasses Opaque iter_mut.
    
    (*
        pub fn and<U>(self, optb: Option<U>) -> Option<U> {
            match self {
                Some(_) => optb,
                None => None,
            }
        }
    *)
    Definition and (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U ], [ self; optb ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let optb := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ U ], optb |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ U ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  M.read (| optb |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ U ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_and :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "and" (and T).
    Admitted.
    Global Typeclasses Opaque and.
    
    (*
        pub fn and_then<U, F>(self, f: F) -> Option<U>
        where
            F: FnOnce(T) -> Option<U>,
        {
            match self {
                Some(x) => f(x),
                None => None,
            }
        }
    *)
    Definition and_then (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ U ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.copy (| T, γ0_0 |) in
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ U ],
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      F,
                      [],
                      [ Ty.tuple [ T ] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ U ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_and_then :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "and_then" (and_then T).
    Admitted.
    Global Typeclasses Opaque and_then.
    
    (*
        pub fn filter<P>(self, predicate: P) -> Self
        where
            P: FnOnce(&T) -> bool,
        {
            if let Some(x) = self {
                if predicate(&x) {
                    return Some(x);
                }
            }
            None
        }
    *)
    Definition filter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ P ], [ self; predicate ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let predicate := M.alloc (| P, predicate |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ T ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := self in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let x := M.copy (| T, γ0_0 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::ops::function::FnOnce",
                                            P,
                                            [],
                                            [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                            "call_once",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| predicate |);
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.borrow (| Pointer.Kind.Ref, x |) |)
                                                |)
                                              ]
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          []
                                          [ T ]
                                          [ M.read (| x |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  Value.StructTuple "core::option::Option::None" [] [ T ] []
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_filter :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "filter" (filter T).
    Admitted.
    Global Typeclasses Opaque filter.
    
    (*
        pub fn or(self, optb: Option<T>) -> Option<T> {
            match self {
                x @ Some(_) => x,
                None => optb,
            }
        }
    *)
    Definition or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; optb ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let optb := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], optb |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let x := M.copy (| Ty.apply (Ty.path "core::option::Option") [] [ T ], γ |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  M.read (| x |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.read (| optb |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_or :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "or" (or T).
    Admitted.
    Global Typeclasses Opaque or.
    
    (*
        pub fn or_else<F>(self, f: F) -> Option<T>
        where
            F: FnOnce() -> Option<T>,
        {
            match self {
                x @ Some(_) => x,
                None => f(),
            }
        }
    *)
    Definition or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let x := M.copy (| Ty.apply (Ty.path "core::option::Option") [] [ T ], γ |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  M.read (| x |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      F,
                      [],
                      [ Ty.tuple [] ],
                      "call_once",
                      [],
                      []
                    |),
                    [ M.read (| f |); Value.Tuple [] ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_or_else :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "or_else" (or_else T).
    Admitted.
    Global Typeclasses Opaque or_else.
    
    (*
        pub fn xor(self, optb: Option<T>) -> Option<T> {
            match (self, optb) {
                (a @ Some(_), None) => a,
                (None, b @ Some(_)) => b,
                _ => None,
            }
        }
    *)
    Definition xor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; optb ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let optb := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], optb |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "core::option::Option") [] [ T ];
                  Ty.apply (Ty.path "core::option::Option") [] [ T ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| optb |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let a := M.copy (| Ty.apply (Ty.path "core::option::Option") [] [ T ], γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  M.read (| a |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let b := M.copy (| Ty.apply (Ty.path "core::option::Option") [] [ T ], γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  M.read (| b |)));
              fun γ => ltac:(M.monadic (Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_xor :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "xor" (xor T).
    Admitted.
    Global Typeclasses Opaque xor.
    
    (*
        pub fn insert(&mut self, value: T) -> &mut T {
            *self = Some(value);
    
            // SAFETY: the code above just filled the option
            unsafe { self.as_mut().unwrap_unchecked() }
        }
    *)
    Definition insert (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; value ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let value := M.alloc (| T, value |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| value |) ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "&mut") [] [ T ],
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                              "unwrap_unchecked",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                  "as_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_insert :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "insert" (insert T).
    Admitted.
    Global Typeclasses Opaque insert.
    
    (*
        pub fn get_or_insert(&mut self, value: T) -> &mut T {
            self.get_or_insert_with(|| value)
        }
    *)
    Definition get_or_insert (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; value ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let value := M.alloc (| T, value |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      "get_or_insert_with",
                      [],
                      [ Ty.function [] T ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  T,
                                  M.alloc (| Ty.tuple [], α0 |),
                                  [ fun γ => ltac:(M.monadic (M.read (| value |))) ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_or_insert :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "get_or_insert" (get_or_insert T).
    Admitted.
    Global Typeclasses Opaque get_or_insert.
    
    (*
        pub fn get_or_insert_default(&mut self) -> &mut T
        where
            T: Default,
        {
            self.get_or_insert_with(T::default)
        }
    *)
    Definition get_or_insert_default
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      "get_or_insert_with",
                      [],
                      [ Ty.function [] T ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.get_trait_method (|
                        "core::default::Default",
                        T,
                        [],
                        [],
                        "default",
                        [],
                        []
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_or_insert_default :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "get_or_insert_default" (get_or_insert_default T).
    Admitted.
    Global Typeclasses Opaque get_or_insert_default.
    
    (*
        pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
        where
            F: FnOnce() -> T,
        {
            if let None = self {
                *self = Some(f());
            }
    
            // SAFETY: a `None` variant for `self` would have been replaced by a `Some`
            // variant in the code above.
            unsafe { self.as_mut().unwrap_unchecked() }
        }
    *)
    Definition get_or_insert_with
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let f := M.alloc (| F, f |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := self in
                          let γ := M.read (| γ |) in
                          let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.write (|
                                M.deref (| M.read (| self |) |),
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  []
                                  [ T ]
                                  [
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::ops::function::FnOnce",
                                        F,
                                        [],
                                        [ Ty.tuple [] ],
                                        "call_once",
                                        [],
                                        []
                                      |),
                                      [ M.read (| f |); Value.Tuple [] ]
                                    |)
                                  ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "&mut") [] [ T ],
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                              "unwrap_unchecked",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                  "as_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_or_insert_with :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "get_or_insert_with" (get_or_insert_with T).
    Admitted.
    Global Typeclasses Opaque get_or_insert_with.
    
    (*
        pub const fn take(&mut self) -> Option<T> {
            // FIXME(const-hack) replace `mem::replace` by `mem::take` when the latter is const ready
            mem::replace(self, None)
        }
    *)
    Definition take (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            M.get_function (|
              "core::mem::replace",
              [],
              [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              Value.StructTuple "core::option::Option::None" [] [ T ] []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_take :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "take" (take T).
    Admitted.
    Global Typeclasses Opaque take.
    
    (*
        pub fn take_if<P>(&mut self, predicate: P) -> Option<T>
        where
            P: FnOnce(&mut T) -> bool,
        {
            if self.as_mut().map_or(false, predicate) { self.take() } else { None }
        }
    *)
    Definition take_if (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ P ], [ self; predicate ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let predicate := M.alloc (| P, predicate |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                            "map_or",
                            [],
                            [ Ty.path "bool"; P ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                "as_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |);
                            Value.Bool false;
                            M.read (| predicate |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      "take",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)));
              fun γ => ltac:(M.monadic (Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_take_if :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "take_if" (take_if T).
    Admitted.
    Global Typeclasses Opaque take_if.
    
    (*
        pub const fn replace(&mut self, value: T) -> Option<T> {
            mem::replace(self, Some(value))
        }
    *)
    Definition replace (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; value ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let value := M.alloc (| T, value |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            M.get_function (|
              "core::mem::replace",
              [],
              [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| value |) ]
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_replace :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "replace" (replace T).
    Admitted.
    Global Typeclasses Opaque replace.
    
    (*
        pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {
            match (self, other) {
                (Some(a), Some(b)) => Some((a, b)),
                _ => None,
            }
        }
    *)
    Definition zip (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U ], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let other := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ U ], other |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.tuple [ T; U ] ],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "core::option::Option") [] [ T ];
                  Ty.apply (Ty.path "core::option::Option") [] [ U ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| other |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let a := M.copy (| T, γ1_0 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let b := M.copy (| U, γ1_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.tuple [ T; U ] ]
                    [ Value.Tuple [ M.read (| a |); M.read (| b |) ] ]));
              fun γ =>
                ltac:(M.monadic
                  (Value.StructTuple "core::option::Option::None" [] [ Ty.tuple [ T; U ] ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_zip :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "zip" (zip T).
    Admitted.
    Global Typeclasses Opaque zip.
    
    (*
        pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>
        where
            F: FnOnce(T, U) -> R,
        {
            match (self, other) {
                (Some(a), Some(b)) => Some(f(a, b)),
                _ => None,
            }
        }
    *)
    Definition zip_with (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F; R ], [ self; other; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          let other := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ U ], other |) in
          let f := M.alloc (| F, f |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ R ],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "core::option::Option") [] [ T ];
                  Ty.apply (Ty.path "core::option::Option") [] [ U ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| other |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let a := M.copy (| T, γ1_0 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let b := M.copy (| U, γ1_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ R ]
                    [
                      M.call_closure (|
                        R,
                        M.get_trait_method (|
                          "core::ops::function::FnOnce",
                          F,
                          [],
                          [ Ty.tuple [ T; U ] ],
                          "call_once",
                          [],
                          []
                        |),
                        [ M.read (| f |); Value.Tuple [ M.read (| a |); M.read (| b |) ] ]
                      |)
                    ]));
              fun γ => ltac:(M.monadic (Value.StructTuple "core::option::Option::None" [] [ R ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_zip_with :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "zip_with" (zip_with T).
    Admitted.
    Global Typeclasses Opaque zip_with.
  End Impl_core_option_Option_T.
  
  Module Impl_core_option_Option_Tuple_T_U_.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.tuple [ T; U ] ].
    
    (*
        pub fn unzip(self) -> (Option<T>, Option<U>) {
            match self {
                Some((a, b)) => (Some(a), Some(b)),
                None => (None, None),
            }
        }
    *)
    Definition unzip (T U : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T U in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.tuple [ T; U ] ],
              self
            |) in
          M.match_operator (|
            Ty.tuple
              [
                Ty.apply (Ty.path "core::option::Option") [] [ T ];
                Ty.apply (Ty.path "core::option::Option") [] [ U ]
              ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                  let a := M.copy (| T, γ1_0 |) in
                  let b := M.copy (| U, γ1_1 |) in
                  Value.Tuple
                    [
                      Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| a |) ];
                      Value.StructTuple "core::option::Option::Some" [] [ U ] [ M.read (| b |) ]
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.Tuple
                    [
                      Value.StructTuple "core::option::Option::None" [] [ T ] [];
                      Value.StructTuple "core::option::Option::None" [] [ U ] []
                    ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unzip :
      forall (T U : Ty.t),
      M.IsAssociatedFunction.C (Self T U) "unzip" (unzip T U).
    Admitted.
    Global Typeclasses Opaque unzip.
  End Impl_core_option_Option_Tuple_T_U_.
  
  Module Impl_core_option_Option_ref__T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
    
    (*
        pub const fn copied(self) -> Option<T>
        where
            T: Copy,
        {
            // FIXME(const-hack): this implementation, which sidesteps using `Option::map` since it's not const
            // ready yet, should be reverted when possible to avoid code repetition
            match self {
                Some(&v) => Some(v),
                None => None,
            }
        }
    *)
    Definition copied (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let v := M.copy (| T, γ0_0 |) in
                  Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| v |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copied :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "copied" (copied T).
    Admitted.
    Global Typeclasses Opaque copied.
    
    (*
        pub fn cloned(self) -> Option<T>
        where
            T: Clone,
        {
            match self {
                Some(t) => Some(t.clone()),
                None => None,
            }
        }
    *)
    Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let t := M.copy (| Ty.apply (Ty.path "&") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ T ]
                    [
                      M.call_closure (|
                        T,
                        M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_cloned :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "cloned" (cloned T).
    Admitted.
    Global Typeclasses Opaque cloned.
  End Impl_core_option_Option_ref__T.
  
  Module Impl_core_option_Option_ref_mut_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ].
    
    (*
        pub const fn copied(self) -> Option<T>
        where
            T: Copy,
        {
            match self {
                Some(&mut t) => Some(t),
                None => None,
            }
        }
    *)
    Definition copied (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let t := M.copy (| T, γ0_0 |) in
                  Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| t |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copied :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "copied" (copied T).
    Admitted.
    Global Typeclasses Opaque copied.
    
    (*
        pub fn cloned(self) -> Option<T>
        where
            T: Clone,
        {
            match self {
                Some(t) => Some(t.clone()),
                None => None,
            }
        }
    *)
    Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let t := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ T ]
                    [
                      M.call_closure (|
                        T,
                        M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_cloned :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "cloned" (cloned T).
    Admitted.
    Global Typeclasses Opaque cloned.
  End Impl_core_option_Option_ref_mut_T.
  
  Module Impl_core_option_Option_core_result_Result_T_E.
    Definition Self (T E : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "core::option::Option")
        []
        [ Ty.apply (Ty.path "core::result::Result") [] [ T; E ] ].
    
    (*
        pub const fn transpose(self) -> Result<Option<T>, E> {
            match self {
                Some(Ok(x)) => Ok(Some(x)),
                Some(Err(e)) => Err(e),
                None => Ok(None),
            }
        }
    *)
    Definition transpose (T E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T E in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "core::result::Result") [] [ T; E ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.apply (Ty.path "core::option::Option") [] [ T ]; E ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ0_0, "core::result::Result::Ok", 0 |) in
                  let x := M.copy (| T, γ1_0 |) in
                  Value.StructTuple
                    "core::result::Result::Ok"
                    []
                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ]; E ]
                    [ Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| x |) ]
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::result::Result::Err",
                      0
                    |) in
                  let e := M.copy (| E, γ1_0 |) in
                  Value.StructTuple
                    "core::result::Result::Err"
                    []
                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ]; E ]
                    [ M.read (| e |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::result::Result::Ok"
                    []
                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ]; E ]
                    [ Value.StructTuple "core::option::Option::None" [] [ T ] [] ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_transpose :
      forall (T E : Ty.t),
      M.IsAssociatedFunction.C (Self T E) "transpose" (transpose T E).
    Admitted.
    Global Typeclasses Opaque transpose.
  End Impl_core_option_Option_core_result_Result_T_E.
  
  (*
  const fn unwrap_failed() -> ! {
      panic("called `Option::unwrap()` on a `None` value")
  }
  *)
  Definition unwrap_failed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "never",
          M.get_function (| "core::panicking::panic", [], [] |),
          [ mk_str (| "called `Option::unwrap()` on a `None` value" |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unwrap_failed :
    M.IsFunction.C "core::option::unwrap_failed" unwrap_failed.
  Admitted.
  Global Typeclasses Opaque unwrap_failed.
  
  (*
  const fn expect_failed(msg: &str) -> ! {
      panic_display(&msg)
  }
  *)
  Definition expect_failed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ msg ] =>
      ltac:(M.monadic
        (let msg := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "str" ], msg |) in
        M.call_closure (|
          Ty.path "never",
          M.get_function (|
            "core::panicking::panic_display",
            [],
            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          |),
          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, msg |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_expect_failed :
    M.IsFunction.C "core::option::expect_failed" expect_failed.
  Admitted.
  Global Typeclasses Opaque expect_failed.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn clone(&self) -> Self {
            match self {
                Some(x) => Some(x.clone()),
                None => None,
            }
        }
    *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let x := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ T ]
                    [
                      M.call_closure (|
                        T,
                        M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            match (self, source) {
                (Some(to), Some(from)) => to.clone_from(from),
                (to, from) => *to = from.clone(),
            }
        }
    *)
    Definition clone_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; source ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let source :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              source
            |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| source |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let to := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ2_0 |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let from := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::clone::Clone", T, [], [], "clone_from", [], [] |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| to |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| from |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let to :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                      γ0_0
                    |) in
                  let from :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                      γ0_1
                    |) in
                  M.write (|
                    M.deref (| M.read (| to |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "core::option::Option") [] [ T ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| from |) |) |) ]
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T));
          ("clone_from", InstanceField.Method (clone_from T))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_option_Option_T.
  
  Module Impl_core_default_Default_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn default() -> Option<T> {
            None
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] => ltac:(M.monadic (Value.StructTuple "core::option::Option::None" [] [ T ] []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_core_option_Option_T.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*     type Item = T; *)
    Definition _Item (T : Ty.t) : Ty.t := T.
    
    (*     type IntoIter = IntoIter<T>; *)
    Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ T ].
    
    (*
        fn into_iter(self) -> IntoIter<T> {
            IntoIter { inner: Item { opt: self } }
        }
    *)
    Definition into_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          Value.mkStructRecord
            "core::option::IntoIter"
            []
            [ T ]
            [
              ("inner",
                Value.mkStructRecord "core::option::Item" [] [ T ] [ ("opt", M.read (| self |)) ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item T));
          ("IntoIter", InstanceField.Ty (_IntoIter T));
          ("into_iter", InstanceField.Method (into_iter T))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_core_option_Option_T.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref__core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ].
    
    (*     type Item = &'a T; *)
    Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
    
    (*     type IntoIter = Iter<'a, T>; *)
    Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ T ].
    
    (*
        fn into_iter(self) -> Iter<'a, T> {
            self.iter()
        }
    *)
    Definition into_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Iter") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "iter",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item T));
          ("IntoIter", InstanceField.Ty (_IntoIter T));
          ("into_iter", InstanceField.Method (into_iter T))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref__core_option_Option_T.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ].
    
    (*     type Item = &'a mut T; *)
    Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
    
    (*     type IntoIter = IterMut<'a, T>; *)
    Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ T ].
    
    (*
        fn into_iter(self) -> IterMut<'a, T> {
            self.iter_mut()
        }
    *)
    Definition into_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::IterMut") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "iter_mut",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item T));
          ("IntoIter", InstanceField.Ty (_IntoIter T));
          ("into_iter", InstanceField.Method (into_iter T))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_core_option_Option_T.
  
  Module Impl_core_convert_From_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn from(val: T) -> Option<T> {
            Some(val)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| T, val |) in
          Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| val |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_core_option_Option_T.
  
  Module Impl_core_convert_From_ref__core_option_Option_T_for_core_option_Option_ref__T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
    
    (*
        fn from(o: &'a Option<T>) -> Option<&'a T> {
            o.as_ref()
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ o ] =>
        ltac:(M.monadic
          (let o :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              o
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "as_ref",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| o |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_ref__core_option_Option_T_for_core_option_Option_ref__T.
  
  Module Impl_core_convert_From_ref_mut_core_option_Option_T_for_core_option_Option_ref_mut_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ].
    
    (*
        fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {
            o.as_mut()
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ o ] =>
        ltac:(M.monadic
          (let o :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              o
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "as_mut",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| o |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_ref_mut_core_option_Option_T_for_core_option_Option_ref_mut_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_core_option_Option_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_option_Option_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn eq(&self, other: &Self) -> bool {
            // Spelling out the cases explicitly optimizes better than
            // `_ => false`
            match (self, other) {
                (Some(l), Some(r)) => *l == *r,
                (Some(_), None) => false,
                (None, Some(_)) => false,
                (None, None) => true,
            }
        }
    *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              other
            |) in
          M.match_operator (|
            Ty.path "bool",
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| other |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let l := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let r := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| l |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| r |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.Bool false));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  Value.Bool false));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.Bool true))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_core_option_Option_T_for_core_option_Option_T.
  
  Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_core_option_Option_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
            match (self, other) {
                (Some(l), Some(r)) => l.partial_cmp(r),
                (Some(_), None) => Some(cmp::Ordering::Greater),
                (None, Some(_)) => Some(cmp::Ordering::Less),
                (None, None) => Some(cmp::Ordering::Equal),
            }
        }
    *)
    Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              other
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| other |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let l := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let r := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                    M.get_trait_method (|
                      "core::cmp::PartialOrd",
                      T,
                      [],
                      [ T ],
                      "partial_cmp",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| l |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| r |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "core::cmp::Ordering" ]
                    [ Value.StructTuple "core::cmp::Ordering::Greater" [] [] [] ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "core::cmp::Ordering" ]
                    [ Value.StructTuple "core::cmp::Ordering::Less" [] [] [] ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "core::cmp::Ordering" ]
                    [ Value.StructTuple "core::cmp::Ordering::Equal" [] [] [] ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_core_option_Option_T_for_core_option_Option_T.
  
  Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn cmp(&self, other: &Self) -> cmp::Ordering {
            match (self, other) {
                (Some(l), Some(r)) => l.cmp(r),
                (Some(_), None) => cmp::Ordering::Greater,
                (None, Some(_)) => cmp::Ordering::Less,
                (None, None) => cmp::Ordering::Equal,
            }
        }
    *)
    Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              other
            |) in
          M.match_operator (|
            Ty.path "core::cmp::Ordering",
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                ],
              Value.Tuple [ M.read (| self |); M.read (| other |) ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let l := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  let r := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                  M.call_closure (|
                    Ty.path "core::cmp::Ordering",
                    M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| l |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| r |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_0,
                      "core::option::Option::Some",
                      0
                    |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.StructTuple "core::cmp::Ordering::Greater" [] [] []));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let γ2_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ0_1,
                      "core::option::Option::Some",
                      0
                    |) in
                  Value.StructTuple "core::cmp::Ordering::Less" [] [] []));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let γ0_0 := M.read (| γ0_0 |) in
                  let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                  let γ0_1 := M.read (| γ0_1 |) in
                  let _ := M.is_struct_tuple (| γ0_1, "core::option::Option::None" |) in
                  Value.StructTuple "core::cmp::Ordering::Equal" [] [] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
  End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_core_option_Option_T.
  
  (* StructRecord
    {
      name := "Item";
      const_params := [];
      ty_params := [ "A" ];
      fields := [ ("opt", Ty.apply (Ty.path "core::option::Option") [] [ A ]) ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_A_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    (* Clone *)
    Definition clone (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          Value.mkStructRecord
            "core::option::Item"
            []
            [ A ]
            [
              ("opt",
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::option::Option") [] [ A ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::option::Item",
                            "opt"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("clone", InstanceField.Method (clone A)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_A_for_core_option_Item_A.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    (* Debug *)
    Definition fmt (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Item" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "opt" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "core::option::Option") [] [ A ] ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::option::Option") [] [ A ] ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::option::Item",
                              "opt"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_Item_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    (*     type Item = A; *)
    Definition _Item (A : Ty.t) : Ty.t := A.
    
    (*
        fn next(&mut self) -> Option<A> {
            self.opt.take()
        }
    *)
    Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              "take",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Item",
                  "opt"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            let len = self.len();
            (len, Some(len))
        }
    *)
    Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          M.read (|
            let~ len : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::iter::traits::exact_size::ExactSizeIterator",
                  Ty.apply (Ty.path "core::option::Item") [] [ A ],
                  [],
                  [],
                  "len",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.read (| len |);
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "usize" ]
                    [ M.read (| len |) ]
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item A));
          ("next", InstanceField.Method (next A));
          ("size_hint", InstanceField.Method (size_hint A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_for_core_option_Item_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    (*
        fn next_back(&mut self) -> Option<A> {
            self.opt.take()
        }
    *)
    Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              "take",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Item",
                  "opt"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("next_back", InstanceField.Method (next_back A)) ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_Item_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    (*
        fn len(&self) -> usize {
            self.opt.len()
        }
    *)
    Definition len (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              "len",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Item",
                  "opt"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("len", InstanceField.Method (len A)) ].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_Item_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_for_core_option_Item_A.
  
  Module Impl_core_iter_traits_marker_TrustedLen_for_core_option_Item_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Item") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::TrustedLen"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_TrustedLen_for_core_option_Item_A.
  
  (* StructRecord
    {
      name := "Iter";
      const_params := [];
      ty_params := [ "A" ];
      fields :=
        [ ("inner", Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    (* Debug *)
    Definition fmt (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Iter") [] [ A ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Iter" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Item")
                            []
                            [ Ty.apply (Ty.path "&") [] [ A ] ]
                        ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Item")
                                []
                                [ Ty.apply (Ty.path "&") [] [ A ] ]
                            ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::option::Iter",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_Iter_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    (*     type Item = &'a A; *)
    Definition _Item (A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ A ].
    
    (*
        fn next(&mut self) -> Option<&'a A> {
            self.inner.next()
        }
    *)
    Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Iter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
              [],
              [],
              "next",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Iter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    *)
    Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Iter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.tuple
              [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
              [],
              [],
              "size_hint",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Iter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item A));
          ("next", InstanceField.Method (next A));
          ("size_hint", InstanceField.Method (size_hint A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_for_core_option_Iter_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    (*
        fn next_back(&mut self) -> Option<&'a A> {
            self.inner.next_back()
        }
    *)
    Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::Iter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
              [],
              [],
              "next_back",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::Iter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("next_back", InstanceField.Method (next_back A)) ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_Iter_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_Iter_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_for_core_option_Iter_A.
  
  Module Impl_core_iter_traits_marker_TrustedLen_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::TrustedLen"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_TrustedLen_for_core_option_Iter_A.
  
  Module Impl_core_clone_Clone_for_core_option_Iter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Iter") [] [ A ].
    
    (*
        fn clone(&self) -> Self {
            Iter { inner: self.inner.clone() }
        }
    *)
    Definition clone (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Iter") [] [ A ] ],
              self
            |) in
          Value.mkStructRecord
            "core::option::Iter"
            []
            [ A ]
            [
              ("inner",
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&") [] [ A ] ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::option::Iter",
                        "inner"
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("clone", InstanceField.Method (clone A)) ].
  End Impl_core_clone_Clone_for_core_option_Iter_A.
  
  (* StructRecord
    {
      name := "IterMut";
      const_params := [];
      ty_params := [ "A" ];
      fields :=
        [
          ("inner",
            Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    (* Debug *)
    Definition fmt (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::IterMut") [] [ A ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "IterMut" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Item")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ A ] ]
                        ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Item")
                                []
                                [ Ty.apply (Ty.path "&mut") [] [ A ] ]
                            ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::option::IterMut",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_IterMut_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    (*     type Item = &'a mut A; *)
    Definition _Item (A : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ A ].
    
    (*
        fn next(&mut self) -> Option<&'a mut A> {
            self.inner.next()
        }
    *)
    Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::IterMut") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ],
              [],
              [],
              "next",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IterMut",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    *)
    Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::IterMut") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.tuple
              [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ],
              [],
              [],
              "size_hint",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IterMut",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item A));
          ("next", InstanceField.Method (next A));
          ("size_hint", InstanceField.Method (size_hint A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_for_core_option_IterMut_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    (*
        fn next_back(&mut self) -> Option<&'a mut A> {
            self.inner.next_back()
        }
    *)
    Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::IterMut") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ],
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::option::Item") [] [ Ty.apply (Ty.path "&mut") [] [ A ] ],
              [],
              [],
              "next_back",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IterMut",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("next_back", InstanceField.Method (next_back A)) ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_IterMut_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_IterMut_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_for_core_option_IterMut_A.
  
  Module Impl_core_iter_traits_marker_TrustedLen_for_core_option_IterMut_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IterMut") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::TrustedLen"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_TrustedLen_for_core_option_IterMut_A.
  
  (* StructRecord
    {
      name := "IntoIter";
      const_params := [];
      ty_params := [ "A" ];
      fields := [ ("inner", Ty.apply (Ty.path "core::option::Item") [] [ A ]) ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_A_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    (* Clone *)
    Definition clone (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::IntoIter") [] [ A ] ],
              self
            |) in
          Value.mkStructRecord
            "core::option::IntoIter"
            []
            [ A ]
            [
              ("inner",
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Item") [] [ A ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::option::Item") [] [ A ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::option::IntoIter",
                            "inner"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("clone", InstanceField.Method (clone A)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_A_for_core_option_IntoIter_A.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    (* Debug *)
    Definition fmt (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::IntoIter") [] [ A ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "IntoIter" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::option::Item") [] [ A ] ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::option::IntoIter",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_A_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    (*     type Item = A; *)
    Definition _Item (A : Ty.t) : Ty.t := A.
    
    (*
        fn next(&mut self) -> Option<A> {
            self.inner.next()
        }
    *)
    Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::IntoIter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ A ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ A ],
              [],
              [],
              "next",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IntoIter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    *)
    Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::option::IntoIter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.tuple
              [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::option::Item") [] [ A ],
              [],
              [],
              "size_hint",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IntoIter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item A));
          ("next", InstanceField.Method (next A));
          ("size_hint", InstanceField.Method (size_hint A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    (*
        fn next_back(&mut self) -> Option<A> {
            self.inner.next_back()
        }
    *)
    Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::option::IntoIter") [] [ A ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ A ],
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::option::Item") [] [ A ],
              [],
              [],
              "next_back",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::option::IntoIter",
                  "inner"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [ ("next_back", InstanceField.Method (next_back A)) ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_marker_TrustedLen_for_core_option_IntoIter_A.
    Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::IntoIter") [] [ A ].
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::TrustedLen"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self A)
        (* Instance *) [].
  End Impl_core_iter_traits_marker_TrustedLen_for_core_option_IntoIter_A.
  
  Module Impl_core_iter_traits_collect_FromIterator_where_core_iter_traits_collect_FromIterator_V_A_core_option_Option_A_for_core_option_Option_V.
    Definition Self (A V : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ V ].
    
    (*
        fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {
            // FIXME(#11084): This could be replaced with Iterator::scan when this
            // performance bug is closed.
    
            iter::try_process(iter.into_iter(), |i| i.collect())
        }
    *)
    Definition from_iter (A V : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A V in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| I, iter |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ V ],
            M.get_function (|
              "core::iter::adapters::try_process",
              [],
              [
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  I
                  "IntoIter";
                A;
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "core::convert::Infallible" ];
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::GenericShunt")
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::collect::IntoIterator"
                          []
                          []
                          I
                          "IntoIter";
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::convert::Infallible" ]
                      ]
                  ]
                  V;
                V
              ]
            |),
            [
              M.call_closure (|
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  I
                  "IntoIter",
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  I,
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| iter |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          V,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::GenericShunt")
                              []
                              [
                                Ty.associated_in_trait
                                  "core::iter::traits::collect::IntoIterator"
                                  []
                                  []
                                  I
                                  "IntoIter";
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ]
                              ],
                            α0
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let i :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::GenericShunt")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::collect::IntoIterator"
                                          []
                                          []
                                          I
                                          "IntoIter";
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "core::convert::Infallible" ]
                                      ],
                                    γ
                                  |) in
                                M.call_closure (|
                                  V,
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::GenericShunt")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::collect::IntoIterator"
                                          []
                                          []
                                          I
                                          "IntoIter";
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "core::convert::Infallible" ]
                                      ],
                                    [],
                                    [],
                                    "collect",
                                    [],
                                    [ V ]
                                  |),
                                  [ M.read (| i |) ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A V : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::option::Option") [] [ A ] ]
        (Self A V)
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter A V)) ].
  End Impl_core_iter_traits_collect_FromIterator_where_core_iter_traits_collect_FromIterator_V_A_core_option_Option_A_for_core_option_Option_V.
  
  Module Impl_core_ops_try_trait_Try_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*     type Output = T; *)
    Definition _Output (T : Ty.t) : Ty.t := T.
    
    (*     type Residual = Option<convert::Infallible>; *)
    Definition _Residual (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::convert::Infallible" ].
    
    (*
        fn from_output(output: Self::Output) -> Self {
            Some(output)
        }
    *)
    Definition from_output (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ output ] =>
        ltac:(M.monadic
          (let output :=
            M.alloc (|
              Ty.associated_in_trait
                "core::ops::try_trait::Try"
                []
                []
                (Ty.apply (Ty.path "core::option::Option") [] [ T ])
                "Output",
              output
            |) in
          Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| output |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
            match self {
                Some(v) => ControlFlow::Continue(v),
                None => ControlFlow::Break(None),
            }
        }
    *)
    Definition branch (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], self |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::ops::control_flow::ControlFlow")
              []
              [
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "core::convert::Infallible" ];
                T
              ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let v := M.copy (| T, γ0_0 |) in
                  Value.StructTuple
                    "core::ops::control_flow::ControlFlow::Continue"
                    []
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::convert::Infallible" ];
                      T
                    ]
                    [ M.read (| v |) ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple
                    "core::ops::control_flow::ControlFlow::Break"
                    []
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::convert::Infallible" ];
                      T
                    ]
                    [
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [ Ty.path "core::convert::Infallible" ]
                        []
                    ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::try_trait::Try"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output T));
          ("Residual", InstanceField.Ty (_Residual T));
          ("from_output", InstanceField.Method (from_output T));
          ("branch", InstanceField.Method (branch T))
        ].
  End Impl_core_ops_try_trait_Try_for_core_option_Option_T.
  
  Module Impl_core_ops_try_trait_FromResidual_core_option_Option_core_convert_Infallible_for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn from_residual(residual: Option<convert::Infallible>) -> Self {
            match residual {
                None => None,
            }
        }
    *)
    Definition from_residual (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ residual ] =>
        ltac:(M.monadic
          (let residual :=
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::convert::Infallible" ],
              residual
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            residual,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::try_trait::FromResidual"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::convert::Infallible" ] ]
        (Self T)
        (* Instance *) [ ("from_residual", InstanceField.Method (from_residual T)) ].
  End Impl_core_ops_try_trait_FromResidual_core_option_Option_core_convert_Infallible_for_core_option_Option_T.
  
  Module Impl_core_ops_try_trait_FromResidual_core_ops_try_trait_Yeet_Tuple__for_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    (*
        fn from_residual(ops::Yeet(()): ops::Yeet<()>) -> Self {
            None
        }
    *)
    Definition from_residual (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ β0 ] =>
        ltac:(M.monadic
          (let β0 :=
            M.alloc (| Ty.apply (Ty.path "core::ops::try_trait::Yeet") [] [ Ty.tuple [] ], β0 |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::ops::try_trait::Yeet", 0 |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::try_trait::FromResidual"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "core::ops::try_trait::Yeet") [] [ Ty.tuple [] ] ]
        (Self T)
        (* Instance *) [ ("from_residual", InstanceField.Method (from_residual T)) ].
  End Impl_core_ops_try_trait_FromResidual_core_ops_try_trait_Yeet_Tuple__for_core_option_Option_T.
  
  Module Impl_core_ops_try_trait_Residual_T_for_core_option_Option_core_convert_Infallible.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::convert::Infallible" ].
    
    (*     type TryType = Option<T>; *)
    Definition _TryType (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::try_trait::Residual"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("TryType", InstanceField.Ty (_TryType T)) ].
  End Impl_core_ops_try_trait_Residual_T_for_core_option_Option_core_convert_Infallible.
  
  Module Impl_core_option_Option_core_option_Option_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "core::option::Option")
        []
        [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ].
    
    (*
        pub const fn flatten(self) -> Option<T> {
            // FIXME(const-hack): could be written with `and_then`
            match self {
                Some(inner) => inner,
                None => None,
            }
        }
    *)
    Definition flatten (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let inner :=
                    M.copy (| Ty.apply (Ty.path "core::option::Option") [] [ T ], γ0_0 |) in
                  M.read (| inner |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  Value.StructTuple "core::option::Option::None" [] [ T ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_flatten :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "flatten" (flatten T).
    Admitted.
    Global Typeclasses Opaque flatten.
  End Impl_core_option_Option_core_option_Option_T.
  
  Module Impl_array_N_core_option_Option_T.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "array") [ N ] [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ].
    
    (*
        pub fn transpose(self) -> Option<[T; N]> {
            self.try_map(core::convert::identity)
        }
    *)
    Definition transpose
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "array")
                [ N ]
                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "array")
                [ N ]
                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
              "try_map",
              [],
              [
                Ty.apply (Ty.path "core::option::Option") [] [ T ];
                Ty.function
                  [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ T ])
              ]
            |),
            [
              M.read (| self |);
              M.get_function (|
                "core::convert::identity",
                [],
                [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_transpose :
      forall (N : Value.t) (T : Ty.t),
      M.IsAssociatedFunction.C (Self N T) "transpose" (transpose N T).
    Admitted.
    Global Typeclasses Opaque transpose.
  End Impl_array_N_core_option_Option_T.
End option.
