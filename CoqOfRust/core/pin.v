(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module pin.
  (* StructRecord
    {
      name := "Pin";
      const_params := [];
      ty_params := [ "P" ];
      fields := [ ("pointer", P) ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_P_for_core_pin_Pin_P.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (* Clone *)
    Definition clone (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "core::pin::Pin"
            [
              ("pointer",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", P, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::pin::Pin",
                      "pointer"
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone P)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_P_for_core_pin_Pin_P.
  
  Module Impl_core_cmp_PartialEq_where_core_ops_deref_Deref_P_where_core_ops_deref_Deref_Q_where_core_cmp_PartialEq_associated_type_associated_type_core_pin_Pin_Q_for_core_pin_Pin_P.
    Definition Self (P Q : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn eq(&self, other: &Pin<Q>) -> bool {
            P::Target::eq(self, other)
        }
    *)
    Definition eq (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.associated,
              [ Ty.associated ],
              "eq",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Pin<Q>) -> bool {
            P::Target::ne(self, other)
        }
    *)
    Definition ne (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.associated,
              [ Ty.associated ],
              "ne",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P Q : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self P Q)
        (* Trait polymorphic types *) [ (* Rhs *) Ty.apply (Ty.path "core::pin::Pin") [] [ Q ] ]
        (* Instance *)
        [ ("eq", InstanceField.Method (eq P Q)); ("ne", InstanceField.Method (ne P Q)) ].
  End Impl_core_cmp_PartialEq_where_core_ops_deref_Deref_P_where_core_ops_deref_Deref_Q_where_core_cmp_PartialEq_associated_type_associated_type_core_pin_Pin_Q_for_core_pin_Pin_P.
  
  Module Impl_core_cmp_Eq_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance "core::cmp::Eq" (Self P) (* Trait polymorphic types *) [] (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
  
  Module Impl_core_cmp_PartialOrd_where_core_ops_deref_Deref_P_where_core_ops_deref_Deref_Q_where_core_cmp_PartialOrd_associated_type_associated_type_core_pin_Pin_Q_for_core_pin_Pin_P.
    Definition Self (P Q : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {
            P::Target::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.associated,
              [ Ty.associated ],
              "partial_cmp",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    (*
        fn lt(&self, other: &Pin<Q>) -> bool {
            P::Target::lt(self, other)
        }
    *)
    Definition lt (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.associated,
              [ Ty.associated ],
              "lt",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    (*
        fn le(&self, other: &Pin<Q>) -> bool {
            P::Target::le(self, other)
        }
    *)
    Definition le (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.associated,
              [ Ty.associated ],
              "le",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    (*
        fn gt(&self, other: &Pin<Q>) -> bool {
            P::Target::gt(self, other)
        }
    *)
    Definition gt (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.associated,
              [ Ty.associated ],
              "gt",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    (*
        fn ge(&self, other: &Pin<Q>) -> bool {
            P::Target::ge(self, other)
        }
    *)
    Definition ge (P Q : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P Q in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.associated,
              [ Ty.associated ],
              "ge",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Q ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P Q : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self P Q)
        (* Trait polymorphic types *) [ (* Rhs *) Ty.apply (Ty.path "core::pin::Pin") [] [ Q ] ]
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp P Q));
          ("lt", InstanceField.Method (lt P Q));
          ("le", InstanceField.Method (le P Q));
          ("gt", InstanceField.Method (gt P Q));
          ("ge", InstanceField.Method (ge P Q))
        ].
  End Impl_core_cmp_PartialOrd_where_core_ops_deref_Deref_P_where_core_ops_deref_Deref_Q_where_core_cmp_PartialOrd_associated_type_associated_type_core_pin_Pin_Q_for_core_pin_Pin_P.
  
  Module Impl_core_cmp_Ord_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn cmp(&self, other: &Self) -> cmp::Ordering {
            P::Target::cmp(self, other)
        }
    *)
    Definition cmp (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", Ty.associated, [], "cmp", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp P)) ].
  End Impl_core_cmp_Ord_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
  
  Module Impl_core_hash_Hash_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            P::Target::hash(self, state);
        }
    *)
    Definition hash (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.associated, [], "hash", [ H ] |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash P)) ].
  End Impl_core_hash_Hash_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
  
  Module Impl_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        pub const fn new(pointer: P) -> Pin<P> {
            // SAFETY: the value pointed to is `Unpin`, and so has no requirements
            // around pinning.
            unsafe { Pin::new_unchecked(pointer) }
        }
    *)
    Definition new (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [ host ], [], [ pointer ] =>
        ltac:(M.monadic
          (let pointer := M.alloc (| pointer |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
              "new_unchecked",
              []
            |),
            [ M.read (| pointer |) ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (P : Ty.t), M.IsAssociatedFunction (Self P) "new" (new P).
    
    (*
        pub const fn into_inner(pin: Pin<P>) -> P {
            pin.pointer
        }
    *)
    Definition into_inner (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [ host ], [], [ pin ] =>
        ltac:(M.monadic
          (let pin := M.alloc (| pin |) in
          M.read (| M.SubPointer.get_struct_record_field (| pin, "core::pin::Pin", "pointer" |) |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "into_inner" (into_inner P).
    (*
        pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {
            Pin { pointer }
        }
    *)
    Definition new_unchecked (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [ host ], [], [ pointer ] =>
        ltac:(M.monadic
          (let pointer := M.alloc (| pointer |) in
          Value.StructRecord "core::pin::Pin" [ ("pointer", M.read (| pointer |)) ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_unchecked :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "new_unchecked" (new_unchecked P).
    
    (*
        pub fn as_ref(&self) -> Pin<&P::Target> {
            // SAFETY: see documentation on this function
            unsafe { Pin::new_unchecked(&*self.pointer) }
        }
    *)
    Definition as_ref (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.associated ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::ops::deref::Deref", P, [], "deref", [] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::pin::Pin",
                    "pointer"
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ref :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "as_ref" (as_ref P).
    
    (*
        pub const unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {
            pin.pointer
        }
    *)
    Definition into_inner_unchecked
        (P : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [ host ], [], [ pin ] =>
        ltac:(M.monadic
          (let pin := M.alloc (| pin |) in
          M.read (| M.SubPointer.get_struct_record_field (| pin, "core::pin::Pin", "pointer" |) |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner_unchecked :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "into_inner_unchecked" (into_inner_unchecked P).
    (*
        pub fn as_mut(&mut self) -> Pin<&mut P::Target> {
            // SAFETY: see documentation on this function
            unsafe { Pin::new_unchecked(&mut *self.pointer) }
        }
    *)
    Definition as_mut (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.associated ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::ops::deref::DerefMut", P, [], "deref_mut", [] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::pin::Pin",
                    "pointer"
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_mut :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "as_mut" (as_mut P).
    
    (*
        pub fn set(&mut self, value: P::Target)
        where
            P::Target: Sized,
        {
            *(self.pointer) = value;
        }
    *)
    Definition set (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self; value ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let value := M.alloc (| value |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.call_closure (|
                  M.get_trait_method (| "core::ops::deref::DerefMut", P, [], "deref_mut", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::pin::Pin",
                      "pointer"
                    |)
                  ]
                |),
                M.read (| value |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_set : forall (P : Ty.t), M.IsAssociatedFunction (Self P) "set" (set P).
  End Impl_core_pin_Pin_P.
  
  
  
  Module Impl_core_pin_Pin_ref__T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
    
    (*
        pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>
        where
            U: ?Sized,
            F: FnOnce(&T) -> &U,
        {
            let pointer = &*self.pointer;
            let new_pointer = func(pointer);
    
            // SAFETY: the safety contract for `new_unchecked` must be
            // upheld by the caller.
            unsafe { Pin::new_unchecked(new_pointer) }
        }
    *)
    Definition map_unchecked (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; func ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let func := M.alloc (| func |) in
          M.read (|
            let~ pointer :=
              M.alloc (|
                M.read (|
                  M.SubPointer.get_struct_record_field (| self, "core::pin::Pin", "pointer" |)
                |)
              |) in
            let~ new_pointer :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                    "call_once",
                    []
                  |),
                  [ M.read (| func |); Value.Tuple [ M.read (| pointer |) ] ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ U ] ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| new_pointer |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_map_unchecked :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "map_unchecked" (map_unchecked T).
    
    (*
        pub const fn get_ref(self) -> &'a T {
            self.pointer
        }
    *)
    Definition get_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (| self, "core::pin::Pin", "pointer" |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "get_ref" (get_ref T).
    (*
        pub const fn static_ref(r: &'static T) -> Pin<&'static T> {
            // SAFETY: The 'static borrow guarantees the data will not be
            // moved/invalidated until it gets dropped (which is never).
            unsafe { Pin::new_unchecked(r) }
        }
    *)
    Definition static_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ r ] =>
        ltac:(M.monadic
          (let r := M.alloc (| r |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              "new_unchecked",
              []
            |),
            [ M.read (| r |) ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_static_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "static_ref" (static_ref T).
  End Impl_core_pin_Pin_ref__T.
  
  Module Impl_core_pin_Pin_ref_mut_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ].
    
    (*
        pub const fn into_ref(self) -> Pin<&'a T> {
            Pin { pointer: self.pointer }
        }
    *)
    Definition into_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "core::pin::Pin"
            [
              ("pointer",
                M.read (|
                  M.SubPointer.get_struct_record_field (| self, "core::pin::Pin", "pointer" |)
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "into_ref" (into_ref T).
    
    (*
        pub const fn get_mut(self) -> &'a mut T
        where
            T: Unpin,
        {
            self.pointer
        }
    *)
    Definition get_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (| self, "core::pin::Pin", "pointer" |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "get_mut" (get_mut T).
    
    (*
        pub const unsafe fn get_unchecked_mut(self) -> &'a mut T {
            self.pointer
        }
    *)
    Definition get_unchecked_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (| self, "core::pin::Pin", "pointer" |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_unchecked_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "get_unchecked_mut" (get_unchecked_mut T).
    
    (*
        pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>
        where
            U: ?Sized,
            F: FnOnce(&mut T) -> &mut U,
        {
            // SAFETY: the caller is responsible for not moving the
            // value out of this reference.
            let pointer = unsafe { Pin::get_unchecked_mut(self) };
            let new_pointer = func(pointer);
            // SAFETY: as the value of `this` is guaranteed to not have
            // been moved out, this call to `new_unchecked` is safe.
            unsafe { Pin::new_unchecked(new_pointer) }
        }
    *)
    Definition map_unchecked_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; func ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let func := M.alloc (| func |) in
          M.read (|
            let~ pointer :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                    "get_unchecked_mut",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ new_pointer :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ T ] ] ],
                    "call_once",
                    []
                  |),
                  [ M.read (| func |); Value.Tuple [ M.read (| pointer |) ] ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ U ] ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| new_pointer |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_map_unchecked_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "map_unchecked_mut" (map_unchecked_mut T).
    (*
        pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {
            // SAFETY: The 'static borrow guarantees the data will not be
            // moved/invalidated until it gets dropped (which is never).
            unsafe { Pin::new_unchecked(r) }
        }
    *)
    Definition static_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [ host ], [], [ r ] =>
        ltac:(M.monadic
          (let r := M.alloc (| r |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              "new_unchecked",
              []
            |),
            [ M.read (| r |) ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_static_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "static_mut" (static_mut T).
  End Impl_core_pin_Pin_ref_mut_T.
  
  
  Module Impl_core_pin_Pin_ref_mut_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "core::pin::Pin")
        []
        [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::pin::Pin") [] [ P ] ] ].
    
    (*
        pub fn as_deref_mut(self) -> Pin<&'a mut P::Target> {
            // SAFETY: What we're asserting here is that going from
            //
            //     Pin<&mut Pin<P>>
            //
            // to
            //
            //     Pin<&mut P::Target>
            //
            // is safe.
            //
            // We need to ensure that two things hold for that to be the case:
            //
            // 1) Once we give out a `Pin<&mut P::Target>`, an `&mut P::Target` will not be given out.
            // 2) By giving out a `Pin<&mut P::Target>`, we do not risk of violating `Pin<&mut Pin<P>>`
            //
            // The existence of `Pin<P>` is sufficient to guarantee #1: since we already have a
            // `Pin<P>`, it must already uphold the pinning guarantees, which must mean that
            // `Pin<&mut P::Target>` does as well, since `Pin::as_mut` is safe. We do not have to rely
            // on the fact that P is _also_ pinned.
            //
            // For #2, we need to ensure that code given a `Pin<&mut P::Target>` cannot cause the
            // `Pin<P>` to move? That is not possible, since `Pin<&mut P::Target>` no longer retains
            // any access to the `P` itself, much less the `Pin<P>`.
            unsafe { self.get_unchecked_mut() }.as_mut()
        }
    *)
    Definition as_deref_mut (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
              "as_mut",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::pin::Pin")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::pin::Pin") [] [ P ] ]
                    ],
                  "get_unchecked_mut",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_deref_mut :
      forall (P : Ty.t),
      M.IsAssociatedFunction (Self P) "as_deref_mut" (as_deref_mut P).
  End Impl_core_pin_Pin_ref_mut_core_pin_Pin_P.
  
  
  Module Impl_core_ops_deref_Deref_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*     type Target = P::Target; *)
    Definition _Target (P : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn deref(&self) -> &P::Target {
            Pin::get_ref(Pin::as_ref(self))
        }
    *)
    Definition deref (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.associated ] ],
              "get_ref",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  "as_ref",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target P)); ("deref", InstanceField.Method (deref P)) ].
  End Impl_core_ops_deref_Deref_where_core_ops_deref_Deref_P_for_core_pin_Pin_P.
  
  Module Impl_core_ops_deref_DerefMut_where_core_ops_deref_DerefMut_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn deref_mut(&mut self) -> &mut P::Target {
            Pin::get_mut(Pin::as_mut(self))
        }
    *)
    Definition deref_mut (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.associated ] ],
              "get_mut",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ P ],
                  "as_mut",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut P)) ].
  End Impl_core_ops_deref_DerefMut_where_core_ops_deref_DerefMut_P_for_core_pin_Pin_P.
  
  Module Impl_core_ops_deref_Receiver_where_core_ops_deref_Receiver_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Receiver"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_Receiver_where_core_ops_deref_Receiver_P_for_core_pin_Pin_P.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&self.pointer, f)
        }
    *)
    Definition fmt (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Debug", P, [], "fmt", [] |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::pin::Pin",
                "pointer"
              |);
              M.read (| f |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt P)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_P_for_core_pin_Pin_P.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&self.pointer, f)
        }
    *)
    Definition fmt (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", P, [], "fmt", [] |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::pin::Pin",
                "pointer"
              |);
              M.read (| f |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt P)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_P_for_core_pin_Pin_P.
  
  Module Impl_core_fmt_Pointer_where_core_fmt_Pointer_P_for_core_pin_Pin_P.
    Definition Self (P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Pointer::fmt(&self.pointer, f)
        }
    *)
    Definition fmt (P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self P in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Pointer", P, [], "fmt", [] |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::pin::Pin",
                "pointer"
              |);
              M.read (| f |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (P : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (Self P)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt P)) ].
  End Impl_core_fmt_Pointer_where_core_fmt_Pointer_P_for_core_pin_Pin_P.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_ops_unsize_CoerceUnsized_P_U_core_pin_Pin_U_for_core_pin_Pin_P.
    Definition Self (P U : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    Axiom Implements :
      forall (P U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self P U)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "core::pin::Pin") [] [ U ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_ops_unsize_CoerceUnsized_P_U_core_pin_Pin_U_for_core_pin_Pin_P.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_ops_unsize_DispatchFromDyn_P_U_core_pin_Pin_U_for_core_pin_Pin_P.
    Definition Self (P U : Ty.t) : Ty.t := Ty.apply (Ty.path "core::pin::Pin") [] [ P ].
    
    Axiom Implements :
      forall (P U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self P U)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "core::pin::Pin") [] [ U ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_ops_unsize_DispatchFromDyn_P_U_core_pin_Pin_U_for_core_pin_Pin_P.
End pin.
