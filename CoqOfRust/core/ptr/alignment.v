(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ptr.
  Module alignment.
    (* StructTuple
      {
        name := "Alignment";
        const_params := [];
        ty_params := [];
        fields := [ Ty.path "core::ptr::alignment::AlignmentEnum" ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_clone_Clone_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_cmp_PartialEq_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "core::ptr::alignment::AlignmentEnum",
                [],
                [ Ty.path "core::ptr::alignment::AlignmentEnum" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "core::ptr::alignment::Alignment",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "core::ptr::alignment::Alignment",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_cmp_Eq_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_ptr_alignment_Alignment.
    
    (*
    fn _alignment_can_be_structurally_matched(a: Alignment) -> bool {
        matches!(a, Alignment::MIN)
    }
    *)
    Definition _alignment_can_be_structurally_matched
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ a ] =>
        ltac:(M.monadic
          (let a := M.alloc (| a |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "bool"),
              a,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::ptr::alignment::Alignment",
                        0
                      |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ0_0,
                        "core::ptr::alignment::AlignmentEnum::_Align1Shl0"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction__alignment_can_be_structurally_matched :
      M.IsFunction.Trait
        "core::ptr::alignment::_alignment_can_be_structurally_matched"
        _alignment_can_be_structurally_matched.
    Admitted.
    Global Typeclasses Opaque _alignment_can_be_structurally_matched.
    
    Module Impl_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*     pub const MIN: Self = Self(AlignmentEnum::_Align1Shl0); *)
      (* Ty.path "core::ptr::alignment::Alignment" *)
      Definition value_MIN : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructTuple
                "core::ptr::alignment::Alignment"
                [ Value.StructTuple "core::ptr::alignment::AlignmentEnum::_Align1Shl0" [] ]
            |))).
      
      Global Instance AssociatedConstant_value_MIN :
        M.IsAssociatedConstant.Trait Self "value_MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*
          pub const fn of<T>() -> Self {
              // SAFETY: rustc ensures that type alignment is always a power of two.
              unsafe { Alignment::new_unchecked(mem::align_of::<T>()) }
          }
      *)
      Definition of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::ptr::alignment::Alignment",
              M.get_associated_function (|
                Ty.path "core::ptr::alignment::Alignment",
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::align_of", [], [ T ] |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_of : M.IsAssociatedFunction.Trait Self "of" of.
      Admitted.
      Global Typeclasses Opaque of.
      
      (*
          pub const fn new(align: usize) -> Option<Self> {
              if align.is_power_of_two() {
                  // SAFETY: Just checked it only has one bit set
                  Some(unsafe { Self::new_unchecked(align) })
              } else {
                  None
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "core::ptr::alignment::Alignment" ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.path "usize",
                                "is_power_of_two",
                                [],
                                []
                              |),
                              [ M.read (| align |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              Ty.path "core::ptr::alignment::Alignment",
                              M.get_associated_function (|
                                Ty.path "core::ptr::alignment::Alignment",
                                "new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| align |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.Trait Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub const unsafe fn new_unchecked(align: usize) -> Self {
              assert_unsafe_precondition!(
                  check_language_ub,
                  "Alignment::new_unchecked requires a power of two",
                  (align: usize = align) => align.is_power_of_two()
              );
      
              // SAFETY: By precondition, this must be a power of two, and
              // our variants encompass all possible powers of two.
              unsafe { mem::transmute::<usize, Alignment>(align) }
          }
      *)
      Definition new_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                                []
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Self,
                                "precondition_check.new_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| align |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::ptr::alignment::Alignment",
                  M.get_function (|
                    "core::intrinsics::transmute",
                    [],
                    [ Ty.path "usize"; Ty.path "core::ptr::alignment::Alignment" ]
                  |),
                  [ M.read (| align |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new_unchecked :
        M.IsAssociatedFunction.Trait Self "new_unchecked" new_unchecked.
      Admitted.
      Global Typeclasses Opaque new_unchecked.
      
      (*
          pub const fn as_usize(self) -> usize {
              self.0 as usize
          }
      *)
      Definition as_usize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast
              (Ty.path "usize")
              (M.read (|
                M.SubPointer.get_struct_tuple_field (| self, "core::ptr::alignment::Alignment", 0 |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_usize :
        M.IsAssociatedFunction.Trait Self "as_usize" as_usize.
      Admitted.
      Global Typeclasses Opaque as_usize.
      
      (*
          pub const fn as_nonzero(self) -> NonZero<usize> {
              // SAFETY: All the discriminants are non-zero.
              unsafe { NonZero::new_unchecked(self.as_usize()) }
          }
      *)
      Definition as_nonzero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "core::ptr::alignment::Alignment",
                    "as_usize",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_nonzero :
        M.IsAssociatedFunction.Trait Self "as_nonzero" as_nonzero.
      Admitted.
      Global Typeclasses Opaque as_nonzero.
      
      (*
          pub const fn log2(self) -> u32 {
              self.as_nonzero().trailing_zeros()
          }
      *)
      Definition log2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "trailing_zeros",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.path "core::ptr::alignment::Alignment",
                    "as_nonzero",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_log2 : M.IsAssociatedFunction.Trait Self "log2" log2.
      Admitted.
      Global Typeclasses Opaque log2.
      
      (*
          pub const fn mask(self) -> usize {
              // SAFETY: The alignment is always nonzero, and therefore decrementing won't overflow.
              !(unsafe { self.as_usize().unchecked_sub(1) })
          }
      *)
      Definition mask (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            UnOp.not (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.path "usize", "unchecked_sub", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.path "core::ptr::alignment::Alignment",
                      "as_usize",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  Value.Integer IntegerKind.Usize 1
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_mask : M.IsAssociatedFunction.Trait Self "mask" mask.
      Admitted.
      Global Typeclasses Opaque mask.
      
      (*
          pub(crate) const fn max(a: Self, b: Self) -> Self {
              if a.as_usize() > b.as_usize() { a } else { b }
          }
      *)
      Definition max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ a; b ] =>
          ltac:(M.monadic
            (let a := M.alloc (| a |) in
            let b := M.alloc (| b |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "core::ptr::alignment::Alignment"),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.gt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "core::ptr::alignment::Alignment",
                                  "as_usize",
                                  [],
                                  []
                                |),
                                [ M.read (| a |) ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "core::ptr::alignment::Alignment",
                                  "as_usize",
                                  [],
                                  []
                                |),
                                [ M.read (| b |) ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      a));
                  fun γ => ltac:(M.monadic b)
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_max : M.IsAssociatedFunction.Trait Self "max" max.
      Admitted.
      Global Typeclasses Opaque max.
    End Impl_core_ptr_alignment_Alignment.
    
    Module Impl_core_fmt_Debug_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(f, "{:?} (1 << {:?})", self.as_nonzero(), self.log2())
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.call_closure (|
                  Ty.path "core::fmt::Arguments",
                  M.get_associated_function (|
                    Ty.path "core::fmt::Arguments",
                    "new_v1",
                    [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2 ],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Value.Array
                              [
                                M.read (| Value.String "" |);
                                M.read (| Value.String " (1 << " |);
                                M.read (| Value.String ")" |)
                              ]
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::rt::Argument",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_debug",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::num::nonzero::NonZero")
                                        []
                                        [ Ty.path "usize" ]
                                    ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::num::nonzero::NonZero")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_associated_function (|
                                                Ty.path "core::ptr::alignment::Alignment",
                                                "as_nonzero",
                                                [],
                                                []
                                              |),
                                              [ M.read (| M.deref (| M.read (| self |) |) |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "core::fmt::rt::Argument",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_debug",
                                    [],
                                    [ Ty.path "u32" ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "u32",
                                              M.get_associated_function (|
                                                Ty.path "core::ptr::alignment::Alignment",
                                                "log2",
                                                [],
                                                []
                                              |),
                                              [ M.read (| M.deref (| M.read (| self |) |) |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*     type Error = num::TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
          fn try_from(align: NonZero<usize>) -> Result<Alignment, Self::Error> {
              align.get().try_into()
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "core::ptr::alignment::Alignment";
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_trait_method (|
                "core::convert::TryInto",
                Ty.path "usize",
                [],
                [ Ty.path "core::ptr::alignment::Alignment" ],
                "try_into",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| align |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_convert_TryFrom_usize_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*     type Error = num::TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
          fn try_from(align: usize) -> Result<Alignment, Self::Error> {
              Self::new(align).ok_or(num::TryFromIntError(()))
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "core::ptr::alignment::Alignment";
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "core::ptr::alignment::Alignment" ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "core::ptr::alignment::Alignment" ],
                  M.get_associated_function (|
                    Ty.path "core::ptr::alignment::Alignment",
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| align |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_usize_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_convert_From_core_ptr_alignment_Alignment_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*
          fn from(align: Alignment) -> NonZero<usize> {
              align.as_nonzero()
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
              M.get_associated_function (|
                Ty.path "core::ptr::alignment::Alignment",
                "as_nonzero",
                [],
                []
              |),
              [ M.read (| align |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::ptr::alignment::Alignment" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_ptr_alignment_Alignment_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_From_core_ptr_alignment_Alignment_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
          fn from(align: Alignment) -> usize {
              align.as_usize()
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.path "core::ptr::alignment::Alignment",
                "as_usize",
                [],
                []
              |),
              [ M.read (| align |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::ptr::alignment::Alignment" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_ptr_alignment_Alignment_for_usize.
    
    Module Impl_core_cmp_Ord_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*
          fn cmp(&self, other: &Self) -> cmp::Ordering {
              self.as_nonzero().get().cmp(&other.as_nonzero().get())
          }
      *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], [], "cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          M.get_associated_function (|
                            Ty.path "core::ptr::alignment::Alignment",
                            "as_nonzero",
                            [],
                            []
                          |),
                          [ M.read (| M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                            "get",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::num::nonzero::NonZero")
                                []
                                [ Ty.path "usize" ],
                              M.get_associated_function (|
                                Ty.path "core::ptr::alignment::Alignment",
                                "as_nonzero",
                                [],
                                []
                              |),
                              [ M.read (| M.deref (| M.read (| other |) |) |) ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_cmp_PartialOrd_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "core::ptr::alignment::Alignment",
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_hash_Hash_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*
          fn hash<H: hash::Hasher>(&self, state: &mut H) {
              self.as_nonzero().hash(state)
          }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                [],
                [],
                "hash",
                [],
                [ H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.path "core::ptr::alignment::Alignment",
                        "as_nonzero",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_ptr_alignment_Alignment.
    
    Module Impl_core_default_Default_for_core_ptr_alignment_Alignment.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::Alignment".
      
      (*
          fn default() -> Alignment {
              Alignment::MIN
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (M.read (| M.get_constant "core::ptr::alignment::MIN" |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_ptr_alignment_Alignment.
    
    (*
    Enum AlignmentEnum
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "_Align1Shl0";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl1";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl2";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl3";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl4";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl5";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl6";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl7";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl8";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl9";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl10";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl11";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl12";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl13";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl14";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl15";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl16";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl17";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl18";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl19";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl20";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl21";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl22";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl23";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl24";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl25";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl26";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl27";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl28";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl29";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl30";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl31";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl32";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl33";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl34";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl35";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl36";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl37";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl38";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl39";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl40";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl41";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl42";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl43";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl44";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl45";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl46";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl47";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl48";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl49";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl50";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl51";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl52";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl53";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl54";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl55";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl56";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl57";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl58";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl59";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl60";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl61";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl62";
            item := StructTuple [];
          };
          {
            name := "_Align1Shl63";
            item := StructTuple [];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl0 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl0" 0.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl1 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl1" 1.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl2 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl2" 2.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl3 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl3" 3.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl4 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl4" 4.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl5 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl5" 5.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl6 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl6" 6.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl7 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl7" 7.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl8 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl8" 8.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl9 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl9" 9.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl10 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl10" 10.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl11 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl11" 11.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl12 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl12" 12.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl13 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl13" 13.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl14 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl14" 14.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl15 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl15" 15.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl16 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl16" 16.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl17 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl17" 17.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl18 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl18" 18.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl19 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl19" 19.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl20 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl20" 20.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl21 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl21" 21.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl22 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl22" 22.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl23 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl23" 23.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl24 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl24" 24.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl25 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl25" 25.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl26 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl26" 26.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl27 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl27" 27.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl28 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl28" 28.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl29 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl29" 29.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl30 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl30" 30.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl31 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl31" 31.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl32 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl32" 32.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl33 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl33" 33.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl34 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl34" 34.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl35 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl35" 35.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl36 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl36" 36.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl37 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl37" 37.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl38 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl38" 38.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl39 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl39" 39.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl40 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl40" 40.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl41 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl41" 41.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl42 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl42" 42.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl43 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl43" 43.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl44 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl44" 44.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl45 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl45" 45.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl46 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl46" 46.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl47 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl47" 47.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl48 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl48" 48.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl49 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl49" 49.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl50 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl50" 50.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl51 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl51" 51.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl52 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl52" 52.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl53 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl53" 53.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl54 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl54" 54.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl55 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl55" 55.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl56 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl56" 56.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl57 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl57" 57.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl58 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl58" 58.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl59 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl59" 59.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl60 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl60" 60.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl61 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl61" 61.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl62 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl62" 62.
    Axiom IsDiscriminant_AlignmentEnum__Align1Shl63 :
      M.IsDiscriminant "core::ptr::alignment::AlignmentEnum::_Align1Shl63" 63.
    
    Module Impl_core_marker_Copy_for_core_ptr_alignment_AlignmentEnum.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::AlignmentEnum".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_ptr_alignment_AlignmentEnum.
    
    Module Impl_core_clone_Clone_for_core_ptr_alignment_AlignmentEnum.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::AlignmentEnum".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.deref (| M.read (| self |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_ptr_alignment_AlignmentEnum.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_ptr_alignment_AlignmentEnum.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::AlignmentEnum".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_ptr_alignment_AlignmentEnum.
    
    Module Impl_core_cmp_PartialEq_for_core_ptr_alignment_AlignmentEnum.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::AlignmentEnum".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_discr : Ty.path "u64" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "core::ptr::alignment::AlignmentEnum" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ __arg1_discr : Ty.path "u64" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "core::ptr::alignment::AlignmentEnum" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |) in
              M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_ptr_alignment_AlignmentEnum.
    
    Module Impl_core_cmp_Eq_for_core_ptr_alignment_AlignmentEnum.
      Definition Self : Ty.t := Ty.path "core::ptr::alignment::AlignmentEnum".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_ptr_alignment_AlignmentEnum.
  End alignment.
End ptr.
