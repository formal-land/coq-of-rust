(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ptr.
  Module mut_ptr.
    Module Impl_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          pub const fn is_null(self) -> bool {
              self.cast_const().is_null()
          }
      *)
      Definition is_null (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "is_null",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast_const",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_null :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "is_null" (is_null T).
      Admitted.
      Global Typeclasses Opaque is_null.
      
      (*
          pub const fn cast<U>(self) -> *mut U {
              self as _
          }
      *)
      Definition cast (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ U ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cast :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "cast" (cast T).
      Admitted.
      Global Typeclasses Opaque cast.
      
      (*
          pub const fn with_metadata_of<U>(self, meta: *const U) -> *mut U
          where
              U: ?Sized,
          {
              from_raw_parts_mut::<U>(self as *mut (), metadata(meta))
          }
      *)
      Definition with_metadata_of
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self; meta ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let meta := M.alloc (| Ty.apply (Ty.path "*const") [] [ U ], meta |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ U ],
              M.get_function (|
                "core::ptr::metadata::from_raw_parts_mut",
                [],
                [ U; Ty.tuple [] ]
              |),
              [
                M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| self |));
                M.call_closure (|
                  Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] U "Metadata",
                  M.get_function (| "core::ptr::metadata::metadata", [], [ U ] |),
                  [ M.read (| meta |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_metadata_of :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "with_metadata_of" (with_metadata_of T).
      Admitted.
      Global Typeclasses Opaque with_metadata_of.
      
      (*
          pub const fn cast_const(self) -> *const T {
              self as _
          }
      *)
      Definition cast_const (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.cast
              (Ty.apply (Ty.path "*const") [] [ T ])
              (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cast_const :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "cast_const" (cast_const T).
      Admitted.
      Global Typeclasses Opaque cast_const.
      
      (*
          pub fn addr(self) -> usize {
              // A pointer-to-integer transmute currently has exactly the right semantics: it returns the
              // address without exposing the provenance. Note that this is *not* a stable guarantee about
              // transmute semantics, it relies on sysroot crates having special status.
              // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the
              // provenance).
              unsafe { mem::transmute(self.cast::<()>()) }
          }
      *)
      Definition addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "addr" (addr T).
      Admitted.
      Global Typeclasses Opaque addr.
      
      (*
          pub fn expose_provenance(self) -> usize {
              self.cast::<()>() as usize
          }
      *)
      Definition expose_provenance
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.cast
              (Ty.path "usize")
              (M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  "cast",
                  [],
                  [ Ty.tuple [] ]
                |),
                [ M.read (| self |) ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_expose_provenance :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "expose_provenance" (expose_provenance T).
      Admitted.
      Global Typeclasses Opaque expose_provenance.
      
      (*
          pub fn with_addr(self, addr: usize) -> Self {
              // This should probably be an intrinsic to avoid doing any sort of arithmetic, but
              // meanwhile, we can implement it with `wrapping_offset`, which preserves the pointer's
              // provenance.
              let self_addr = self.addr() as isize;
              let dest_addr = addr as isize;
              let offset = dest_addr.wrapping_sub(self_addr);
              self.wrapping_byte_offset(offset)
          }
      *)
      Definition with_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; addr ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let addr := M.alloc (| Ty.path "usize", addr |) in
            M.read (|
              let~ self_addr : Ty.path "isize" :=
                M.cast
                  (Ty.path "isize")
                  (M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      "addr",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)) in
              let~ dest_addr : Ty.path "isize" := M.cast (Ty.path "isize") (M.read (| addr |)) in
              let~ offset : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "wrapping_sub", [], [] |),
                  [ M.read (| dest_addr |); M.read (| self_addr |) ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "wrapping_byte_offset",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| offset |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "with_addr" (with_addr T).
      Admitted.
      Global Typeclasses Opaque with_addr.
      
      (*
          pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {
              self.with_addr(f(self.addr()))
          }
      *)
      Definition map_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ impl_FnOnce_usize__arrow_usize ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let f := M.alloc (| impl_FnOnce_usize__arrow_usize, f |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "with_addr",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    impl_FnOnce_usize__arrow_usize,
                    [],
                    [ Ty.tuple [ Ty.path "usize" ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "addr",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_map_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "map_addr" (map_addr T).
      Admitted.
      Global Typeclasses Opaque map_addr.
      
      (*
          pub const fn to_raw_parts(self) -> ( *mut (), <T as super::Pointee>::Metadata) {
              (self.cast(), super::metadata(self))
          }
      *)
      Definition to_raw_parts
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            Value.Tuple
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] T "Metadata",
                  M.get_function (| "core::ptr::metadata::metadata", [], [ T ] |),
                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_raw_parts :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "to_raw_parts" (to_raw_parts T).
      Admitted.
      Global Typeclasses Opaque to_raw_parts.
      
      (*
          pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
              // SAFETY: the caller must guarantee that `self` is valid for a
              // reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&*self) } }
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_ref" (as_ref T).
      Admitted.
      Global Typeclasses Opaque as_ref.
      
      (*
          pub const unsafe fn as_ref_unchecked<'a>(self) -> &'a T {
              // SAFETY: the caller must guarantee that `self` is valid for a reference
              unsafe { &*self }
          }
      *)
      Definition as_ref_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_ref_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_ref_unchecked" (as_ref_unchecked T).
      Admitted.
      Global Typeclasses Opaque as_ref_unchecked.
      
      (*
          pub const unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_ref
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ]
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ])
                                      (M.read (| self |))
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_uninit_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_uninit_ref" (as_uninit_ref T).
      Admitted.
      Global Typeclasses Opaque as_uninit_ref.
      
      (*
          pub const unsafe fn offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              #[inline]
              #[rustc_allow_const_fn_unstable(const_eval_select)]
              const fn runtime_offset_nowrap(this: *const (), count: isize, size: usize) -> bool {
                  // We can use const_eval_select here because this is only for UB checks.
                  const_eval_select!(
                      @capture { this: *const (), count: isize, size: usize } -> bool:
                      if const {
                          true
                      } else {
                          // `size` is the size of a Rust type, so we know that
                          // `size <= isize::MAX` and thus `as` cast here is not lossy.
                          let Some(byte_offset) = count.checked_mul(size as isize) else {
                              return false;
                          };
                          let (_, overflow) = this.addr().overflowing_add_signed(byte_offset);
                          !overflow
                      }
                  )
              }
      
              ub_checks::assert_unsafe_precondition!(
                  check_language_ub,
                  "ptr::offset requires the address calculation to not overflow",
                  (
                      this: *const () = self as *const (),
                      count: isize = count,
                      size: usize = size_of::<T>(),
                  ) => runtime_offset_nowrap(this, count, size)
              );
      
              // SAFETY: the caller must uphold the safety contract for `offset`.
              // The obtained pointer is valid for writes since the caller must
              // guarantee that it points to the same allocated object as `self`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "isize", count |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                                  []
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Self,
                                "precondition_check.offset",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                                  (M.read (| self |));
                                M.read (| count |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ T ] |),
                                  []
                                |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::intrinsics::offset",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "isize" ]
                  |),
                  [ M.read (| self |); M.read (| count |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "offset" (offset T).
      Admitted.
      Global Typeclasses Opaque offset.
      
      (*
          pub const unsafe fn byte_offset(self, count: isize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { self.cast::<u8>().offset(count).with_metadata_of(self) }
          }
      *)
      Definition byte_offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "isize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "offset",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "byte_offset" (byte_offset T).
      Admitted.
      Global Typeclasses Opaque byte_offset.
      
      (*
          pub const fn wrapping_offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.
              unsafe { intrinsics::arith_offset(self, count) as *mut T }
          }
      *)
      Definition wrapping_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "isize", count |) in
            M.cast
              (Ty.apply (Ty.path "*mut") [] [ T ])
              (M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ T ],
                M.get_function (| "core::intrinsics::arith_offset", [], [ T ] |),
                [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)); M.read (| count |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_offset" (wrapping_offset T).
      Admitted.
      Global Typeclasses Opaque wrapping_offset.
      
      (*
          pub const fn wrapping_byte_offset(self, count: isize) -> Self {
              self.cast::<u8>().wrapping_offset(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "isize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_offset",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_byte_offset" (wrapping_byte_offset T).
      Admitted.
      Global Typeclasses Opaque wrapping_byte_offset.
      
      (*
          pub fn mask(self, mask: usize) -> *mut T {
              intrinsics::ptr_mask(self.cast::<()>(), mask).cast_mut().with_metadata_of(self)
          }
      *)
      Definition mask (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mask ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let mask := M.alloc (| Ty.path "usize", mask |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                    "cast_mut",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                      M.get_function (| "core::intrinsics::ptr_mask", [], [ Ty.tuple [] ] |),
                      [
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "cast",
                              [],
                              [ Ty.tuple [] ]
                            |),
                            [ M.read (| self |) ]
                          |));
                        M.read (| mask |)
                      ]
                    |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_mask :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "mask" (mask T).
      Admitted.
      Global Typeclasses Opaque mask.
      
      (*
          pub const unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {
              // SAFETY: the caller must guarantee that `self` is be valid for
              // a mutable reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&mut *self) } }
          }
      *)
      Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_mut" (as_mut T).
      Admitted.
      Global Typeclasses Opaque as_mut.
      
      (*
          pub const unsafe fn as_mut_unchecked<'a>(self) -> &'a mut T {
              // SAFETY: the caller must guarantee that `self` is valid for a reference
              unsafe { &mut *self }
          }
      *)
      Definition as_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_mut_unchecked" (as_mut_unchecked T).
      Admitted.
      Global Typeclasses Opaque as_mut_unchecked.
      
      (*
          pub const unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &mut *(self as *mut MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ]
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ])
                                          (M.read (| self |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_uninit_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_uninit_mut" (as_uninit_mut T).
      Admitted.
      Global Typeclasses Opaque as_uninit_mut.
      
      (*
          pub const fn guaranteed_eq(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_eq(other as _)
          }
      *)
      Definition guaranteed_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let other := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_eq",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_guaranteed_eq :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "guaranteed_eq" (guaranteed_eq T).
      Admitted.
      Global Typeclasses Opaque guaranteed_eq.
      
      (*
          pub const fn guaranteed_ne(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_ne(other as _)
          }
      *)
      Definition guaranteed_ne
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let other := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_ne",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_guaranteed_ne :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "guaranteed_ne" (guaranteed_ne T).
      Admitted.
      Global Typeclasses Opaque guaranteed_ne.
      
      (*
          pub const unsafe fn offset_from(self, origin: *const T) -> isize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { (self as *const T).offset_from(origin) }
          }
      *)
      Definition offset_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let origin := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], origin |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "offset_from",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "offset_from" (offset_from T).
      Admitted.
      Global Typeclasses Opaque offset_from.
      
      (*
          pub const unsafe fn byte_offset_from<U: ?Sized>(self, origin: *const U) -> isize {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }
          }
      *)
      Definition byte_offset_from
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let origin := M.alloc (| Ty.apply (Ty.path "*const") [] [ U ], origin |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "offset_from",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ U ],
                    "cast",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| origin |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_byte_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "byte_offset_from" (byte_offset_from T).
      Admitted.
      Global Typeclasses Opaque byte_offset_from.
      
      (*
          pub const unsafe fn sub_ptr(self, origin: *const T) -> usize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `sub_ptr`.
              unsafe { (self as *const T).sub_ptr(origin) }
          }
      *)
      Definition sub_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let origin := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], origin |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "sub_ptr",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_sub_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "sub_ptr" (sub_ptr T).
      Admitted.
      Global Typeclasses Opaque sub_ptr.
      
      (*
          pub const unsafe fn byte_sub_ptr<U: ?Sized>(self, origin: *mut U) -> usize {
              // SAFETY: the caller must uphold the safety contract for `byte_sub_ptr`.
              unsafe { (self as *const T).byte_sub_ptr(origin) }
          }
      *)
      Definition byte_sub_ptr
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let origin := M.alloc (| Ty.apply (Ty.path "*mut") [] [ U ], origin |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "byte_sub_ptr",
                [],
                [ U ]
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                (* MutToConstPointer *) M.pointer_coercion (M.read (| origin |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_byte_sub_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "byte_sub_ptr" (byte_sub_ptr T).
      Admitted.
      Global Typeclasses Opaque byte_sub_ptr.
      
      (*
          pub const unsafe fn add(self, count: usize) -> Self
          where
              T: Sized,
          {
              #[cfg(debug_assertions)]
              #[inline]
              #[rustc_allow_const_fn_unstable(const_eval_select)]
              const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {
                  const_eval_select!(
                      @capture { this: *const (), count: usize, size: usize } -> bool:
                      if const {
                          true
                      } else {
                          let Some(byte_offset) = count.checked_mul(size) else {
                              return false;
                          };
                          let (_, overflow) = this.addr().overflowing_add(byte_offset);
                          byte_offset <= (isize::MAX as usize) && !overflow
                      }
                  )
              }
      
              #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.
              ub_checks::assert_unsafe_precondition!(
                  check_language_ub,
                  "ptr::add requires that the address calculation does not overflow",
                  (
                      this: *const () = self as *const (),
                      count: usize = count,
                      size: usize = size_of::<T>(),
                  ) => runtime_add_nowrap(this, count, size)
              );
      
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                                  []
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Self,
                                "precondition_check.add",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                                  (M.read (| self |));
                                M.read (| count |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ T ] |),
                                  []
                                |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::intrinsics::offset",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize" ]
                  |),
                  [ M.read (| self |); M.read (| count |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "add" (add T).
      Admitted.
      Global Typeclasses Opaque add.
      
      (*
          pub const unsafe fn byte_add(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `add`.
              unsafe { self.cast::<u8>().add(count).with_metadata_of(self) }
          }
      *)
      Definition byte_add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "byte_add" (byte_add T).
      Admitted.
      Global Typeclasses Opaque byte_add.
      
      (*
          pub const unsafe fn sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              #[cfg(debug_assertions)]
              #[inline]
              #[rustc_allow_const_fn_unstable(const_eval_select)]
              const fn runtime_sub_nowrap(this: *const (), count: usize, size: usize) -> bool {
                  const_eval_select!(
                      @capture { this: *const (), count: usize, size: usize } -> bool:
                      if const {
                          true
                      } else {
                          let Some(byte_offset) = count.checked_mul(size) else {
                              return false;
                          };
                          byte_offset <= (isize::MAX as usize) && this.addr() >= byte_offset
                      }
                  )
              }
      
              #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.
              ub_checks::assert_unsafe_precondition!(
                  check_language_ub,
                  "ptr::sub requires that the address calculation does not overflow",
                  (
                      this: *const () = self as *const (),
                      count: usize = count,
                      size: usize = size_of::<T>(),
                  ) => runtime_sub_nowrap(this, count, size)
              );
      
              if T::IS_ZST {
                  // Pointer arithmetic does nothing when the pointee is a ZST.
                  self
              } else {
                  // SAFETY: the caller must uphold the safety contract for `offset`.
                  // Because the pointee is *not* a ZST, that means that `count` is
                  // at most `isize::MAX`, and thus the negation cannot overflow.
                  unsafe { intrinsics::offset(self, intrinsics::unchecked_sub(0, count as isize)) }
              }
          }
      *)
      Definition sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                                  []
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Self,
                                "precondition_check.sub",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                                  (M.read (| self |));
                                M.read (| count |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ T ] |),
                                  []
                                |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (get_constant (|
                            "core::mem::SizedTypeProperties::IS_ZST",
                            Ty.path "bool"
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      self));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_function (|
                            "core::intrinsics::offset",
                            [],
                            [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "isize" ]
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              Ty.path "isize",
                              M.get_function (|
                                "core::intrinsics::unchecked_sub",
                                [],
                                [ Ty.path "isize" ]
                              |),
                              [
                                Value.Integer IntegerKind.Isize 0;
                                M.cast (Ty.path "isize") (M.read (| count |))
                              ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "sub" (sub T).
      Admitted.
      Global Typeclasses Opaque sub.
      
      (*
          pub const unsafe fn byte_sub(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `sub`.
              unsafe { self.cast::<u8>().sub(count).with_metadata_of(self) }
          }
      *)
      Definition byte_sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "sub",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "byte_sub" (byte_sub T).
      Admitted.
      Global Typeclasses Opaque byte_sub.
      
      (*
          pub const fn wrapping_add(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset(count as isize)
          }
      *)
      Definition wrapping_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "isize") (M.read (| count |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_add" (wrapping_add T).
      Admitted.
      Global Typeclasses Opaque wrapping_add.
      
      (*
          pub const fn wrapping_byte_add(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_add(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_byte_add" (wrapping_byte_add T).
      Admitted.
      Global Typeclasses Opaque wrapping_byte_add.
      
      (*
          pub const fn wrapping_sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset((count as isize).wrapping_neg())
          }
      *)
      Definition wrapping_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "wrapping_neg", [], [] |),
                  [ M.cast (Ty.path "isize") (M.read (| count |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_sub" (wrapping_sub T).
      Admitted.
      Global Typeclasses Opaque wrapping_sub.
      
      (*
          pub const fn wrapping_byte_sub(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_sub",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "wrapping_byte_sub" (wrapping_byte_sub T).
      Admitted.
      Global Typeclasses Opaque wrapping_byte_sub.
      
      (*
          pub const unsafe fn read(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for ``.
              unsafe { read(self) }
          }
      *)
      Definition read (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_read :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "read" (read T).
      Admitted.
      Global Typeclasses Opaque read.
      
      (*
          pub unsafe fn read_volatile(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_volatile`.
              unsafe { read_volatile(self) }
          }
      *)
      Definition read_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read_volatile", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_read_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "read_volatile" (read_volatile T).
      Admitted.
      Global Typeclasses Opaque read_volatile.
      
      (*
          pub const unsafe fn read_unaligned(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_unaligned`.
              unsafe { read_unaligned(self) }
          }
      *)
      Definition read_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read_unaligned", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_read_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "read_unaligned" (read_unaligned T).
      Admitted.
      Global Typeclasses Opaque read_unaligned.
      
      (*
          pub const unsafe fn copy_to(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(self, dest, count) }
          }
      *)
      Definition copy_to (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let dest := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], dest |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy", [], [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_copy_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "copy_to" (copy_to T).
      Admitted.
      Global Typeclasses Opaque copy_to.
      
      (*
          pub const unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(self, dest, count) }
          }
      *)
      Definition copy_to_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let dest := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], dest |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_copy_to_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "copy_to_nonoverlapping" (copy_to_nonoverlapping T).
      Admitted.
      Global Typeclasses Opaque copy_to_nonoverlapping.
      
      (*
          pub const unsafe fn copy_from(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(src, self, count) }
          }
      *)
      Definition copy_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], src |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy", [], [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_copy_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "copy_from" (copy_from T).
      Admitted.
      Global Typeclasses Opaque copy_from.
      
      (*
          pub const unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(src, self, count) }
          }
      *)
      Definition copy_from_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], src |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_copy_from_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "copy_from_nonoverlapping" (copy_from_nonoverlapping T).
      Admitted.
      Global Typeclasses Opaque copy_from_nonoverlapping.
      
      (*
          pub unsafe fn drop_in_place(self) {
              // SAFETY: the caller must uphold the safety contract for `drop_in_place`.
              unsafe { drop_in_place(self) }
          }
      *)
      Definition drop_in_place
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_drop_in_place :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "drop_in_place" (drop_in_place T).
      Admitted.
      Global Typeclasses Opaque drop_in_place.
      
      (*
          pub const unsafe fn write(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write`.
              unsafe { write(self, val) }
          }
      *)
      Definition write (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let val := M.alloc (| T, val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_write :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "write" (write T).
      Admitted.
      Global Typeclasses Opaque write.
      
      (*
          pub const unsafe fn write_bytes(self, val: u8, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_bytes`.
              unsafe { write_bytes(self, val, count) }
          }
      *)
      Definition write_bytes (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let val := M.alloc (| Ty.path "u8", val |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::write_bytes", [], [ T ] |),
              [ M.read (| self |); M.read (| val |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_write_bytes :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "write_bytes" (write_bytes T).
      Admitted.
      Global Typeclasses Opaque write_bytes.
      
      (*
          pub unsafe fn write_volatile(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_volatile`.
              unsafe { write_volatile(self, val) }
          }
      *)
      Definition write_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let val := M.alloc (| T, val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write_volatile", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_write_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "write_volatile" (write_volatile T).
      Admitted.
      Global Typeclasses Opaque write_volatile.
      
      (*
          pub const unsafe fn write_unaligned(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_unaligned`.
              unsafe { write_unaligned(self, val) }
          }
      *)
      Definition write_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let val := M.alloc (| T, val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write_unaligned", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_write_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "write_unaligned" (write_unaligned T).
      Admitted.
      Global Typeclasses Opaque write_unaligned.
      
      (*
          pub unsafe fn replace(self, src: T) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `replace`.
              unsafe { replace(self, src) }
          }
      *)
      Definition replace (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let src := M.alloc (| T, src |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::replace", [], [ T ] |),
              [ M.read (| self |); M.read (| src |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_replace :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "replace" (replace T).
      Admitted.
      Global Typeclasses Opaque replace.
      
      (*
          pub const unsafe fn swap(self, with: *mut T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `swap`.
              unsafe { swap(self, with) }
          }
      *)
      Definition swap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; with_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let with_ := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], with_ |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::swap", [], [ T ] |),
              [ M.read (| self |); M.read (| with_ |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "swap" (swap T).
      Admitted.
      Global Typeclasses Opaque swap.
      
      (*
          pub fn align_offset(self, align: usize) -> usize
          where
              T: Sized,
          {
              if !align.is_power_of_two() {
                  panic!("align_offset: align is not a power-of-two");
              }
      
              // SAFETY: `align` has been checked to be a power of 2 above
              let ret = unsafe { align_offset(self, align) };
      
              // Inform Miri that we want to consider the resulting pointer to be suitably aligned.
              #[cfg(miri)]
              if ret != usize::MAX {
                  intrinsics::miri_promise_symbolic_alignment(
                      self.wrapping_add(ret).cast_const().cast(),
                      align,
                  );
              }
      
              ret
          }
      *)
      Definition align_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let align := M.alloc (| Ty.path "usize", align |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "is_power_of_two",
                                      [],
                                      []
                                    |),
                                    [ M.read (| align |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Ty.tuple [],
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_const",
                                      [ Value.Integer IntegerKind.Usize 1 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                              Value.Array
                                                [
                                                  mk_str (|
                                                    "align_offset: align is not a power-of-two"
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ ret : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::ptr::align_offset", [], [ T ] |),
                  [
                    (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                    M.read (| align |)
                  ]
                |) in
              ret
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_align_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "align_offset" (align_offset T).
      Admitted.
      Global Typeclasses Opaque align_offset.
      
      (*
          pub fn is_aligned(self) -> bool
          where
              T: Sized,
          {
              self.is_aligned_to(mem::align_of::<T>())
          }
      *)
      Definition is_aligned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "is_aligned_to",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::align_of", [], [ T ] |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_aligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "is_aligned" (is_aligned T).
      Admitted.
      Global Typeclasses Opaque is_aligned.
      
      (*
          pub fn is_aligned_to(self, align: usize) -> bool {
              if !align.is_power_of_two() {
                  panic!("is_aligned_to: align is not a power-of-two");
              }
      
              self.addr() & (align - 1) == 0
          }
      *)
      Definition is_aligned_to
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], self |) in
            let align := M.alloc (| Ty.path "usize", align |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "is_power_of_two",
                                      [],
                                      []
                                    |),
                                    [ M.read (| align |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Ty.tuple [],
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_const",
                                      [ Value.Integer IntegerKind.Usize 1 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                              Value.Array
                                                [
                                                  mk_str (|
                                                    "is_aligned_to: align is not a power-of-two"
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.path "bool",
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "addr",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| align |); Value.Integer IntegerKind.Usize 1 ]
                        |)
                      ]
                    |);
                    Value.Integer IntegerKind.Usize 0
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_aligned_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "is_aligned_to" (is_aligned_to T).
      Admitted.
      Global Typeclasses Opaque is_aligned_to.
    End Impl_pointer_mut_T.
    
    Module Impl_pointer_mut_slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          pub const fn len(self) -> usize {
              metadata(self)
          }
      *)
      Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::ptr::metadata::metadata",
                [],
                [ Ty.apply (Ty.path "slice") [] [ T ] ]
              |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "len" (len T).
      Admitted.
      Global Typeclasses Opaque len.
      
      (*
          pub const fn is_empty(self) -> bool {
              self.len() == 0
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "len",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                Value.Integer IntegerKind.Usize 0
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "is_empty" (is_empty T).
      Admitted.
      Global Typeclasses Opaque is_empty.
      
      (*
          pub const fn as_mut_array<const N: usize>(self) -> Option<*mut [T; N]> {
              if self.len() == N {
                  let me = self.as_mut_ptr() as *mut [T; N];
                  Some(me)
              } else {
                  None
              }
          }
      *)
      Definition as_mut_array
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ N ], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                N
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ me :
                          Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
                        M.cast
                          (Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ])
                          (M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "as_mut_ptr",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |)) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ]
                          [ M.read (| me |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ]
                          []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_array :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_mut_array" (as_mut_array T).
      Admitted.
      Global Typeclasses Opaque as_mut_array.
      
      (*
          pub unsafe fn split_at_mut(self, mid: usize) -> ( *mut [T], *mut [T]) {
              assert!(mid <= self.len());
              // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct
              // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`
              unsafe { self.split_at_mut_unchecked(mid) }
          }
      *)
      Definition split_at_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            let mid := M.alloc (| Ty.path "usize", mid |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [
                                      M.read (| mid |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Ty.tuple [],
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "assertion failed: mid <= self.len()" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "split_at_mut_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| mid |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_at_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "split_at_mut" (split_at_mut T).
      Admitted.
      Global Typeclasses Opaque split_at_mut.
      
      (*
          pub unsafe fn split_at_mut_unchecked(self, mid: usize) -> ( *mut [T], *mut [T]) {
              let len = self.len();
              let ptr = self.as_mut_ptr();
      
              // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.
              let tail = unsafe { ptr.add(mid) };
              (
                  crate::ptr::slice_from_raw_parts_mut(ptr, mid),
                  crate::ptr::slice_from_raw_parts_mut(tail, len - mid),
              )
          }
      *)
      Definition split_at_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            let mid := M.alloc (| Ty.path "usize", mid |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "len",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |) in
              let~ ptr : Ty.apply (Ty.path "*mut") [] [ T ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "as_mut_ptr",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |) in
              let~ tail : Ty.apply (Ty.path "*mut") [] [ T ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [], [] |),
                  [ M.read (| ptr |); M.read (| mid |) ]
                |) in
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                  ],
                Value.Tuple
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [], [ T ] |),
                      [ M.read (| ptr |); M.read (| mid |) ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [], [ T ] |),
                      [
                        M.read (| tail |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| len |); M.read (| mid |) ]
                        |)
                      ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_at_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "split_at_mut_unchecked" (split_at_mut_unchecked T).
      Admitted.
      Global Typeclasses Opaque split_at_mut_unchecked.
      
      (*
          pub const fn as_mut_ptr(self) -> *mut T {
              self as *mut T
          }
      *)
      Definition as_mut_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_mut_ptr" (as_mut_ptr T).
      Admitted.
      Global Typeclasses Opaque as_mut_ptr.
      
      (*
          pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output
          where
              I: SliceIndex<[T]>,
          {
              // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
              unsafe { index.get_unchecked_mut(self) }
          }
      *)
      Definition get_unchecked_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as I ], [ self; index ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            let index := M.alloc (| I, index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "*mut")
                []
                [
                  Ty.associated_in_trait
                    "core::slice::index::SliceIndex"
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    I
                    "Output"
                ],
              M.get_trait_method (|
                "core::slice::index::SliceIndex",
                I,
                [],
                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                "get_unchecked_mut",
                [],
                []
              |),
              [ M.read (| index |); M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_unchecked_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "get_unchecked_mut" (get_unchecked_mut T).
      Admitted.
      Global Typeclasses Opaque get_unchecked_mut.
      
      (*
          pub const unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.
                  Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ]
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ],
                                  M.get_function (|
                                    "core::slice::raw::from_raw_parts",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  [
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ])
                                      (M.read (| self |));
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_uninit_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_uninit_slice" (as_uninit_slice T).
      Admitted.
      Global Typeclasses Opaque as_uninit_slice.
      
      (*
          pub const unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.
                  Some(unsafe { slice::from_raw_parts_mut(self as *mut MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ]
                          []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ]
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ],
                                      M.get_function (|
                                        "core::slice::raw::from_raw_parts_mut",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ])
                                          (M.read (| self |));
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_uninit_slice_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "as_uninit_slice_mut" (as_uninit_slice_mut T).
      Admitted.
      Global Typeclasses Opaque as_uninit_slice_mut.
    End Impl_pointer_mut_slice_T.
    
    Module Impl_pointer_mut_array_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
      
      (*
          pub const fn as_mut_ptr(self) -> *mut T {
              self as *mut T
          }
      *)
      Definition as_mut_ptr
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                self
              |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_ptr :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction.C (Self N T) "as_mut_ptr" (as_mut_ptr N T).
      Admitted.
      Global Typeclasses Opaque as_mut_ptr.
      
      (*
          pub const fn as_mut_slice(self) -> *mut [T] {
              self
          }
      *)
      Definition as_mut_slice
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                self
              |) in
            (* Unsize *) M.pointer_coercion (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_slice :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction.C (Self N T) "as_mut_slice" (as_mut_slice N T).
      Admitted.
      Global Typeclasses Opaque as_mut_slice.
    End Impl_pointer_mut_array_N_T.
    
    Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_pointer_mut_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn eq(&self, other: &*mut T) -> bool {
              *self == *other
          }
      *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.read (| M.deref (| M.read (| self |) |) |);
                M.read (| M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "*mut") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_pointer_mut_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn cmp(&self, other: &*mut T) -> Ordering {
              if self < other {
                  Less
              } else if self == other {
                  Equal
              } else {
                  Greater
              }
          }
      *)
      Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.read (|
              M.match_operator (|
                Ty.path "core::cmp::Ordering",
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, self |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| other |) |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Ty.path "core::cmp::Ordering",
                        Value.StructTuple "core::cmp::Ordering::Less" [] [] []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "core::cmp::Ordering",
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, self |);
                                        M.borrow (| Pointer.Kind.Ref, other |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Ty.path "core::cmp::Ordering",
                                Value.StructTuple "core::cmp::Ordering::Equal" [] [] []
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Ty.path "core::cmp::Ordering",
                                Value.StructTuple "core::cmp::Ordering::Greater" [] [] []
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
    End Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_pointer_mut_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            Value.StructTuple
              "core::option::Option::Some"
              []
              [ Ty.path "core::cmp::Ordering" ]
              [
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn lt(&self, other: &*mut T) -> bool {
              *self < *other
          }
      *)
      Definition lt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.lt,
              [
                M.read (| M.deref (| M.read (| self |) |) |);
                M.read (| M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn le(&self, other: &*mut T) -> bool {
              *self <= *other
          }
      *)
      Definition le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.le,
              [
                M.read (| M.deref (| M.read (| self |) |) |);
                M.read (| M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn gt(&self, other: &*mut T) -> bool {
              *self > *other
          }
      *)
      Definition gt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.gt,
              [
                M.read (| M.deref (| M.read (| self |) |) |);
                M.read (| M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn ge(&self, other: &*mut T) -> bool {
              *self >= *other
          }
      *)
      Definition ge (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.ge,
              [
                M.read (| M.deref (| M.read (| self |) |) |);
                M.read (| M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "*mut") [] [ T ] ]
          (Self T)
          (* Instance *)
          [
            ("partial_cmp", InstanceField.Method (partial_cmp T));
            ("lt", InstanceField.Method (lt T));
            ("le", InstanceField.Method (le T));
            ("gt", InstanceField.Method (gt T));
            ("ge", InstanceField.Method (ge T))
          ].
    End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_pointer_mut_T_for_pointer_mut_T.
  End mut_ptr.
End ptr.
