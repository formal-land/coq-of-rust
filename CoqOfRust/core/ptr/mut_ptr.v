(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ptr.
  Module mut_ptr.
    Module Impl_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          pub const fn is_null(self) -> bool {
              self.cast_const().is_null()
          }
      *)
      Definition is_null (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "is_null",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast_const",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_null :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_null" (is_null T).
      Smpl Add apply AssociatedFunction_is_null : is_associated.
      
      (*
          pub const fn cast<U>(self) -> *mut U {
              self as _
          }
      *)
      Definition cast (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ U ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_cast :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "cast" (cast T).
      Smpl Add apply AssociatedFunction_cast : is_associated.
      
      (*
          pub const fn with_metadata_of<U>(self, meta: *const U) -> *mut U
          where
              U: ?Sized,
          {
              from_raw_parts_mut::<U>(self as *mut (), metadata(meta))
          }
      *)
      Definition with_metadata_of
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self; meta ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let meta := M.alloc (| meta |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ U ],
              M.get_function (|
                "core::ptr::metadata::from_raw_parts_mut",
                [],
                [ U; Ty.tuple [] ]
              |),
              [
                M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| self |));
                M.call_closure (|
                  Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] U "Metadata",
                  M.get_function (| "core::ptr::metadata::metadata", [], [ U ] |),
                  [ M.read (| meta |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_with_metadata_of :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_metadata_of" (with_metadata_of T).
      Smpl Add apply AssociatedFunction_with_metadata_of : is_associated.
      
      (*
          pub const fn cast_const(self) -> *const T {
              self as _
          }
      *)
      Definition cast_const (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast
              (Ty.apply (Ty.path "*const") [] [ T ])
              (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_cast_const :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "cast_const" (cast_const T).
      Smpl Add apply AssociatedFunction_cast_const : is_associated.
      
      (*
          pub fn addr(self) -> usize {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the
              // provenance).
              unsafe { mem::transmute(self.cast::<()>()) }
          }
      *)
      Definition addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "addr" (addr T).
      Smpl Add apply AssociatedFunction_addr : is_associated.
      
      (*
          pub fn expose_provenance(self) -> usize {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              self.cast::<()>() as usize
          }
      *)
      Definition expose_provenance
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast
              (Ty.path "usize")
              (M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  "cast",
                  [],
                  [ Ty.tuple [] ]
                |),
                [ M.read (| self |) ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_expose_provenance :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "expose_provenance" (expose_provenance T).
      Smpl Add apply AssociatedFunction_expose_provenance : is_associated.
      
      (*
          pub fn with_addr(self, addr: usize) -> Self {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              //
              // In the mean-time, this operation is defined to be "as if" it was
              // a wrapping_offset, so we can emulate it as such. This should properly
              // restore pointer provenance even under today's compiler.
              let self_addr = self.addr() as isize;
              let dest_addr = addr as isize;
              let offset = dest_addr.wrapping_sub(self_addr);
      
              // This is the canonical desugaring of this operation
              self.wrapping_byte_offset(offset)
          }
      *)
      Definition with_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; addr ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let addr := M.alloc (| addr |) in
            M.read (|
              let~ self_addr : Ty.path "isize" :=
                M.alloc (|
                  M.cast
                    (Ty.path "isize")
                    (M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "addr",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |))
                |) in
              let~ dest_addr : Ty.path "isize" :=
                M.alloc (| M.cast (Ty.path "isize") (M.read (| addr |)) |) in
              let~ offset : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_associated_function (| Ty.path "isize", "wrapping_sub", [], [] |),
                    [ M.read (| dest_addr |); M.read (| self_addr |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "wrapping_byte_offset",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| offset |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_with_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_addr" (with_addr T).
      Smpl Add apply AssociatedFunction_with_addr : is_associated.
      
      (*
          pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {
              self.with_addr(f(self.addr()))
          }
      *)
      Definition map_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ impl_FnOnce_usize__arrow_usize ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "with_addr",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    impl_FnOnce_usize__arrow_usize,
                    [],
                    [ Ty.tuple [ Ty.path "usize" ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "addr",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_map_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "map_addr" (map_addr T).
      Smpl Add apply AssociatedFunction_map_addr : is_associated.
      
      (*
          pub const fn to_raw_parts(self) -> ( *mut (), <T as super::Pointee>::Metadata) {
              (self.cast(), super::metadata(self))
          }
      *)
      Definition to_raw_parts
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] T "Metadata",
                  M.get_function (| "core::ptr::metadata::metadata", [], [ T ] |),
                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_to_raw_parts :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "to_raw_parts" (to_raw_parts T).
      Smpl Add apply AssociatedFunction_to_raw_parts : is_associated.
      
      (*
          pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
              // SAFETY: the caller must guarantee that `self` is valid for a
              // reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&*self) } }
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ref" (as_ref T).
      Smpl Add apply AssociatedFunction_as_ref : is_associated.
      
      (*
          pub const unsafe fn as_ref_unchecked<'a>(self) -> &'a T {
              // SAFETY: the caller must guarantee that `self` is valid for a reference
              unsafe { &*self }
          }
      *)
      Definition as_ref_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ref_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ref_unchecked" (as_ref_unchecked T).
      Smpl Add apply AssociatedFunction_as_ref_unchecked : is_associated.
      
      (*
          pub const unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_ref
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ])
                                      (M.read (| self |))
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_uninit_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_ref" (as_uninit_ref T).
      Smpl Add apply AssociatedFunction_as_uninit_ref : is_associated.
      
      (*
          pub const unsafe fn offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              // The obtained pointer is valid for writes since the caller must
              // guarantee that it points to the same allocated object as `self`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_function (|
                "core::intrinsics::offset",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "isize" ]
              |),
              [ M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "offset" (offset T).
      Smpl Add apply AssociatedFunction_offset : is_associated.
      
      (*
          pub const unsafe fn byte_offset(self, count: isize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { self.cast::<u8>().offset(count).with_metadata_of(self) }
          }
      *)
      Definition byte_offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "offset",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_offset" (byte_offset T).
      Smpl Add apply AssociatedFunction_byte_offset : is_associated.
      
      (*
          pub const fn wrapping_offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.
              unsafe { intrinsics::arith_offset(self, count) as *mut T }
          }
      *)
      Definition wrapping_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.cast
              (Ty.apply (Ty.path "*mut") [] [ T ])
              (M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ T ],
                M.get_function (| "core::intrinsics::arith_offset", [], [ T ] |),
                [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)); M.read (| count |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_offset" (wrapping_offset T).
      Smpl Add apply AssociatedFunction_wrapping_offset : is_associated.
      
      (*
          pub const fn wrapping_byte_offset(self, count: isize) -> Self {
              self.cast::<u8>().wrapping_offset(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_offset",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_offset" (wrapping_byte_offset T).
      Smpl Add apply AssociatedFunction_wrapping_byte_offset : is_associated.
      
      (*
          pub fn mask(self, mask: usize) -> *mut T {
              intrinsics::ptr_mask(self.cast::<()>(), mask).cast_mut().with_metadata_of(self)
          }
      *)
      Definition mask (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mask ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mask := M.alloc (| mask |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                    "cast_mut",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                      M.get_function (| "core::intrinsics::ptr_mask", [], [ Ty.tuple [] ] |),
                      [
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "cast",
                              [],
                              [ Ty.tuple [] ]
                            |),
                            [ M.read (| self |) ]
                          |));
                        M.read (| mask |)
                      ]
                    |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_mask :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "mask" (mask T).
      Smpl Add apply AssociatedFunction_mask : is_associated.
      
      (*
          pub const unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {
              // SAFETY: the caller must guarantee that `self` is be valid for
              // a mutable reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&mut *self) } }
          }
      *)
      Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut" (as_mut T).
      Smpl Add apply AssociatedFunction_as_mut : is_associated.
      
      (*
          pub const unsafe fn as_mut_unchecked<'a>(self) -> &'a mut T {
              // SAFETY: the caller must guarantee that `self` is valid for a reference
              unsafe { &mut *self }
          }
      *)
      Definition as_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut_unchecked" (as_mut_unchecked T).
      Smpl Add apply AssociatedFunction_as_mut_unchecked : is_associated.
      
      (*
          pub const unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &mut *(self as *mut MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ])
                                          (M.read (| self |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_uninit_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_mut" (as_uninit_mut T).
      Smpl Add apply AssociatedFunction_as_uninit_mut : is_associated.
      
      (*
          pub const fn guaranteed_eq(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_eq(other as _)
          }
      *)
      Definition guaranteed_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_eq",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_guaranteed_eq :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "guaranteed_eq" (guaranteed_eq T).
      Smpl Add apply AssociatedFunction_guaranteed_eq : is_associated.
      
      (*
          pub const fn guaranteed_ne(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_ne(other as _)
          }
      *)
      Definition guaranteed_ne
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_ne",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_guaranteed_ne :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "guaranteed_ne" (guaranteed_ne T).
      Smpl Add apply AssociatedFunction_guaranteed_ne : is_associated.
      
      (*
          pub const unsafe fn offset_from(self, origin: *const T) -> isize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { (self as *const T).offset_from(origin) }
          }
      *)
      Definition offset_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "offset_from",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "offset_from" (offset_from T).
      Smpl Add apply AssociatedFunction_offset_from : is_associated.
      
      (*
          pub const unsafe fn byte_offset_from<U: ?Sized>(self, origin: *const U) -> isize {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }
          }
      *)
      Definition byte_offset_from
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U ], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "offset_from",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ U ],
                    "cast",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| origin |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_byte_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_offset_from" (byte_offset_from T).
      Smpl Add apply AssociatedFunction_byte_offset_from : is_associated.
      
      (*
          pub const unsafe fn sub_ptr(self, origin: *const T) -> usize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `sub_ptr`.
              unsafe { (self as *const T).sub_ptr(origin) }
          }
      *)
      Definition sub_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "sub_ptr",
                [],
                []
              |),
              [
                M.cast
                  (Ty.apply (Ty.path "*const") [] [ T ])
                  (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_sub_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "sub_ptr" (sub_ptr T).
      Smpl Add apply AssociatedFunction_sub_ptr : is_associated.
      
      (*
          pub const unsafe fn add(self, count: usize) -> Self
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_function (|
                "core::intrinsics::offset",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize" ]
              |),
              [ M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "add" (add T).
      Smpl Add apply AssociatedFunction_add : is_associated.
      
      (*
          pub const unsafe fn byte_add(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `add`.
              unsafe { self.cast::<u8>().add(count).with_metadata_of(self) }
          }
      *)
      Definition byte_add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_add" (byte_add T).
      Smpl Add apply AssociatedFunction_byte_add : is_associated.
      
      (*
          pub const unsafe fn sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              if T::IS_ZST {
                  // Pointer arithmetic does nothing when the pointee is a ZST.
                  self
              } else {
                  // SAFETY: the caller must uphold the safety contract for `offset`.
                  // Because the pointee is *not* a ZST, that means that `count` is
                  // at most `isize::MAX`, and thus the negation cannot overflow.
                  unsafe { self.offset((count as isize).unchecked_neg()) }
              }
          }
      *)
      Definition sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.get_constant "core::mem::SizedTypeProperties::IS_ZST") in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      self));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "offset",
                            [],
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "unchecked_neg",
                                [],
                                []
                              |),
                              [ M.cast (Ty.path "isize") (M.read (| count |)) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "sub" (sub T).
      Smpl Add apply AssociatedFunction_sub : is_associated.
      
      (*
          pub const unsafe fn byte_sub(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `sub`.
              unsafe { self.cast::<u8>().sub(count).with_metadata_of(self) }
          }
      *)
      Definition byte_sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "sub",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_sub" (byte_sub T).
      Smpl Add apply AssociatedFunction_byte_sub : is_associated.
      
      (*
          pub const fn wrapping_add(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset(count as isize)
          }
      *)
      Definition wrapping_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "isize") (M.read (| count |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_add" (wrapping_add T).
      Smpl Add apply AssociatedFunction_wrapping_add : is_associated.
      
      (*
          pub const fn wrapping_byte_add(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_add(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_add" (wrapping_byte_add T).
      Smpl Add apply AssociatedFunction_wrapping_byte_add : is_associated.
      
      (*
          pub const fn wrapping_sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset((count as isize).wrapping_neg())
          }
      *)
      Definition wrapping_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "wrapping_neg", [], [] |),
                  [ M.cast (Ty.path "isize") (M.read (| count |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_sub" (wrapping_sub T).
      Smpl Add apply AssociatedFunction_wrapping_sub : is_associated.
      
      (*
          pub const fn wrapping_byte_sub(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [],
                [ T ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_sub",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_wrapping_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_sub" (wrapping_byte_sub T).
      Smpl Add apply AssociatedFunction_wrapping_byte_sub : is_associated.
      
      (*
          pub const unsafe fn read(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for ``.
              unsafe { read(self) }
          }
      *)
      Definition read (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_read :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read" (read T).
      Smpl Add apply AssociatedFunction_read : is_associated.
      
      (*
          pub unsafe fn read_volatile(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_volatile`.
              unsafe { read_volatile(self) }
          }
      *)
      Definition read_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read_volatile", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_read_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read_volatile" (read_volatile T).
      Smpl Add apply AssociatedFunction_read_volatile : is_associated.
      
      (*
          pub const unsafe fn read_unaligned(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_unaligned`.
              unsafe { read_unaligned(self) }
          }
      *)
      Definition read_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::read_unaligned", [], [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_read_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read_unaligned" (read_unaligned T).
      Smpl Add apply AssociatedFunction_read_unaligned : is_associated.
      
      (*
          pub const unsafe fn copy_to(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(self, dest, count) }
          }
      *)
      Definition copy_to (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dest := M.alloc (| dest |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy", [], [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_copy_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_to" (copy_to T).
      Smpl Add apply AssociatedFunction_copy_to : is_associated.
      
      (*
          pub const unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(self, dest, count) }
          }
      *)
      Definition copy_to_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dest := M.alloc (| dest |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_copy_to_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_to_nonoverlapping" (copy_to_nonoverlapping T).
      Smpl Add apply AssociatedFunction_copy_to_nonoverlapping : is_associated.
      
      (*
          pub const unsafe fn copy_from(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(src, self, count) }
          }
      *)
      Definition copy_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy", [], [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_copy_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_from" (copy_from T).
      Smpl Add apply AssociatedFunction_copy_from : is_associated.
      
      (*
          pub const unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(src, self, count) }
          }
      *)
      Definition copy_from_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_copy_from_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_from_nonoverlapping" (copy_from_nonoverlapping T).
      Smpl Add apply AssociatedFunction_copy_from_nonoverlapping : is_associated.
      
      (*
          pub unsafe fn drop_in_place(self) {
              // SAFETY: the caller must uphold the safety contract for `drop_in_place`.
              unsafe { drop_in_place(self) }
          }
      *)
      Definition drop_in_place
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_drop_in_place :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "drop_in_place" (drop_in_place T).
      Smpl Add apply AssociatedFunction_drop_in_place : is_associated.
      
      (*
          pub const unsafe fn write(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write`.
              unsafe { write(self, val) }
          }
      *)
      Definition write (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_write :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write" (write T).
      Smpl Add apply AssociatedFunction_write : is_associated.
      
      (*
          pub const unsafe fn write_bytes(self, val: u8, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_bytes`.
              unsafe { write_bytes(self, val, count) }
          }
      *)
      Definition write_bytes (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::write_bytes", [], [ T ] |),
              [ M.read (| self |); M.read (| val |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_write_bytes :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_bytes" (write_bytes T).
      Smpl Add apply AssociatedFunction_write_bytes : is_associated.
      
      (*
          pub unsafe fn write_volatile(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_volatile`.
              unsafe { write_volatile(self, val) }
          }
      *)
      Definition write_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write_volatile", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_write_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_volatile" (write_volatile T).
      Smpl Add apply AssociatedFunction_write_volatile : is_associated.
      
      (*
          pub const unsafe fn write_unaligned(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_unaligned`.
              unsafe { write_unaligned(self, val) }
          }
      *)
      Definition write_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::write_unaligned", [], [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_write_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_unaligned" (write_unaligned T).
      Smpl Add apply AssociatedFunction_write_unaligned : is_associated.
      
      (*
          pub unsafe fn replace(self, src: T) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `replace`.
              unsafe { replace(self, src) }
          }
      *)
      Definition replace (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.call_closure (|
              T,
              M.get_function (| "core::ptr::replace", [], [ T ] |),
              [ M.read (| self |); M.read (| src |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_replace :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "replace" (replace T).
      Smpl Add apply AssociatedFunction_replace : is_associated.
      
      (*
          pub const unsafe fn swap(self, with: *mut T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `swap`.
              unsafe { swap(self, with) }
          }
      *)
      Definition swap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; with_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let with_ := M.alloc (| with_ |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::ptr::swap", [], [ T ] |),
              [ M.read (| self |); M.read (| with_ |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "swap" (swap T).
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
          pub const fn align_offset(self, align: usize) -> usize
          where
              T: Sized,
          {
              if !align.is_power_of_two() {
                  panic!("align_offset: align is not a power-of-two");
              }
      
              // SAFETY: `align` has been checked to be a power of 2 above
              let ret = unsafe { align_offset(self, align) };
      
              // Inform Miri that we want to consider the resulting pointer to be suitably aligned.
              #[cfg(miri)]
              if ret != usize::MAX {
                  intrinsics::miri_promise_symbolic_alignment(
                      self.wrapping_add(ret).cast_const().cast(),
                      align,
                  );
              }
      
              ret
          }
      *)
      Definition align_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "is_power_of_two",
                                    [],
                                    []
                                  |),
                                  [ M.read (| align |) ]
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.read (|
                                                  Value.String
                                                    "align_offset: align is not a power-of-two"
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ ret : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "core::ptr::align_offset", [], [ T ] |),
                    [
                      (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                      M.read (| align |)
                    ]
                  |)
                |) in
              ret
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_align_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "align_offset" (align_offset T).
      Smpl Add apply AssociatedFunction_align_offset : is_associated.
      
      (*
          pub const fn is_aligned(self) -> bool
          where
              T: Sized,
          {
              self.is_aligned_to(mem::align_of::<T>())
          }
      *)
      Definition is_aligned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "is_aligned_to",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::align_of", [], [ T ] |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_aligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_aligned" (is_aligned T).
      Smpl Add apply AssociatedFunction_is_aligned : is_associated.
      
      (*
          pub const fn is_aligned_to(self, align: usize) -> bool {
              if !align.is_power_of_two() {
                  panic!("is_aligned_to: align is not a power-of-two");
              }
      
              #[inline]
              fn runtime_impl(ptr: *mut (), align: usize) -> bool {
                  ptr.addr() & (align - 1) == 0
              }
      
              #[inline]
              const fn const_impl(ptr: *mut (), align: usize) -> bool {
                  // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.
                  ptr.align_offset(align) == 0
              }
      
              // The cast to `()` is used to
              //   1. deal with fat pointers; and
              //   2. ensure that `align_offset` (in `const_impl`) doesn't actually try to compute an offset.
              const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl)
          }
      *)
      Definition is_aligned_to
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "is_power_of_two",
                                    [],
                                    []
                                  |),
                                  [ M.read (| align |) ]
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.read (|
                                                  Value.String
                                                    "is_aligned_to: align is not a power-of-two"
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_function (|
                    "core::intrinsics::const_eval_select",
                    [],
                    [
                      Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ];
                      Ty.function
                        [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
                        (Ty.path "bool");
                      Ty.function
                        [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
                        (Ty.path "bool");
                      Ty.path "bool"
                    ]
                  |),
                  [
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "cast",
                            [],
                            [ Ty.tuple [] ]
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.read (| align |)
                      ];
                    M.get_associated_function (| Self, "const_impl.is_aligned_to", [], [] |);
                    M.get_associated_function (| Self, "runtime_impl.is_aligned_to", [], [] |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_aligned_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_aligned_to" (is_aligned_to T).
      Smpl Add apply AssociatedFunction_is_aligned_to : is_associated.
    End Impl_pointer_mut_T.
    
    Module Impl_pointer_mut_slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          pub const fn len(self) -> usize {
              metadata(self)
          }
      *)
      Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::ptr::metadata::metadata",
                [],
                [ Ty.apply (Ty.path "slice") [] [ T ] ]
              |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_len :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "len" (len T).
      Smpl Add apply AssociatedFunction_len : is_associated.
      
      (*
          pub const fn is_empty(self) -> bool {
              self.len() == 0
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.eq (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  "len",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |),
              Value.Integer IntegerKind.Usize 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_empty" (is_empty T).
      Smpl Add apply AssociatedFunction_is_empty : is_associated.
      
      (*
          pub unsafe fn split_at_mut(self, mid: usize) -> ( *mut [T], *mut [T]) {
              assert!(mid <= self.len());
              // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct
              // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`
              unsafe { self.split_at_mut_unchecked(mid) }
          }
      *)
      Definition split_at_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mid := M.alloc (| mid |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                BinOp.le (|
                                  M.read (| mid |),
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [ M.read (| Value.String "assertion failed: mid <= self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "split_at_mut_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| mid |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_split_at_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "split_at_mut" (split_at_mut T).
      Smpl Add apply AssociatedFunction_split_at_mut : is_associated.
      
      (*
          pub unsafe fn split_at_mut_unchecked(self, mid: usize) -> ( *mut [T], *mut [T]) {
              let len = self.len();
              let ptr = self.as_mut_ptr();
      
              // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.
              let tail = unsafe { ptr.add(mid) };
              (
                  crate::ptr::slice_from_raw_parts_mut(ptr, mid),
                  crate::ptr::slice_from_raw_parts_mut(tail, len - mid),
              )
          }
      *)
      Definition split_at_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mid := M.alloc (| mid |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "len",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*mut") [] [ T ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "as_mut_ptr",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ tail : Ty.apply (Ty.path "*mut") [] [ T ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      "add",
                      [],
                      []
                    |),
                    [ M.read (| ptr |); M.read (| mid |) ]
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [], [ T ] |),
                      [ M.read (| ptr |); M.read (| mid |) ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [], [ T ] |),
                      [ M.read (| tail |); BinOp.Wrap.sub (| M.read (| len |), M.read (| mid |) |) ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_split_at_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "split_at_mut_unchecked" (split_at_mut_unchecked T).
      Smpl Add apply AssociatedFunction_split_at_mut_unchecked : is_associated.
      
      (*
          pub const fn as_mut_ptr(self) -> *mut T {
              self as *mut T
          }
      *)
      Definition as_mut_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut_ptr" (as_mut_ptr T).
      Smpl Add apply AssociatedFunction_as_mut_ptr : is_associated.
      
      (*
          pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output
          where
              I: SliceIndex<[T]>,
          {
              // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
              unsafe { index.get_unchecked_mut(self) }
          }
      *)
      Definition get_unchecked_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as I ], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "*mut")
                []
                [ Ty.associated_in_trait "core::slice::index::SliceIndex" [] [] I "Output" ],
              M.get_trait_method (|
                "core::slice::index::SliceIndex",
                I,
                [],
                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                "get_unchecked_mut",
                [],
                []
              |),
              [ M.read (| index |); M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_unchecked_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_unchecked_mut" (get_unchecked_mut T).
      Smpl Add apply AssociatedFunction_get_unchecked_mut : is_associated.
      
      (*
          pub const unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.
                  Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ],
                                  M.get_function (|
                                    "core::slice::raw::from_raw_parts",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  [
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ])
                                      (M.read (| self |));
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_uninit_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_slice" (as_uninit_slice T).
      Smpl Add apply AssociatedFunction_as_uninit_slice : is_associated.
      
      (*
          pub const unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.
                  Some(unsafe { slice::from_raw_parts_mut(self as *mut MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ],
                                      M.get_function (|
                                        "core::slice::raw::from_raw_parts_mut",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ])
                                          (M.read (| self |));
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_uninit_slice_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_slice_mut" (as_uninit_slice_mut T).
      Smpl Add apply AssociatedFunction_as_uninit_slice_mut : is_associated.
    End Impl_pointer_mut_slice_T.
    
    Module Impl_pointer_mut_array_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
      
      (*
          pub const fn as_mut_ptr(self) -> *mut T {
              self as *mut T
          }
      *)
      Definition as_mut_ptr
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| self |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut_ptr :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "as_mut_ptr" (as_mut_ptr N T).
      Smpl Add apply AssociatedFunction_as_mut_ptr : is_associated.
      
      (*
          pub const fn as_mut_slice(self) -> *mut [T] {
              self
          }
      *)
      Definition as_mut_slice
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| self |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut_slice :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "as_mut_slice" (as_mut_slice N T).
      Smpl Add apply AssociatedFunction_as_mut_slice : is_associated.
    End Impl_pointer_mut_array_N_T.
    
    Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn eq(&self, other: &*mut T) -> bool {
              *self == *other
          }
      *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.eq (|
              M.read (| M.deref (| M.read (| self |) |) |),
              M.read (| M.deref (| M.read (| other |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn cmp(&self, other: &*mut T) -> Ordering {
              if self < other {
                  Less
              } else if self == other {
                  Equal
              } else {
                  Greater
              }
          }
      *)
      Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, self |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| other |) |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::cmp::Ordering::Less" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, self |);
                                        M.borrow (| Pointer.Kind.Ref, other |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::cmp::Ordering::Greater" [] |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
    End Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn lt(&self, other: &*mut T) -> bool {
              *self < *other
          }
      *)
      Definition lt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.lt (|
              M.read (| M.deref (| M.read (| self |) |) |),
              M.read (| M.deref (| M.read (| other |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn le(&self, other: &*mut T) -> bool {
              *self <= *other
          }
      *)
      Definition le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.le (|
              M.read (| M.deref (| M.read (| self |) |) |),
              M.read (| M.deref (| M.read (| other |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn gt(&self, other: &*mut T) -> bool {
              *self > *other
          }
      *)
      Definition gt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.gt (|
              M.read (| M.deref (| M.read (| self |) |) |),
              M.read (| M.deref (| M.read (| other |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn ge(&self, other: &*mut T) -> bool {
              *self >= *other
          }
      *)
      Definition ge (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.ge (|
              M.read (| M.deref (| M.read (| self |) |) |),
              M.read (| M.deref (| M.read (| other |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("partial_cmp", InstanceField.Method (partial_cmp T));
            ("lt", InstanceField.Method (lt T));
            ("le", InstanceField.Method (le T));
            ("gt", InstanceField.Method (gt T));
            ("ge", InstanceField.Method (ge T))
          ].
    End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_for_pointer_mut_T.
  End mut_ptr.
End ptr.
