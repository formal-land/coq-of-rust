(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module ptr.
  Module mut_ptr.
    Module Impl_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          pub const fn is_null(self) -> bool {
              #[inline]
              fn runtime_impl(ptr: *mut u8) -> bool {
                  ptr.addr() == 0
              }
      
              #[inline]
              const fn const_impl(ptr: *mut u8) -> bool {
                  // Compare via a cast to a thin pointer, so fat pointers are only
                  // considering their "data" part for null-ness.
                  match (ptr).guaranteed_eq(null_mut()) {
                      None => false,
                      Some(res) => res,
                  }
              }
      
              // SAFETY: The two versions are equivalent at runtime.
              unsafe { const_eval_select((self as *mut u8,), const_impl, runtime_impl) }
          }
      *)
      Definition is_null (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::const_eval_select",
                [
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ];
                  Ty.function [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] (Ty.path "bool");
                  Ty.function [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] (Ty.path "bool");
                  Ty.path "bool"
                ]
              |),
              [
                Value.Tuple [ M.rust_cast (M.read (| self |)) ];
                M.get_associated_function (| Self, "const_impl.is_null", [] |);
                M.get_associated_function (| Self, "runtime_impl.is_null", [] |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_null :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_null" (is_null T).
      
      (*
          pub const fn cast<U>(self) -> *mut U {
              self as _
          }
      *)
      Definition cast (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [ U ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| self |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_cast :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "cast" (cast T).
      
      (*
          pub const fn with_metadata_of<U>(self, meta: *const U) -> *mut U
          where
              U: ?Sized,
          {
              from_raw_parts_mut::<U>(self as *mut (), metadata(meta))
          }
      *)
      Definition with_metadata_of
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [ U ], [ self; meta ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let meta := M.alloc (| meta |) in
            M.call_closure (|
              M.get_function (| "core::ptr::metadata::from_raw_parts_mut", [ U ] |),
              [
                M.rust_cast (M.read (| self |));
                M.call_closure (|
                  M.get_function (| "core::ptr::metadata::metadata", [ U ] |),
                  [ M.read (| meta |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_metadata_of :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_metadata_of" (with_metadata_of T).
      
      (*
          pub const fn cast_const(self) -> *const T {
              self as _
          }
      *)
      Definition cast_const (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_cast_const :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "cast_const" (cast_const T).
      
      (*
          pub fn to_bits(self) -> usize
          where
              T: Sized,
          {
              self as usize
          }
      *)
      Definition to_bits (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| self |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_bits :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "to_bits" (to_bits T).
      
      (*
          pub fn from_bits(bits: usize) -> Self
          where
              T: Sized,
          {
              bits as Self
          }
      *)
      Definition from_bits (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ bits ] =>
          ltac:(M.monadic
            (let bits := M.alloc (| bits |) in
            M.rust_cast (M.read (| bits |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_bits :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_bits" (from_bits T).
      
      (*
          pub fn addr(self) -> usize {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the
              // provenance).
              unsafe { mem::transmute(self.cast::<()>()) }
          }
      *)
      Definition addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute",
                [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "addr" (addr T).
      
      (*
          pub fn expose_addr(self) -> usize {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              self.cast::<()>() as usize
          }
      *)
      Definition expose_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  "cast",
                  [ Ty.tuple [] ]
                |),
                [ M.read (| self |) ]
              |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_expose_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "expose_addr" (expose_addr T).
      
      (*
          pub fn with_addr(self, addr: usize) -> Self {
              // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
              //
              // In the mean-time, this operation is defined to be "as if" it was
              // a wrapping_offset, so we can emulate it as such. This should properly
              // restore pointer provenance even under today's compiler.
              let self_addr = self.addr() as isize;
              let dest_addr = addr as isize;
              let offset = dest_addr.wrapping_sub(self_addr);
      
              // This is the canonical desugaring of this operation
              self.wrapping_byte_offset(offset)
          }
      *)
      Definition with_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; addr ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let addr := M.alloc (| addr |) in
            M.read (|
              let~ self_addr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "addr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |))
                |) in
              let~ dest_addr := M.alloc (| M.rust_cast (M.read (| addr |)) |) in
              let~ offset :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                    [ M.read (| dest_addr |); M.read (| self_addr |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "wrapping_byte_offset",
                    []
                  |),
                  [ M.read (| self |); M.read (| offset |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_addr" (with_addr T).
      
      (*
          pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {
              self.with_addr(f(self.addr()))
          }
      *)
      Definition map_addr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ impl_FnOnce_usize__arrow_usize ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "with_addr", [] |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    impl_FnOnce_usize__arrow_usize,
                    [ Ty.tuple [ Ty.path "usize" ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "addr",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_map_addr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "map_addr" (map_addr T).
      
      (*
          pub const fn to_raw_parts(self) -> ( *mut (), <T as super::Pointee>::Metadata) {
              (self.cast(), super::metadata(self))
          }
      *)
      Definition to_raw_parts
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [ Ty.tuple [] ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  M.get_function (| "core::ptr::metadata::metadata", [ T ] |),
                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
                |)
              ]))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_raw_parts :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "to_raw_parts" (to_raw_parts T).
      
      (*
          pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
              // SAFETY: the caller must guarantee that `self` is valid for a
              // reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&*self) } }
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ref" (as_ref T).
      
      (*
          pub const unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_ref
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.rust_cast (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_uninit_ref :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_ref" (as_uninit_ref T).
      
      (*
          pub const unsafe fn offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              // The obtained pointer is valid for writes since the caller must
              // guarantee that it points to the same allocated object as `self`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::offset",
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "isize" ]
              |),
              [ M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "offset" (offset T).
      
      (*
          pub const unsafe fn byte_offset(self, count: isize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { self.cast::<u8>().offset(count).with_metadata_of(self) }
          }
      *)
      Definition byte_offset (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "offset",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_offset" (byte_offset T).
      
      (*
          pub const fn wrapping_offset(self, count: isize) -> *mut T
          where
              T: Sized,
          {
              // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.
              unsafe { intrinsics::arith_offset(self, count) as *mut T }
          }
      *)
      Definition wrapping_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.rust_cast
              (M.call_closure (|
                M.get_function (| "core::intrinsics::arith_offset", [ T ] |),
                [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)); M.read (| count |)
                ]
              |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_offset" (wrapping_offset T).
      
      (*
          pub const fn wrapping_byte_offset(self, count: isize) -> Self {
              self.cast::<u8>().wrapping_offset(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_offset",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_byte_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_offset" (wrapping_byte_offset T).
      
      (*
          pub fn mask(self, mask: usize) -> *mut T {
              intrinsics::ptr_mask(self.cast::<()>(), mask).cast_mut().with_metadata_of(self)
          }
      *)
      Definition mask (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mask ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mask := M.alloc (| mask |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                    "cast_mut",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::ptr_mask", [ Ty.tuple [] ] |),
                      [
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "cast",
                              [ Ty.tuple [] ]
                            |),
                            [ M.read (| self |) ]
                          |));
                        M.read (| mask |)
                      ]
                    |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_mask :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "mask" (mask T).
      
      (*
          pub const unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {
              // SAFETY: the caller must guarantee that `self` is be valid for
              // a mutable reference if it isn't null.
              if self.is_null() { None } else { unsafe { Some(&mut *self) } }
          }
      *)
      Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut" (as_mut T).
      
      (*
          pub const unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>
          where
              T: Sized,
          {
              // SAFETY: the caller must guarantee that `self` meets all the
              // requirements for a reference.
              if self.is_null() { None } else { Some(unsafe { &mut *(self as *mut MaybeUninit<T>) }) }
          }
      *)
      Definition as_uninit_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.rust_cast (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_uninit_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_mut" (as_uninit_mut T).
      
      (*
          pub const fn guaranteed_eq(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_eq(other as _)
          }
      *)
      Definition guaranteed_eq
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_eq",
                []
              |),
              [
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_guaranteed_eq :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "guaranteed_eq" (guaranteed_eq T).
      
      (*
          pub const fn guaranteed_ne(self, other: *mut T) -> Option<bool>
          where
              T: Sized,
          {
              (self as *const T).guaranteed_ne(other as _)
          }
      *)
      Definition guaranteed_ne
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "guaranteed_ne",
                []
              |),
              [
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| other |)))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_guaranteed_ne :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "guaranteed_ne" (guaranteed_ne T).
      
      (*
          pub const unsafe fn offset_from(self, origin: *const T) -> isize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { (self as *const T).offset_from(origin) }
          }
      *)
      Definition offset_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ T ],
                "offset_from",
                []
              |),
              [
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "offset_from" (offset_from T).
      
      (*
          pub const unsafe fn byte_offset_from<U: ?Sized>(self, origin: *const U) -> isize {
              // SAFETY: the caller must uphold the safety contract for `offset_from`.
              unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }
          }
      *)
      Definition byte_offset_from
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [ U ], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "offset_from",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "cast",
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ U ],
                    "cast",
                    [ Ty.path "u8" ]
                  |),
                  [ M.read (| origin |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_byte_offset_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_offset_from" (byte_offset_from T).
      
      (*
          pub const unsafe fn sub_ptr(self, origin: *const T) -> usize
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `sub_ptr`.
              unsafe { (self as *const T).sub_ptr(origin) }
          }
      *)
      Definition sub_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; origin ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let origin := M.alloc (| origin |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*const") [] [ T ], "sub_ptr", [] |),
              [
                M.rust_cast (* MutToConstPointer *) (M.pointer_coercion (M.read (| self |)));
                M.read (| origin |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sub_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "sub_ptr" (sub_ptr T).
      
      (*
          pub const unsafe fn add(self, count: usize) -> Self
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `offset`.
              unsafe { intrinsics::offset(self, count) }
          }
      *)
      Definition add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::offset",
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize" ]
              |),
              [ M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "add" (add T).
      
      (*
          pub const unsafe fn byte_add(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `add`.
              unsafe { self.cast::<u8>().add(count).with_metadata_of(self) }
          }
      *)
      Definition byte_add (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "add",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_add" (byte_add T).
      
      (*
          pub const unsafe fn sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              if T::IS_ZST {
                  // Pointer arithmetic does nothing when the pointee is a ZST.
                  self
              } else {
                  // SAFETY: the caller must uphold the safety contract for `offset`.
                  // Because the pointee is *not* a ZST, that means that `count` is
                  // at most `isize::MAX`, and thus the negation cannot overflow.
                  unsafe { self.offset(intrinsics::unchecked_sub(0, count as isize)) }
              }
          }
      *)
      Definition sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      self));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "offset",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::unchecked_sub",
                                [ Ty.path "isize" ]
                              |),
                              [ Value.Integer 0; M.rust_cast (M.read (| count |)) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "sub" (sub T).
      
      (*
          pub const unsafe fn byte_sub(self, count: usize) -> Self {
              // SAFETY: the caller must uphold the safety contract for `sub`.
              unsafe { self.cast::<u8>().sub(count).with_metadata_of(self) }
          }
      *)
      Definition byte_sub (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "sub",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "byte_sub" (byte_sub T).
      
      (*
          pub const fn wrapping_add(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset(count as isize)
          }
      *)
      Definition wrapping_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                []
              |),
              [ M.read (| self |); M.rust_cast (M.read (| count |)) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_add" (wrapping_add T).
      
      (*
          pub const fn wrapping_byte_add(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_add(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_add",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_add" (wrapping_byte_add T).
      
      (*
          pub const fn wrapping_sub(self, count: usize) -> Self
          where
              T: Sized,
          {
              self.wrapping_offset((count as isize).wrapping_neg())
          }
      *)
      Definition wrapping_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "wrapping_offset",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_neg", [] |),
                  [ M.rust_cast (M.read (| count |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_sub" (wrapping_sub T).
      
      (*
          pub const fn wrapping_byte_sub(self, count: usize) -> Self {
              self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)
          }
      *)
      Definition wrapping_byte_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "with_metadata_of",
                [ T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "wrapping_sub",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [ Ty.path "u8" ]
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrapping_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "wrapping_byte_sub" (wrapping_byte_sub T).
      
      (*
          pub const unsafe fn read(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for ``.
              unsafe { read(self) }
          }
      *)
      Definition read (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::ptr::read", [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_read :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read" (read T).
      
      (*
          pub unsafe fn read_volatile(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_volatile`.
              unsafe { read_volatile(self) }
          }
      *)
      Definition read_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::ptr::read_volatile", [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_read_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read_volatile" (read_volatile T).
      
      (*
          pub const unsafe fn read_unaligned(self) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `read_unaligned`.
              unsafe { read_unaligned(self) }
          }
      *)
      Definition read_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::ptr::read_unaligned", [ T ] |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_read_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "read_unaligned" (read_unaligned T).
      
      (*
          pub const unsafe fn copy_to(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(self, dest, count) }
          }
      *)
      Definition copy_to (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dest := M.alloc (| dest |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy", [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_to" (copy_to T).
      
      (*
          pub const unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(self, dest, count) }
          }
      *)
      Definition copy_to_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; dest; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dest := M.alloc (| dest |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
              [
                (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                M.read (| dest |);
                M.read (| count |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_to_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_to_nonoverlapping" (copy_to_nonoverlapping T).
      
      (*
          pub const unsafe fn copy_from(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy`.
              unsafe { copy(src, self, count) }
          }
      *)
      Definition copy_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy", [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_from :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_from" (copy_from T).
      
      (*
          pub const unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.
              unsafe { copy_nonoverlapping(src, self, count) }
          }
      *)
      Definition copy_from_nonoverlapping
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; src; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
              [ M.read (| src |); M.read (| self |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_from_nonoverlapping :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "copy_from_nonoverlapping" (copy_from_nonoverlapping T).
      
      (*
          pub unsafe fn drop_in_place(self) {
              // SAFETY: the caller must uphold the safety contract for `drop_in_place`.
              unsafe { drop_in_place(self) }
          }
      *)
      Definition drop_in_place
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::ptr::drop_in_place", [ T ] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_drop_in_place :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "drop_in_place" (drop_in_place T).
      
      (*
          pub const unsafe fn write(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write`.
              unsafe { write(self, val) }
          }
      *)
      Definition write (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              M.get_function (| "core::ptr::write", [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write" (write T).
      
      (*
          pub const unsafe fn write_bytes(self, val: u8, count: usize)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_bytes`.
              unsafe { write_bytes(self, val, count) }
          }
      *)
      Definition write_bytes (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; val; count ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_function (| "core::intrinsics::write_bytes", [ T ] |),
              [ M.read (| self |); M.read (| val |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write_bytes :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_bytes" (write_bytes T).
      
      (*
          pub unsafe fn write_volatile(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_volatile`.
              unsafe { write_volatile(self, val) }
          }
      *)
      Definition write_volatile
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              M.get_function (| "core::ptr::write_volatile", [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write_volatile :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_volatile" (write_volatile T).
      
      (*
          pub const unsafe fn write_unaligned(self, val: T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `write_unaligned`.
              unsafe { write_unaligned(self, val) }
          }
      *)
      Definition write_unaligned
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            M.call_closure (|
              M.get_function (| "core::ptr::write_unaligned", [ T ] |),
              [ M.read (| self |); M.read (| val |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write_unaligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "write_unaligned" (write_unaligned T).
      
      (*
          pub unsafe fn replace(self, src: T) -> T
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `replace`.
              unsafe { replace(self, src) }
          }
      *)
      Definition replace (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.call_closure (|
              M.get_function (| "core::ptr::replace", [ T ] |),
              [ M.read (| self |); M.read (| src |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_replace :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "replace" (replace T).
      
      (*
          pub const unsafe fn swap(self, with: *mut T)
          where
              T: Sized,
          {
              // SAFETY: the caller must uphold the safety contract for `swap`.
              unsafe { swap(self, with) }
          }
      *)
      Definition swap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; with_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let with_ := M.alloc (| with_ |) in
            M.call_closure (|
              M.get_function (| "core::ptr::swap", [ T ] |),
              [ M.read (| self |); M.read (| with_ |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "swap" (swap T).
      
      (*
          pub const fn align_offset(self, align: usize) -> usize
          where
              T: Sized,
          {
              if !align.is_power_of_two() {
                  panic!("align_offset: align is not a power-of-two");
              }
      
              // SAFETY: `align` has been checked to be a power of 2 above
              let ret = unsafe { align_offset(self, align) };
      
              // Inform Miri that we want to consider the resulting pointer to be suitably aligned.
              #[cfg(miri)]
              if ret != usize::MAX {
                  intrinsics::miri_promise_symbolic_alignment(
                      self.wrapping_add(ret).cast_const().cast(),
                      align,
                  );
              }
      
              ret
          }
      *)
      Definition align_offset
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "is_power_of_two",
                                    []
                                  |),
                                  [ M.read (| align |) ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic_fmt", [] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "align_offset: align is not a power-of-two"
                                            |)
                                          ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ ret :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::ptr::align_offset", [ T ] |),
                    [
                      (* MutToConstPointer *) M.pointer_coercion (M.read (| self |));
                      M.read (| align |)
                    ]
                  |)
                |) in
              ret
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_align_offset :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "align_offset" (align_offset T).
      
      (*
          pub const fn is_aligned(self) -> bool
          where
              T: Sized,
          {
              self.is_aligned_to(mem::align_of::<T>())
          }
      *)
      Definition is_aligned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                "is_aligned_to",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (| M.get_function (| "core::mem::align_of", [ T ] |), [] |)
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_aligned :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_aligned" (is_aligned T).
      
      (*
          pub const fn is_aligned_to(self, align: usize) -> bool {
              if !align.is_power_of_two() {
                  panic!("is_aligned_to: align is not a power-of-two");
              }
      
              #[inline]
              fn runtime_impl(ptr: *mut (), align: usize) -> bool {
                  ptr.addr() & (align - 1) == 0
              }
      
              #[inline]
              const fn const_impl(ptr: *mut (), align: usize) -> bool {
                  // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.
                  // The cast to `()` is used to
                  //   1. deal with fat pointers; and
                  //   2. ensure that `align_offset` doesn't actually try to compute an offset.
                  ptr.align_offset(align) == 0
              }
      
              // SAFETY: The two versions are equivalent at runtime.
              unsafe { const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl) }
          }
      *)
      Definition is_aligned_to
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "is_power_of_two",
                                    []
                                  |),
                                  [ M.read (| align |) ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic_fmt", [] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "is_aligned_to: align is not a power-of-two"
                                            |)
                                          ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::const_eval_select",
                    [
                      Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ];
                      Ty.function
                        [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
                        (Ty.path "bool");
                      Ty.function
                        [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]; Ty.path "usize" ]
                        (Ty.path "bool");
                      Ty.path "bool"
                    ]
                  |),
                  [
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "cast",
                            [ Ty.tuple [] ]
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.read (| align |)
                      ];
                    M.get_associated_function (| Self, "const_impl.is_aligned_to", [] |);
                    M.get_associated_function (| Self, "runtime_impl.is_aligned_to", [] |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_aligned_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_aligned_to" (is_aligned_to T).
    End Impl_pointer_mut_T.
    
    Module Impl_pointer_mut_slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          pub const fn len(self) -> usize {
              metadata(self)
          }
      *)
      Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (|
                "core::ptr::metadata::metadata",
                [ Ty.apply (Ty.path "slice") [] [ T ] ]
              |),
              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_len :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "len" (len T).
      
      (*
          pub const fn is_empty(self) -> bool {
              self.len() == 0
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.eq
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  "len",
                  []
                |),
                [ M.read (| self |) ]
              |))
              (Value.Integer 0)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "is_empty" (is_empty T).
      
      (*
          pub unsafe fn split_at_mut(self, mid: usize) -> ( *mut [T], *mut [T]) {
              assert!(mid <= self.len());
              // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct
              // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`
              unsafe { self.split_at_mut_unchecked(mid) }
          }
      *)
      Definition split_at_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mid := M.alloc (| mid |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.le
                                  (M.read (| mid |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: mid <= self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    "split_at_mut_unchecked",
                    []
                  |),
                  [ M.read (| self |); M.read (| mid |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_split_at_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "split_at_mut" (split_at_mut T).
      
      (*
          pub unsafe fn split_at_mut_unchecked(self, mid: usize) -> ( *mut [T], *mut [T]) {
              let len = self.len();
              let ptr = self.as_mut_ptr();
      
              // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.
              let tail = unsafe { ptr.add(mid) };
              (
                  crate::ptr::slice_from_raw_parts_mut(ptr, mid),
                  crate::ptr::slice_from_raw_parts_mut(tail, len - mid),
              )
          }
      *)
      Definition split_at_mut_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; mid ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mid := M.alloc (| mid |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "len",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ tail :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [] |),
                    [ M.read (| ptr |); M.read (| mid |) ]
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.call_closure (|
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                      [ M.read (| ptr |); M.read (| mid |) ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                      [
                        M.read (| tail |);
                        BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| mid |))
                      ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_split_at_mut_unchecked :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "split_at_mut_unchecked" (split_at_mut_unchecked T).
      
      (*
          pub const fn as_mut_ptr(self) -> *mut T {
              self as *mut T
          }
      *)
      Definition as_mut_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| self |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_mut_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut_ptr" (as_mut_ptr T).
      
      (*
          pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output
          where
              I: SliceIndex<[T]>,
          {
              // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.
              unsafe { index.get_unchecked_mut(self) }
          }
      *)
      Definition get_unchecked_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as I ], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::slice::index::SliceIndex",
                I,
                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                "get_unchecked_mut",
                []
              |),
              [ M.read (| index |); M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_unchecked_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_unchecked_mut" (get_unchecked_mut T).
      
      (*
          pub const unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.
                  Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_function (|
                                "core::slice::raw::from_raw_parts",
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                              |),
                              [
                                M.rust_cast (M.read (| self |));
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_uninit_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_slice" (as_uninit_slice T).
      
      (*
          pub const unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {
              if self.is_null() {
                  None
              } else {
                  // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.
                  Some(unsafe { slice::from_raw_parts_mut(self as *mut MaybeUninit<T>, self.len()) })
              }
          }
      *)
      Definition as_uninit_slice_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [ host ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_null",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_function (|
                                "core::slice::raw::from_raw_parts_mut",
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                              |),
                              [
                                M.rust_cast (M.read (| self |));
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_uninit_slice_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_uninit_slice_mut" (as_uninit_slice_mut T).
    End Impl_pointer_mut_slice_T.
    
    Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn eq(&self, other: &*mut T) -> bool {
              *self == *other
          }
      *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Pure.eq (M.read (| M.read (| self |) |)) (M.read (| M.read (| other |) |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn cmp(&self, other: &*mut T) -> Ordering {
              if self < other {
                  Less
              } else if self == other {
                  Equal
              } else {
                  Greater
              }
          }
      *)
      Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                ],
                                "lt",
                                []
                              |),
                              [ self; M.alloc (| M.read (| other |) |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::cmp::Ordering::Less" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                        ],
                                        "eq",
                                        []
                                      |),
                                      [ self; other ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::cmp::Ordering::Greater" [] |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
    End Impl_core_cmp_Ord_where_core_marker_Sized_T_for_pointer_mut_T.
    
    Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
          fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    [],
                    "cmp",
                    []
                  |),
                  [ M.read (| self |); M.read (| other |) ]
                |)
              ]))
        | _, _, _ => M.impossible
        end.
      
      (*
          fn lt(&self, other: &*mut T) -> bool {
              *self < *other
          }
      *)
      Definition lt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Pure.lt (M.read (| M.read (| self |) |)) (M.read (| M.read (| other |) |))))
        | _, _, _ => M.impossible
        end.
      
      (*
          fn le(&self, other: &*mut T) -> bool {
              *self <= *other
          }
      *)
      Definition le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Pure.le (M.read (| M.read (| self |) |)) (M.read (| M.read (| other |) |))))
        | _, _, _ => M.impossible
        end.
      
      (*
          fn gt(&self, other: &*mut T) -> bool {
              *self > *other
          }
      *)
      Definition gt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Pure.gt (M.read (| M.read (| self |) |)) (M.read (| M.read (| other |) |))))
        | _, _, _ => M.impossible
        end.
      
      (*
          fn ge(&self, other: &*mut T) -> bool {
              *self >= *other
          }
      *)
      Definition ge (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            BinOp.Pure.ge (M.read (| M.read (| self |) |)) (M.read (| M.read (| other |) |))))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("partial_cmp", InstanceField.Method (partial_cmp T));
            ("lt", InstanceField.Method (lt T));
            ("le", InstanceField.Method (le T));
            ("gt", InstanceField.Method (gt T));
            ("ge", InstanceField.Method (ge T))
          ].
    End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_for_pointer_mut_T.
  End mut_ptr.
End ptr.
