(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module iter.
    Module Impl_core_iter_traits_iterator_Iterator_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_iterator_Iterator_for_slice_T.
    
    Module Impl_core_iter_traits_collect_IntoIterator_for_ref__slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (*     type IntoIter = Iter<'a, T>; *)
      Definition _IntoIter (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*
          fn into_iter(self) -> Iter<'a, T> {
              self.iter()
          }
      *)
      Definition into_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "iter", [], [] |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("IntoIter", InstanceField.Ty (_IntoIter T));
            ("into_iter", InstanceField.Method (into_iter T))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_for_ref__slice_T.
    
    Module Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*     type Item = &'a mut T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (*     type IntoIter = IterMut<'a, T>; *)
      Definition _IntoIter (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      (*
          fn into_iter(self) -> IterMut<'a, T> {
              self.iter_mut()
          }
      *)
      Definition into_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ T ],
                "iter_mut",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("IntoIter", InstanceField.Ty (_IntoIter T));
            ("into_iter", InstanceField.Method (into_iter T))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_slice_T.
    
    (* StructRecord
      {
        name := "Iter";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]);
            ("end_or_len", Ty.apply (Ty.path "*const") [] [ T ]);
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [] [ Ty.apply (Ty.path "&") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("Iter").field(&self.as_slice()).finish()
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_tuple",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "Iter" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                    "as_slice",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_marker_Send_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let len = slice.len();
              let ptr: NonNull<T> = NonNull::from(slice).cast();
              // SAFETY: Similar to `IterMut::new`.
              unsafe {
                  let end_or_len =
                      if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };
      
                  Self { ptr, end_or_len, _marker: PhantomData }
              }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "cast",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                          [],
                          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    ]
                  |)
                |) in
              let~ end_or_len : Ty.apply (Ty.path "*const") [] [ T ] :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant "core::mem::SizedTypeProperties::IS_ZST") in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_function (| "core::ptr::without_provenance", [], [ T ] |),
                              [ M.read (| len |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            (* MutToConstPointer *)
                            M.pointer_coercion
                              (M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                      "as_ptr",
                                      [],
                                      []
                                    |),
                                    [ M.read (| ptr |) ]
                                  |);
                                  M.read (| len |)
                                ]
                              |))
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::Iter"
                  [
                    ("ptr", M.read (| ptr |));
                    ("end_or_len", M.read (| end_or_len |));
                    ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn as_slice(&self) -> &'a [T] {
              self.make_slice()
          }
      *)
      Definition as_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                    "make_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_slice" (as_slice T).
      Smpl Add apply AssociatedFunction_as_slice : is_associated.
    End Impl_core_slice_iter_Iter_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              Iter { ptr: self.ptr, end_or_len: self.end_or_len, _marker: self._marker }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Iter"
              [
                ("ptr",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Iter",
                      "ptr"
                    |)
                  |));
                ("end_or_len",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Iter",
                      "end_or_len"
                    |)
                  |));
                ("_marker",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Iter",
                      "_marker"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Iter_T.
    
    Module Impl_core_convert_AsRef_slice_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*
          fn as_ref(&self) -> &[T] {
              self.as_slice()
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                    "as_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
    End Impl_core_convert_AsRef_slice_T_for_core_slice_iter_Iter_T.
    
    (* StructRecord
      {
        name := "IterMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]);
            ("end_or_len", Ty.apply (Ty.path "*mut") [] [ T ]);
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "&mut") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("IterMut").field(&self.make_slice()).finish()
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_tuple",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "IterMut" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ],
                                    "make_slice",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T]) -> Self {
              let len = slice.len();
              let ptr: NonNull<T> = NonNull::from(slice).cast();
              // SAFETY: There are several things here:
              //
              // `ptr` has been obtained by `slice.as_ptr()` where `slice` is a valid
              // reference thus it is non-NUL and safe to use and pass to
              // `NonNull::new_unchecked` .
              //
              // Adding `slice.len()` to the starting pointer gives a pointer
              // at the end of `slice`. `end` will never be dereferenced, only checked
              // for direct pointer equality with `ptr` to check if the iterator is
              // done.
              //
              // In the case of a ZST, the end pointer is just the length.  It's never
              // used as a pointer at all, and thus it's fine to have no provenance.
              //
              // See the `next_unchecked!` and `is_empty!` macros as well as the
              // `post_inc_start` method for more information.
              unsafe {
                  let end_or_len =
                      if T::IS_ZST { without_provenance_mut(len) } else { ptr.as_ptr().add(len) };
      
                  Self { ptr, end_or_len, _marker: PhantomData }
              }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      "cast",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                          [],
                          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    ]
                  |)
                |) in
              let~ end_or_len : Ty.apply (Ty.path "*mut") [] [ T ] :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant "core::mem::SizedTypeProperties::IS_ZST") in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                              [ M.read (| len |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "add",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| ptr |) ]
                                |);
                                M.read (| len |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::IterMut"
                  [
                    ("ptr", M.read (| ptr |));
                    ("end_or_len", M.read (| end_or_len |));
                    ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn into_slice(self) -> &'a mut [T] {
              // SAFETY: the iterator was created from a mutable slice with pointer
              // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites
              // for `from_raw_parts_mut` are fulfilled.
              unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }
          }
      *)
      Definition into_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                          M.get_function (| "core::slice::raw::from_raw_parts_mut", [], [ T ] |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::IterMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.get_constant
                                            "core::mem::SizedTypeProperties::IS_ZST") in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ len : Ty.path "usize" :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "addr",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "core::slice::iter::IterMut",
                                                  "end_or_len"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      len));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let~ end_ :
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ T ] :=
                                        M.copy (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*const")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "*const")
                                                  []
                                                  [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                                "cast",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ T ]
                                                ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.ConstPointer,
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "core::slice::iter::IterMut",
                                                    "end_or_len"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ T ],
                                            "sub_ptr",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| end_ |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::IterMut",
                                                "ptr"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_slice" (into_slice T).
      Smpl Add apply AssociatedFunction_into_slice : is_associated.
      
      (*
          pub fn as_slice(&self) -> &[T] {
              self.make_slice()
          }
      *)
      Definition as_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ],
                    "make_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_slice" (as_slice T).
      Smpl Add apply AssociatedFunction_as_slice : is_associated.
      
      (*
          pub fn as_mut_slice(&mut self) -> &mut [T] {
              // SAFETY: the iterator was created from a mutable slice with pointer
              // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites
              // for `from_raw_parts_mut` are fulfilled.
              unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }
          }
      *)
      Definition as_mut_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                          M.get_function (| "core::slice::raw::from_raw_parts_mut", [], [ T ] |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::IterMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.get_constant
                                            "core::mem::SizedTypeProperties::IS_ZST") in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ len : Ty.path "usize" :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "addr",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::IterMut",
                                                  "end_or_len"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      len));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let~ end_ :
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ T ] :=
                                        M.copy (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*const")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "*const")
                                                  []
                                                  [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                                "cast",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ T ]
                                                ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.ConstPointer,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::IterMut",
                                                    "end_or_len"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ T ],
                                            "sub_ptr",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| end_ |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::IterMut",
                                                "ptr"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut_slice" (as_mut_slice T).
      Smpl Add apply AssociatedFunction_as_mut_slice : is_associated.
    End Impl_core_slice_iter_IterMut_T.
    
    Module Impl_core_convert_AsRef_slice_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      (*
          fn as_ref(&self) -> &[T] {
              self.as_slice()
          }
      *)
      Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ],
                    "as_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
    End Impl_core_convert_AsRef_slice_T_for_core_slice_iter_IterMut_T.
    
    (* Trait *)
    (* Empty module 'SplitIter' *)
    
    (* StructRecord
      {
        name := "Split";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              Self { v: slice, pred, finished: false }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::Split"
              [
                ("v", M.read (| slice |));
                ("pred", M.read (| pred |));
                ("finished", Value.Bool false)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn as_slice(&self) -> &'a [T] {
              if self.finished { &[] } else { &self.v }
          }
      *)
      Definition as_slice (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.read (|
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::Split",
                                    "v"
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "as_slice" (as_slice T P).
      Smpl Add apply AssociatedFunction_as_slice : is_associated.
    End Impl_core_slice_iter_Split_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Split").field("v", &self.v).field("finished", &self.finished).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "Split" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Split",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::Split",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              Split { v: self.v, pred: self.pred.clone(), finished: self.finished }
          }
      *)
      Definition clone (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Split"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Split",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("pred",
                  M.call_closure (|
                    P,
                    M.get_trait_method (| "core::clone::Clone", P, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Split",
                          "pred"
                        |)
                      |)
                    ]
                  |));
                ("finished",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Split",
                      "finished"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().position(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let (left, right) =
                          // SAFETY: if v.iter().position returns Some(idx), that
                          // idx is definitely a valid index for v
                          unsafe { (self.v.get_unchecked(..idx), self.v.get_unchecked(idx + 1..)) };
                      let ret = Some(left);
                      self.v = right;
                      ret
                  }
              }
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::Split",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                          [],
                          [],
                          "position",
                          [],
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                P,
                                                [],
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Split",
                                                    "pred"
                                                  |)
                                                |);
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| x |) |)
                                                    |)
                                                  ]
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ],
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                                [],
                                [],
                                "finish",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          M.match_operator (|
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          []
                                          [ Ty.path "usize" ]
                                      ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Split",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| idx |)) ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          []
                                          [ Ty.path "usize" ]
                                      ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Split",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [
                                          ("start",
                                            BinOp.Wrap.add (|
                                              M.read (| idx |),
                                              Value.Integer IntegerKind.Usize 1
                                            |))
                                        ]
                                    ]
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left := M.copy (| γ0_0 |) in
                                  let right := M.copy (| γ0_1 |) in
                                  let~ ret :
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                        ] :=
                                    M.alloc (|
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| left |) ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |),
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right |) |)
                                        |)
                                      |)
                                    |) in
                                  ret))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len() + 1` empty slices.
                  (1, Some(self.v.len() + 1))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                BinOp.Wrap.add (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Split",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().rposition(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let (left, right) =
                          // SAFETY: if v.iter().rposition returns Some(idx), then
                          // idx is definitely a valid index for v
                          unsafe { (self.v.get_unchecked(..idx), self.v.get_unchecked(idx + 1..)) };
                      let ret = Some(right);
                      self.v = left;
                      ret
                  }
              }
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::Split",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                          [],
                          [],
                          "rposition",
                          [],
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                P,
                                                [],
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Split",
                                                    "pred"
                                                  |)
                                                |);
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| x |) |)
                                                    |)
                                                  ]
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ],
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                                [],
                                [],
                                "finish",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          M.match_operator (|
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          []
                                          [ Ty.path "usize" ]
                                      ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Split",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| idx |)) ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          []
                                          [ Ty.path "usize" ]
                                      ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Split",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [
                                          ("start",
                                            BinOp.Wrap.add (|
                                              M.read (| idx |),
                                              Value.Integer IntegerKind.Usize 1
                                            |))
                                        ]
                                    ]
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left := M.copy (| γ0_0 |) in
                                  let right := M.copy (| γ0_1 |) in
                                  let~ ret :
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                        ] :=
                                    M.alloc (|
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| right |) ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |),
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left |) |)
                                        |)
                                      |)
                                    |) in
                                  ret))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  None
              } else {
                  self.finished = true;
                  Some(self.v)
              }
          }
      *)
      Definition finish (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Split",
                              "finished"
                            |),
                            Value.Bool true
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::Split",
                                    "v"
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    (* StructRecord
      {
        name := "SplitInclusive";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              let finished = slice.is_empty();
              Self { v: slice, pred, finished }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            M.read (|
              let~ finished : Ty.path "bool" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "is_empty",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::SplitInclusive"
                  [
                    ("v", M.read (| slice |));
                    ("pred", M.read (| pred |));
                    ("finished", M.read (| finished |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitInclusive")
                  .field("v", &self.v)
                  .field("finished", &self.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "SplitInclusive" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::SplitInclusive",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::SplitInclusive",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }
          }
      *)
      Definition clone (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::SplitInclusive"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::SplitInclusive",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("pred",
                  M.call_closure (|
                    P,
                    M.get_trait_method (| "core::clone::Clone", P, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::SplitInclusive",
                          "pred"
                        |)
                      |)
                    ]
                  |));
                ("finished",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::SplitInclusive",
                      "finished"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              let idx =
                  self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());
              if idx == self.v.len() {
                  self.finished = true;
              }
              let ret = Some(&self.v[..idx]);
              self.v = &self.v[idx..];
              ret
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          "unwrap_or",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              "map",
                              [],
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                  [],
                                  [],
                                  "position",
                                  [],
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          "iter",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::SplitInclusive",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let x := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_trait_method (|
                                                        "core::ops::function::FnMut",
                                                        P,
                                                        [],
                                                        [
                                                          Ty.tuple
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                        ],
                                                        "call_mut",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::slice::iter::SplitInclusive",
                                                            "pred"
                                                          |)
                                                        |);
                                                        Value.Tuple
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| x |) |)
                                                            |)
                                                          ]
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let idx := M.copy (| γ |) in
                                                BinOp.Wrap.add (|
                                                  M.read (| idx |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::SplitInclusive",
                                      "v"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (|
                                    M.read (| idx |),
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusive",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::SplitInclusive",
                                    "finished"
                                  |),
                                  Value.Bool true
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ] :=
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeTo")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitInclusive",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeTo"
                                    [ ("end_", M.read (| idx |)) ]
                                ]
                              |)
                            |)
                          |)
                        ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::SplitInclusive",
                          "v"
                        |),
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeFrom")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |);
                                    Value.StructRecord
                                      "core::ops::range::RangeFrom"
                                      [ ("start", M.read (| idx |)) ]
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      |)
                    |) in
                  ret
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len()` one-element slices,
                  // or a single empty slice.
                  (1, Some(cmp::max(1, self.v.len())))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::SplitInclusive",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                                  [
                                    Value.Integer IntegerKind.Usize 1;
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusive",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              // The last index of self.v is already checked and found to match
              // by the last iteration, so we start searching a new match
              // one index to the left.
              let remainder = if self.v.is_empty() { &[] } else { &self.v[..(self.v.len() - 1)] };
              let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);
              if idx == 0 {
                  self.finished = true;
              }
              let ret = Some(&self.v[idx..]);
              self.v = &self.v[..idx];
              ret
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ remainder :
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusive",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusive",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeTo"
                                          [
                                            ("end_",
                                              BinOp.Wrap.sub (|
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::slice::iter::SplitInclusive",
                                                            "v"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |),
                                                Value.Integer IntegerKind.Usize 1
                                              |))
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ idx : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          "unwrap_or",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              "map",
                              [],
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                  [],
                                  [],
                                  "rposition",
                                  [],
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          "iter",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| remainder |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let x := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_trait_method (|
                                                        "core::ops::function::FnMut",
                                                        P,
                                                        [],
                                                        [
                                                          Ty.tuple
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                        ],
                                                        "call_mut",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::slice::iter::SplitInclusive",
                                                            "pred"
                                                          |)
                                                        |);
                                                        Value.Tuple
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| x |) |)
                                                            |)
                                                          ]
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let idx := M.copy (| γ |) in
                                                BinOp.Wrap.add (|
                                                  M.read (| idx |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |);
                          Value.Integer IntegerKind.Usize 0
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (| M.read (| idx |), Value.Integer IntegerKind.Usize 0 |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::SplitInclusive",
                                    "finished"
                                  |),
                                  Value.Bool true
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ] :=
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitInclusive",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    [ ("start", M.read (| idx |)) ]
                                ]
                              |)
                            |)
                          |)
                        ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::SplitInclusive",
                          "v"
                        |),
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |);
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [ ("end_", M.read (| idx |)) ]
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      |)
                    |) in
                  ret
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    (* StructRecord
      {
        name := "SplitMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              Self { v: slice, pred, finished: false }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::SplitMut"
              [
                ("v", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |));
                ("pred", M.read (| pred |));
                ("finished", Value.Bool false)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitMut").field("v", &self.v).field("finished", &self.finished).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "SplitMut" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::SplitMut",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::SplitMut",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  None
              } else {
                  self.finished = true;
                  Some(mem::take(&mut self.v))
              }
          }
      *)
      Definition finish (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::SplitMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::SplitMut",
                              "finished"
                            |),
                            Value.Bool true
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_function (|
                                    "core::mem::take",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                    ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::SplitMut",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().position(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let tmp = mem::take(&mut self.v);
                      // idx is the index of the element we are splitting on. We want to set self to the
                      // region after idx, and return the subslice before and not including idx.
                      // So first we split after idx
                      let (head, tail) = tmp.split_at_mut(idx + 1);
                      self.v = tail;
                      // Then return the subslice up to but not including the found element
                      Some(&mut head[..idx])
                  }
              }
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                          [],
                          [],
                          "position",
                          [],
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                P,
                                                [],
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::SplitMut",
                                                    "pred"
                                                  |)
                                                |);
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| x |) |)
                                                    |)
                                                  ]
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ],
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                                [],
                                [],
                                "finish",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ tmp :
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_function (|
                                  "core::mem::take",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "split_at_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| tmp |) |)
                                  |);
                                  BinOp.Wrap.add (|
                                    M.read (| idx |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let head := M.copy (| γ0_0 |) in
                                  let tail := M.copy (| γ0_1 |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |),
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| tail |) |)
                                        |)
                                      |)
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::index::IndexMut",
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::RangeTo")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ],
                                                    "index_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| head |) |)
                                                    |);
                                                    Value.StructRecord
                                                      "core::ops::range::RangeTo"
                                                      [ ("end_", M.read (| idx |)) ]
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len() + 1` empty slices.
                  (1, Some(self.v.len() + 1))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::SplitMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                BinOp.Wrap.add (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::SplitMut",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
                  self.v.iter().rposition(|x| ( *pred)(x))
              };
              match idx_opt {
                  None => self.finish(),
                  Some(idx) => {
                      let tmp = mem::take(&mut self.v);
                      let (head, tail) = tmp.split_at_mut(idx);
                      self.v = head;
                      Some(&mut tail[1..])
                  }
              }
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt : Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      let~ pred : Ty.apply (Ty.path "&mut") [] [ P ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::SplitMut",
                              "pred"
                            |)
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                            [],
                            [],
                            "rposition",
                            [],
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::SplitMut",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  P,
                                                  [],
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                  "call_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| pred |) |)
                                                  |);
                                                  Value.Tuple
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| x |) |)
                                                      |)
                                                    ]
                                                ]
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)
                    |) in
                  M.match_operator (|
                    idx_opt,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ],
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                                [],
                                [],
                                "finish",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ tmp :
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_function (|
                                  "core::mem::take",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "split_at_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| tmp |) |)
                                  |);
                                  M.read (| idx |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let head := M.copy (| γ0_0 |) in
                                  let tail := M.copy (| γ0_1 |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |),
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| head |) |)
                                        |)
                                      |)
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::index::IndexMut",
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::RangeFrom")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ],
                                                    "index_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| tail |) |)
                                                    |);
                                                    Value.StructRecord
                                                      "core::ops::range::RangeFrom"
                                                      [ ("start", Value.Integer IntegerKind.Usize 1)
                                                      ]
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    (* StructRecord
      {
        name := "SplitInclusiveMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              let finished = slice.is_empty();
              Self { v: slice, pred, finished }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            M.read (|
              let~ finished : Ty.path "bool" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "is_empty",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::SplitInclusiveMut"
                  [
                    ("v", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |));
                    ("pred", M.read (| pred |));
                    ("finished", M.read (| finished |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitInclusiveMut")
                  .field("v", &self.v)
                  .field("finished", &self.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (| Value.String "SplitInclusiveMut" |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::SplitInclusiveMut",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::SplitInclusiveMut",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [] [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
                  self.v.iter().position(|x| ( *pred)(x))
              };
              let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());
              if idx == self.v.len() {
                  self.finished = true;
              }
              let tmp = mem::take(&mut self.v);
              let (head, tail) = tmp.split_at_mut(idx);
              self.v = tail;
              Some(head)
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt : Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      let~ pred : Ty.apply (Ty.path "&mut") [] [ P ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::SplitInclusiveMut",
                              "pred"
                            |)
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                            [],
                            [],
                            "position",
                            [],
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::SplitInclusiveMut",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  P,
                                                  [],
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                  "call_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| pred |) |)
                                                  |);
                                                  Value.Tuple
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| x |) |)
                                                      |)
                                                    ]
                                                ]
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)
                    |) in
                  let~ idx : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          "unwrap_or",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              "map",
                              [],
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.read (| idx_opt |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let idx := M.copy (| γ |) in
                                                BinOp.Wrap.add (|
                                                  M.read (| idx |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::SplitInclusiveMut",
                                      "v"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (|
                                    M.read (| idx |),
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusiveMut",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::SplitInclusiveMut",
                                    "finished"
                                  |),
                                  Value.Bool true
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tmp : Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        M.get_function (|
                          "core::mem::take",
                          [],
                          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "v"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "split_at_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| tmp |) |) |);
                          M.read (| idx |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let head := M.copy (| γ0_0 |) in
                          let tail := M.copy (| γ0_1 |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "v"
                                |),
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| tail |) |) |)
                              |)
                            |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| head |) |) |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len()` one-element slices,
                  // or a single empty slice.
                  (1, Some(cmp::max(1, self.v.len())))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::SplitInclusiveMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                                  [
                                    Value.Integer IntegerKind.Usize 1;
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusiveMut",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = if self.v.is_empty() {
                  None
              } else {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
      
                  // The last index of self.v is already checked and found to match
                  // by the last iteration, so we start searching a new match
                  // one index to the left.
                  let remainder = &self.v[..(self.v.len() - 1)];
                  remainder.iter().rposition(|x| ( *pred)(x))
              };
              let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);
              if idx == 0 {
                  self.finished = true;
              }
              let tmp = mem::take(&mut self.v);
              let (head, tail) = tmp.split_at_mut(idx);
              self.v = head;
              Some(tail)
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt : Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::SplitInclusiveMut",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ pred : Ty.apply (Ty.path "&mut") [] [ P ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::SplitInclusiveMut",
                                      "pred"
                                    |)
                                  |)
                                |) in
                              let~ remainder :
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeTo")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::SplitInclusiveMut",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeTo"
                                            [
                                              ("end_",
                                                BinOp.Wrap.sub (|
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "slice") [] [ T ],
                                                      "len",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "core::slice::iter::SplitInclusiveMut",
                                                              "v"
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                    [],
                                    [],
                                    "rposition",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                        (Ty.path "bool")
                                    ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "iter",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| remainder |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let x := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_trait_method (|
                                                          "core::ops::function::FnMut",
                                                          P,
                                                          [],
                                                          [
                                                            Ty.tuple
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                          ],
                                                          "call_mut",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (| M.read (| pred |) |)
                                                          |);
                                                          Value.Tuple
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| x |) |)
                                                              |)
                                                            ]
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ idx : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          "unwrap_or",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              "map",
                              [],
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.read (| idx_opt |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let idx := M.copy (| γ |) in
                                                BinOp.Wrap.add (|
                                                  M.read (| idx |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |);
                          Value.Integer IntegerKind.Usize 0
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (| M.read (| idx |), Value.Integer IntegerKind.Usize 0 |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::SplitInclusiveMut",
                                    "finished"
                                  |),
                                  Value.Bool true
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tmp : Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        M.get_function (|
                          "core::mem::take",
                          [],
                          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "v"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "split_at_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| tmp |) |) |);
                          M.read (| idx |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let head := M.copy (| γ0_0 |) in
                          let tail := M.copy (| γ0_1 |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "v"
                                |),
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| head |) |) |)
                              |)
                            |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| tail |) |) |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    (* StructRecord
      {
        name := "RSplit";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields := [ ("inner", Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ]) ];
      } *)
    
    Module Impl_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              Self { inner: Split::new(slice, pred) }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::RSplit"
              [
                ("inner",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                      "new",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                      M.read (| pred |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplit")
                  .field("v", &self.inner.v)
                  .field("finished", &self.inner.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "RSplit" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RSplit",
                                          "inner"
                                        |),
                                        "core::slice::iter::Split",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RSplit",
                                  "inner"
                                |),
                                "core::slice::iter::Split",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              RSplit { inner: self.inner.clone() }
          }
      *)
      Definition clone (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RSplit"
              [
                ("inner",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RSplit",
                          "inner"
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              self.inner.next_back()
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplit",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.inner.size_hint()
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplit",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              self.inner.next()
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                [],
                [],
                "next",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplit",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a [T]> {
              self.inner.finish()
          }
      *)
      Definition finish (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::slice::iter::SplitIter",
                Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
                [],
                [],
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplit",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    (* StructRecord
      {
        name := "RSplitMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields := [ ("inner", Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ]) ];
      } *)
    
    Module Impl_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              Self { inner: SplitMut::new(slice, pred) }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::RSplitMut"
              [
                ("inner",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                      "new",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |);
                      M.read (| pred |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitMut")
                  .field("v", &self.inner.v)
                  .field("finished", &self.inner.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "RSplitMut" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "v" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RSplitMut",
                                          "inner"
                                        |),
                                        "core::slice::iter::SplitMut",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "finished" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RSplitMut",
                                  "inner"
                                |),
                                "core::slice::iter::SplitMut",
                                "finished"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a mut [T]> {
              self.inner.finish()
          }
      *)
      Definition finish (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::slice::iter::SplitIter",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                [],
                [],
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplitMut",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              self.inner.next_back()
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplitMut",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.inner.size_hint()
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplitMut",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              self.inner.next()
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
                [],
                [],
                "next",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RSplitMut",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    (* StructRecord
      {
        name := "GenericSplitN";
        const_params := [];
        ty_params := [ "I" ];
        fields := [ ("iter", I); ("count", Ty.path "usize") ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_I_for_core_slice_iter_GenericSplitN_I.
      Definition Self (I : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GenericSplitN") [] [ I ].
      
      (* Debug *)
      Definition fmt (I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "GenericSplitN" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "iter" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::GenericSplitN",
                        "iter"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "count" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::GenericSplitN",
                            "count"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt I)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_I_for_core_slice_iter_GenericSplitN_I.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_slice_iter_SplitIter_I_for_core_slice_iter_GenericSplitN_I.
      Definition Self (T I : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GenericSplitN") [] [ I ].
      
      (*     type Item = T; *)
      Definition _Item (T I : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              match self.count {
                  0 => None,
                  1 => {
                      self.count -= 1;
                      self.iter.finish()
                  }
                  _ => {
                      self.count -= 1;
                      self.iter.next()
                  }
              }
          }
      *)
      Definition next (T I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T I in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::slice::iter::GenericSplitN",
                  "count"
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (|
                          M.read (| γ |),
                          Value.Integer IntegerKind.Usize 0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (|
                          M.read (| γ |),
                          Value.Integer IntegerKind.Usize 1
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β :=
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::GenericSplitN",
                              "count"
                            |) in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          M.get_trait_method (|
                            "core::slice::iter::SplitIter",
                            I,
                            [],
                            [],
                            "finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::GenericSplitN",
                                "iter"
                              |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β :=
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::GenericSplitN",
                              "count"
                            |) in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            I,
                            [],
                            [],
                            "next",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::GenericSplitN",
                                "iter"
                              |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let (lower, upper_opt) = self.iter.size_hint();
              (
                  cmp::min(self.count, lower),
                  Some(upper_opt.map_or(self.count, |upper| cmp::min(self.count, upper))),
              )
          }
      *)
      Definition size_hint (T I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T I in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      I,
                      [],
                      [],
                      "size_hint",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::GenericSplitN",
                          "iter"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let lower := M.copy (| γ0_0 |) in
                      let upper_opt := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::GenericSplitN",
                                    "count"
                                  |)
                                |);
                                M.read (| lower |)
                              ]
                            |);
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    "map_or",
                                    [],
                                    [
                                      Ty.path "usize";
                                      Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                                    ]
                                  |),
                                  [
                                    M.read (| upper_opt |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::GenericSplitN",
                                        "count"
                                      |)
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let upper := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        M.get_function (|
                                                          "core::cmp::min",
                                                          [],
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "core::slice::iter::GenericSplitN",
                                                              "count"
                                                            |)
                                                          |);
                                                          M.read (| upper |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T I : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T I)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T I));
            ("next", InstanceField.Method (next T I));
            ("size_hint", InstanceField.Method (size_hint T I))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_slice_iter_SplitIter_I_for_core_slice_iter_GenericSplitN_I.
    
    (* StructRecord
      {
        name := "SplitN";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                []
                [ Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitN") [] [ T; P ].
      
      (*
          pub(super) fn new(s: Split<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::SplitN"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_SplitN_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitN") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitN").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "SplitN" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "inner" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::SplitN",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitN_T_P.
    
    (* StructRecord
      {
        name := "RSplitN";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                []
                [ Ty.apply (Ty.path "core::slice::iter::RSplit") [] [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_RSplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitN") [] [ T; P ].
      
      (*
          pub(super) fn new(s: RSplit<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::RSplitN"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RSplitN_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitN") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitN").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "RSplitN" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "inner" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RSplitN",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitN_T_P.
    
    (* StructRecord
      {
        name := "SplitNMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                []
                [ Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitNMut") [] [ T; P ].
      
      (*
          pub(super) fn new(s: SplitMut<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::SplitNMut"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_SplitNMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitNMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitNMut").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "SplitNMut" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "inner" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::SplitNMut",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitNMut_T_P.
    
    (* StructRecord
      {
        name := "RSplitNMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                []
                [ Ty.apply (Ty.path "core::slice::iter::RSplitMut") [] [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_RSplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitNMut") [] [ T; P ].
      
      (*
          pub(super) fn new(s: RSplitMut<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::RSplitNMut"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RSplitNMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitNMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitNMut").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "RSplitNMut" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "inner" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RSplitNMut",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitNMut_T_P.
    
    (* StructRecord
      {
        name := "Windows";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("size", Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "Windows" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::Windows",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "size" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Windows",
                            "size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Windows_T.
    
    Module Impl_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: NonZero<usize>) -> Self {
              Self { v: slice, size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::Windows"
              [ ("v", M.read (| slice |)); ("size", M.read (| size |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_Windows_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              Windows { v: self.v, size: self.size }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Windows"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Windows",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Windows",
                      "size"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let ret = Some(&self.v[..self.size.get()]);
                  self.v = &self.v[1..];
                  ret
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.gt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ ret :
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ] :=
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Windows",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ],
                                                "get",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Windows",
                                                    "size"
                                                  |)
                                                |)
                                              ]
                                            |))
                                        ]
                                    ]
                                  |)
                                |)
                              |)
                            ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Windows",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::Windows",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeFrom"
                                          [ ("start", Value.Integer IntegerKind.Usize 1) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      ret))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.size.get() > self.v.len() {
                  (0, Some(0))
              } else {
                  let size = self.v.len() - self.size.get() + 1;
                  (size, Some(size))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.gt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ size : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.add (|
                            BinOp.Wrap.sub (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| size |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| size |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = self.size.get().overflowing_add(n);
              if end > self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let nth = &self.v[n..end];
                  self.v = &self.v[n + 1..];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_add", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Windows",
                              "size"
                            |)
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.gt (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Windows",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ nth :
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::Windows",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [ ("start", M.read (| n |)); ("end_", M.read (| end_ |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::RangeFrom")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::Windows",
                                                        "v"
                                                      |)
                                                    |)
                                                  |)
                                                |);
                                                Value.StructRecord
                                                  "core::ops::range::RangeFrom"
                                                  [
                                                    ("start",
                                                      BinOp.Wrap.add (|
                                                        M.read (| n |),
                                                        Value.Integer IntegerKind.Usize 1
                                                      |))
                                                  ]
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let start = self.v.len() - self.size.get();
                  Some(&self.v[start..])
              }
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.gt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          self,
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::Windows",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::num::nonzero::NonZero")
                                  []
                                  [ Ty.path "usize" ],
                                "get",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Windows",
                                    "size"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::Windows",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeFrom"
                                          [ ("start", M.read (| start |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              // SAFETY: since the caller guarantees that `i` is in bounds,
              // which means that `i` cannot overflow an `isize`, and the
              // slice created by `from_raw_parts` is a subslice of `self.v`
              // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.
              unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size.get()) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [] [ T ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::Windows",
                                    "v"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |);
                        M.read (| idx |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Windows",
                            "size"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let ret = Some(&self.v[self.v.len() - self.size.get()..]);
                  self.v = &self.v[..self.v.len() - 1];
                  ret
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.gt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::num::nonzero::NonZero")
                                    []
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ ret :
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ] :=
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Windows",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [
                                          ("start",
                                            BinOp.Wrap.sub (|
                                              M.call_closure (|
                                                Ty.path "usize",
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ T ],
                                                  "len",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::Windows",
                                                          "v"
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |),
                                              M.call_closure (|
                                                Ty.path "usize",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  "get",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::slice::iter::Windows",
                                                      "size"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |))
                                        ]
                                    ]
                                  |)
                                |)
                              |)
                            ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Windows",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::Windows",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeTo"
                                          [
                                            ("end_",
                                              BinOp.Wrap.sub (|
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::slice::iter::Windows",
                                                            "v"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |),
                                                Value.Integer IntegerKind.Usize 1
                                              |))
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      ret))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = self.v.len().overflowing_sub(n);
              if end < self.size.get() || overflow {
                  self.v = &[];
                  None
              } else {
                  let ret = &self.v[end - self.size.get()..end];
                  self.v = &self.v[..end - 1];
                  Some(ret)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_sub", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::Windows",
                                  "v"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.lt (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::num::nonzero::NonZero")
                                              []
                                              [ Ty.path "usize" ],
                                            "get",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::Windows",
                                                "size"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ ret :
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::Windows",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start",
                                                BinOp.Wrap.sub (|
                                                  M.read (| end_ |),
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::num::nonzero::NonZero")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      "get",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::Windows",
                                                          "size"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |));
                                              ("end_", M.read (| end_ |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::RangeTo")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::Windows",
                                                        "v"
                                                      |)
                                                    |)
                                                  |)
                                                |);
                                                Value.StructRecord
                                                  "core::ops::range::RangeTo"
                                                  [
                                                    ("end_",
                                                      BinOp.Wrap.sub (|
                                                        M.read (| end_ |),
                                                        Value.Integer IntegerKind.Usize 1
                                                      |))
                                                  ]
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| ret |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Windows_T.
    
    (* StructRecord
      {
        name := "Chunks";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "Chunks" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::Chunks",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::Chunks",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::Chunks"
              [ ("v", M.read (| slice |)); ("chunk_size", M.read (| size |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_Chunks_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              Chunks { v: self.v, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Chunks"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Chunks",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::Chunks",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let chunksz = cmp::min(self.v.len(), self.chunk_size);
                  let (fst, snd) = self.v.split_at(chunksz);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ chunksz : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Chunks",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::Chunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              M.read (| chunksz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.div (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ n : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.gt (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let end = match start.checked_add(self.chunk_size) {
                      Some(sum) => cmp::min(self.v.len(), sum),
                      None => self.v.len(),
                  };
                  let nth = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Chunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| start |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Chunks",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ : Ty.path "usize" :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| start |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::Chunks",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_function (|
                                                "core::cmp::min",
                                                [],
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::slice::iter::Chunks",
                                                            "v"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| sum |)
                                              ]
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::Chunks",
                                                        "v"
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              let~ nth :
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::Chunks",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start", M.read (| start |));
                                              ("end_", M.read (| end_ |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::RangeFrom")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::Chunks",
                                                        "v"
                                                      |)
                                                    |)
                                                  |)
                                                |);
                                                Value.StructRecord
                                                  "core::ops::range::RangeFrom"
                                                  [ ("start", M.read (| end_ |)) ]
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;
                  Some(&self.v[start..])
              }
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.div (|
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            self,
                                            "core::slice::iter::Chunks",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::slice::iter::Chunks",
                                  "chunk_size"
                                |)
                              |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::Chunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeFrom"
                                          [ ("start", M.read (| start |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: the caller guarantees that `i` is in bounds,
              // which means that `start` must be in bounds of the
              // underlying `self.v` slice, and we made sure that `len`
              // is also in bounds of `self.v`. Thus, `start` cannot overflow
              // an `isize`, and the slice constructed by `from_raw_parts`
              // is a subslice of `self.v` which is guaranteed to be valid
              // for the lifetime `'a` of `self.v`.
              unsafe {
                  let len = cmp::min(self.v.len().unchecked_sub(start), self.chunk_size);
                  from_raw_parts(self.v.as_ptr().add(start), len)
              }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.mul (|
                    M.read (| idx |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::Chunks",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "usize", "unchecked_sub", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |);
                          M.read (| start |)
                        ]
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::Chunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |);
                            M.read (| start |)
                          ]
                        |);
                        M.read (| len |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let chunksz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: split_at_unchecked requires the argument be less than or
                  // equal to the length. This is guaranteed, but subtle: `chunksz`
                  // will always either be `self.v.len() % self.chunk_size`, which
                  // will always evaluate to strictly less than `self.v.len()` (or
                  // panic, in the case that `self.chunk_size` is zero), or it can be
                  // `self.chunk_size`, in the case that the length is exactly
                  // divisible by the chunk size.
                  //
                  // While it seems like using `self.chunk_size` in this case could
                  // lead to a value greater than `self.v.len()`, it cannot: if
                  // `self.chunk_size` were greater than `self.v.len()`, then
                  // `self.v.len() % self.chunk_size` would return nonzero (note that
                  // in this branch of the `if`, we already know that `self.v` is
                  // non-empty).
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ chunksz : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.read (| remainder |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::Chunks",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at_unchecked",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::Chunks",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                M.read (| chunksz |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = match start.checked_add(self.chunk_size) {
                      Some(res) => cmp::min(self.v.len(), res),
                      None => self.v.len(),
                  };
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[..start];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Chunks",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "checked_add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| start |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::Chunks",
                                      "chunk_size"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let res := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (|
                                        "core::cmp::min",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::Chunks",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (| res |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::Chunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let~ nth_back :
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::Chunks",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::Chunks",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::Chunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeTo"
                                          [ ("end_", M.read (| start |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth_back |) |) |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Chunks_T.
    
    (* StructRecord
      {
        name := "ChunksMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "&mut") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ChunksMut" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksMut",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksMut",
                        "chunk_size"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "_marker" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksMut",
                            "_marker"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::ChunksMut"
              [
                ("v", M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| slice |) |) |));
                ("chunk_size", M.read (| size |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let sz = cmp::min(self.v.len(), self.chunk_size);
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(sz) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ sz : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| sz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |),
                                    M.read (| tail |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| head |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.div (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ n : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.gt (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  let end = match start.checked_add(self.chunk_size) {
                      Some(sum) => cmp::min(self.v.len(), sum),
                      None => self.v.len(),
                  };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth) = unsafe { head.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth })
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ChunksMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| start |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ : Ty.path "usize" :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| start |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksMut",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_function (|
                                                "core::cmp::min",
                                                [],
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "*mut")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::ChunksMut",
                                                        "v"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| sum |)
                                              ]
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::ChunksMut",
                                                    "v"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| end_ |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let tail := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              "split_at_mut",
                                              [],
                                              []
                                            |),
                                            [ M.read (| head |); M.read (| start |) ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let nth := M.copy (| γ0_1 |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.write (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::slice::iter::ChunksMut",
                                                      "v"
                                                    |),
                                                    M.read (| tail |)
                                                  |)
                                                |) in
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (| M.read (| nth |) |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })
              }
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.div (|
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::ChunksMut",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::slice::iter::ChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "get_unchecked_mut",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::RangeFrom")
                                                []
                                                [ Ty.path "usize" ]
                                            ]
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |);
                                            Value.StructRecord
                                              "core::ops::range::RangeFrom"
                                              [ ("start", M.read (| start |)) ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.
              //
              // Also note that the caller also guarantees that we're never called
              // with the same index again, and that no other methods that will
              // access this subslice are called, so it is valid for the returned
              // slice to be mutable.
              unsafe {
                  let len = cmp::min(self.v.len().unchecked_sub(start), self.chunk_size);
                  from_raw_parts_mut(self.v.as_mut_ptr().add(start), len)
              }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ start : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.mul (|
                        M.read (| idx |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksMut",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          let~ len : Ty.path "usize" :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "unchecked_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksMut",
                                              "v"
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.read (| start |)
                                    ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "chunk_size"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_function (|
                                    "core::slice::raw::from_raw_parts_mut",
                                    [],
                                    [ T ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "as_mut_ptr",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (| start |)
                                      ]
                                    |);
                                    M.read (| len |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let sz = if remainder != 0 { remainder } else { self.chunk_size };
                  let len = self.v.len();
                  // SAFETY: Similar to `Chunks::next_back`
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ sz : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.read (| remainder |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksMut",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      let~ len : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut_unchecked",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub (| M.read (| len |), M.read (| sz |) |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |),
                                    M.read (| head |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| tail |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = match start.checked_add(self.chunk_size) {
                      Some(res) => cmp::min(self.v.len(), res),
                      None => self.v.len(),
                  };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (temp, _tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, nth_back) = unsafe { temp.split_at_mut(start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ChunksMut",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.MutPointer,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "checked_add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| start |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksMut",
                                      "chunk_size"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let res := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (|
                                        "core::cmp::min",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (| res |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunksMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let temp := M.copy (| γ0_0 |) in
                              let _tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [ M.read (| temp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksMut",
                                              "v"
                                            |),
                                            M.read (| head |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| nth_back |) |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksMut_T.
    
    (* StructRecord
      {
        name := "ChunksExact";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ChunksExact" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExact",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExact",
                        "rem"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksExact",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              let fst_len = slice.len() - rem;
              // SAFETY: 0 <= fst_len <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };
              Self { v: fst, rem: snd, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.rem (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| chunk_size |)
                  |)
                |) in
              let~ fst_len : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.sub (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| rem |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "split_at_unchecked",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                      M.read (| fst_len |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ChunksExact"
                          [
                            ("v", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |));
                            ("rem",
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "core::slice::iter::ChunksExact",
                "rem"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "remainder" (remainder T).
      Smpl Add apply AssociatedFunction_remainder : is_associated.
    End Impl_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              ChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ChunksExact"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ChunksExact",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("rem",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ChunksExact",
                          "rem"
                        |)
                      |)
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::ChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.chunk_size);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.div (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksExact",
                                "v"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExact",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let (_, snd) = self.v.split_at(start);
                  self.v = snd;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ChunksExact",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| start |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::ChunksExact",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "split_at",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksExact",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let snd := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksExact",
                                              "v"
                                            |),
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| snd |) |)
                                            |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::ChunksExact")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.mul (|
                    M.read (| idx |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExact",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunksExact",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |);
                            M.read (| start |)
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksExact",
                            "chunk_size"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunksExact",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksExact",
                                    "chunk_size"
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = start + self.chunk_size;
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[..start];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ChunksExact",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksExact",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.add (|
                            M.read (| start |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksExact",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ nth_back :
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ChunksExact",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::ChunksExact",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeTo"
                                          [ ("end_", M.read (| start |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth_back |) |) |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ T ],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExact",
                        "v"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExact_T.
    
    (* StructRecord
      {
        name := "ChunksExactMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "&mut") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field4_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ChunksExactMut" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExactMut",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExactMut",
                        "rem"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExactMut",
                        "chunk_size"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "_marker" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksExactMut",
                            "_marker"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              let fst_len = slice.len() - rem;
              // SAFETY: 0 <= fst_len <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };
              Self { v: fst, rem: snd, chunk_size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.rem (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| chunk_size |)
                  |)
                |) in
              let~ fst_len : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.sub (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| rem |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "split_at_mut_unchecked",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |);
                      M.read (| fst_len |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ChunksExactMut"
                          [
                            ("v",
                              M.borrow (|
                                Pointer.Kind.MutPointer,
                                M.deref (| M.read (| fst |) |)
                              |));
                            ("rem",
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| snd |) |) |));
                            ("chunk_size", M.read (| chunk_size |));
                            ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::slice::iter::ChunksExactMut",
                        "rem"
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_remainder" (into_remainder T).
      Smpl Add apply AssociatedFunction_into_remainder : is_associated.
    End Impl_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()
                  let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |),
                                    M.read (| tail |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| head |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.div (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksExactMut",
                            "v"
                          |)
                        |)
                      ]
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ChunksExactMut",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, snd) = unsafe { self.v.split_at_mut(start) };
                  self.v = snd;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ChunksExactMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| start |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::ChunksExactMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksExactMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let snd := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksExactMut",
                                              "v"
                                            |),
                                            M.read (| snd |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::ChunksExactMut")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ start : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.mul (|
                        M.read (| idx |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ChunksExactMut",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.get_function (|
                                "core::slice::raw::from_raw_parts_mut",
                                [],
                                [ T ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "as_mut_ptr",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunksExactMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| start |)
                                  ]
                                |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksExactMut",
                                    "chunk_size"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: This subtraction is inbounds because of the check above
                  let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ChunksExactMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunksExactMut",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |),
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::ChunksExactMut",
                                    "chunk_size"
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |),
                                    M.read (| head |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| tail |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = start + self.chunk_size;
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, nth_back) = unsafe { temp.split_at_mut(start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ChunksExactMut",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.MutPointer,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksExactMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.add (|
                            M.read (| start |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunksExactMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_function (|
                                  "core::mem::replace",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ChunksExactMut",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.MutPointer,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (| Value.Array [] |)
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let temp := M.copy (| γ0_0 |) in
                              let _tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [ M.read (| temp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::ChunksExactMut",
                                              "v"
                                            |),
                                            M.read (| head |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| nth_back |) |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                "is_empty",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ChunksExactMut",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksExactMut_T.
    
    (* StructRecord
      {
        name := "ArrayWindows";
        const_params := [ "N" ];
        ty_params := [ "T" ];
        fields :=
          [
            ("slice_head", Ty.apply (Ty.path "*const") [] [ T ]);
            ("num", Ty.path "usize");
            ("marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (* Debug *)
      Definition fmt
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ArrayWindows" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "slice_head" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ArrayWindows",
                        "slice_head"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "num" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "marker" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ArrayWindows",
                            "marker"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (* Clone *)
      Definition clone
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ArrayWindows"
              [
                ("slice_head",
                  M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ T ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "*const") [] [ T ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ArrayWindows",
                              "slice_head"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("num",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "usize",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ArrayWindows",
                              "num"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::ArrayWindows",
                              "marker"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("clone", InstanceField.Method (clone N T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let num_windows = slice.len().saturating_sub(N - 1);
              Self { slice_head: slice.as_ptr(), num: num_windows, marker: PhantomData }
          }
      *)
      Definition new
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ num_windows : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (| Ty.path "usize", "saturating_sub", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                      |);
                      BinOp.Wrap.sub (|
                        M.read (| M.get_constant "core::slice::iter::N" |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::ArrayWindows"
                  [
                    ("slice_head",
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                      |));
                    ("num", M.read (| num_windows |));
                    ("marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "new" (new N T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (*     type Item = &'a [T; N]; *)
      Definition _Item (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.num == 0 {
                  return None;
              }
              // SAFETY:
              // This is safe because it's indexing into a slice guaranteed to be length > N.
              let ret = unsafe { &*self.slice_head.cast::<[T; N]>() };
              // SAFETY: Guaranteed that there are at least 1 item remaining otherwise
              // earlier branch would've been hit
              self.slice_head = unsafe { self.slice_head.add(1) };
      
              self.num -= 1;
              Some(ret)
          }
      *)
      Definition next
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*const")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::ArrayWindows",
                                  "slice_head"
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "slice_head"
                        |),
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ArrayWindows",
                                "slice_head"
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "num"
                        |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| ret |) |) |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (self.num, Some(self.num))
          }
      *)
      Definition size_hint
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayWindows",
                    "num"
                  |)
                |);
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |)
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.num
          }
      *)
      Definition count
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "core::slice::iter::ArrayWindows",
                "num"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              if self.num <= n {
                  self.num = 0;
                  return None;
              }
              // SAFETY:
              // This is safe because it's indexing into a slice guaranteed to be length > N.
              let ret = unsafe { &*self.slice_head.add(n).cast::<[T; N]>() };
              // SAFETY: Guaranteed that there are at least n items remaining
              self.slice_head = unsafe { self.slice_head.add(n + 1) };
      
              self.num -= n + 1;
              Some(ret)
          }
      *)
      Definition nth
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.le (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    M.read (| n |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ArrayWindows",
                                          "num"
                                        |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |) in
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*const")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [] [ T ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ArrayWindows",
                                      "slice_head"
                                    |)
                                  |);
                                  M.read (| n |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "slice_head"
                        |),
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ArrayWindows",
                                "slice_head"
                              |)
                            |);
                            BinOp.Wrap.add (| M.read (| n |), Value.Integer IntegerKind.Usize 1 |)
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "num"
                        |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (|
                          M.read (| β |),
                          BinOp.Wrap.add (| M.read (| n |), Value.Integer IntegerKind.Usize 1 |)
                        |)
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| ret |) |) |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.nth(self.num.checked_sub(1)?)
          }
      *)
      Definition last
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ],
                    [],
                    [],
                    "nth",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, self |);
                    M.read (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.path "usize"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "checked_sub",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::ArrayWindows",
                                      "num"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N T));
            ("next", InstanceField.Method (next N T));
            ("size_hint", InstanceField.Method (size_hint N T));
            ("count", InstanceField.Method (count N T));
            ("nth", InstanceField.Method (nth N T));
            ("last", InstanceField.Method (last N T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T; N]> {
              if self.num == 0 {
                  return None;
              }
              // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.
              let ret = unsafe { &*self.slice_head.add(self.num - 1).cast::<[T; N]>() };
              self.num -= 1;
              Some(ret)
          }
      *)
      Definition next_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.eq (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*const")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [] [ T ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ArrayWindows",
                                      "slice_head"
                                    |)
                                  |);
                                  BinOp.Wrap.sub (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "num"
                        |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| ret |) |) |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<&'a [T; N]> {
              if self.num <= n {
                  self.num = 0;
                  return None;
              }
              // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.
              let ret = unsafe { &*self.slice_head.add(self.num - (n + 1)).cast::<[T; N]>() };
              self.num -= n + 1;
              Some(ret)
          }
      *)
      Definition nth_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.le (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    M.read (| n |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::ArrayWindows",
                                          "num"
                                        |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |) in
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*const")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [] [ T ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ArrayWindows",
                                      "slice_head"
                                    |)
                                  |);
                                  BinOp.Wrap.sub (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |),
                                    BinOp.Wrap.add (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayWindows",
                          "num"
                        |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (|
                          M.read (| β |),
                          BinOp.Wrap.add (| M.read (| n |), Value.Integer IntegerKind.Usize 1 |)
                        |)
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| ret |) |) |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back N T));
            ("nth_back", InstanceField.Method (nth_back N T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayWindows_N_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayWindows_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ N ] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.num == 0
          }
      *)
      Definition is_empty
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::slice::iter::ArrayWindows",
                  "num"
                |)
              |),
              Value.Integer IntegerKind.Usize 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty N T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayWindows_N_T.
    
    (* StructRecord
      {
        name := "ArrayChunks";
        const_params := [ "N" ];
        ty_params := [ "T" ];
        fields :=
          [
            ("iter",
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (* Debug *)
      Definition fmt
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ArrayChunks" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "iter" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ArrayChunks",
                        "iter"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ArrayChunks",
                            "rem"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let (array_slice, rem) = slice.as_chunks();
              Self { iter: array_slice.iter(), rem }
          }
      *)
      Definition new
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "as_chunks",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let array_slice := M.copy (| γ0_0 |) in
                      let rem := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ArrayChunks"
                          [
                            ("iter",
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| array_slice |) |)
                                  |)
                                ]
                              |));
                            ("rem", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rem |) |) |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "new" (new N T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "core::slice::iter::ArrayChunks",
                "rem"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "remainder" (remainder N T).
      Smpl Add apply AssociatedFunction_remainder : is_associated.
    End Impl_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*
          fn clone(&self) -> Self {
              ArrayChunks { iter: self.iter.clone(), rem: self.rem }
          }
      *)
      Definition clone
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ArrayChunks"
              [
                ("iter",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayChunks",
                          "iter"
                        |)
                      |)
                    ]
                  |));
                ("rem",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::ArrayChunks",
                          "rem"
                        |)
                      |)
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("clone", InstanceField.Method (clone N T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*     type Item = &'a [T; N]; *)
      Definition _Item (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T; N]> {
              self.iter.next()
          }
      *)
      Definition next
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "next",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.iter.count()
          }
      *)
      Definition count
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "count",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth(n)
          }
      *)
      Definition nth
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "nth",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              self.iter.last()
          }
      *)
      Definition last
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "last",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a [T; N] {
              // SAFETY: The safety guarantees of `__iterator_get_unchecked` are
              // transferred to the caller.
              unsafe { self.iter.__iterator_get_unchecked(i) }
          }
      *)
      Definition __iterator_get_unchecked
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; i ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "__iterator_get_unchecked",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |);
                M.read (| i |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N T));
            ("next", InstanceField.Method (next N T));
            ("size_hint", InstanceField.Method (size_hint N T));
            ("count", InstanceField.Method (count N T));
            ("nth", InstanceField.Method (nth N T));
            ("last", InstanceField.Method (last N T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked N T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T; N]> {
              self.iter.next_back()
          }
      *)
      Definition next_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth_back(n)
          }
      *)
      Definition nth_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "nth_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back N T));
            ("nth_back", InstanceField.Method (nth_back N T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty N T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunks_N_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunks_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ N ] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (N : Value.t) (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self N T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT N T))
          ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunks_N_T.
    
    (* StructRecord
      {
        name := "ArrayChunksMut";
        const_params := [ "N" ];
        ty_params := [ "T" ];
        fields :=
          [
            ("iter",
              Ty.apply
                (Ty.path "core::slice::iter::IterMut")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (* Debug *)
      Definition fmt
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "ArrayChunksMut" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "iter" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::ArrayChunksMut",
                        "iter"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::ArrayChunksMut",
                            "rem"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T]) -> Self {
              let (array_slice, rem) = slice.as_chunks_mut();
              Self { iter: array_slice.iter_mut(), rem }
          }
      *)
      Definition new
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ];
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "as_chunks_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let array_slice := M.copy (| γ0_0 |) in
                      let rem := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ArrayChunksMut"
                          [
                            ("iter",
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| array_slice |) |)
                                  |)
                                ]
                              |));
                            ("rem",
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rem |) |) |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "new" (new N T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::slice::iter::ArrayChunksMut",
                        "rem"
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (N : Value.t) (T : Ty.t),
        M.IsAssociatedFunction (Self N T) "into_remainder" (into_remainder N T).
      Smpl Add apply AssociatedFunction_into_remainder : is_associated.
    End Impl_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (*     type Item = &'a mut [T; N]; *)
      Definition _Item (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T; N]> {
              self.iter.next()
          }
      *)
      Definition next
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "next",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.iter.count()
          }
      *)
      Definition count
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "count",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth(n)
          }
      *)
      Definition nth
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "nth",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              self.iter.last()
          }
      *)
      Definition last
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "last",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {
              // SAFETY: The safety guarantees of `__iterator_get_unchecked` are transferred to
              // the caller.
              unsafe { self.iter.__iterator_get_unchecked(i) }
          }
      *)
      Definition __iterator_get_unchecked
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; i ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::slice::iter::IterMut")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            [],
                            [],
                            "__iterator_get_unchecked",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ArrayChunksMut",
                                "iter"
                              |)
                            |);
                            M.read (| i |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N T));
            ("next", InstanceField.Method (next N T));
            ("size_hint", InstanceField.Method (size_hint N T));
            ("count", InstanceField.Method (count N T));
            ("nth", InstanceField.Method (nth N T));
            ("last", InstanceField.Method (last N T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked N T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T; N]> {
              self.iter.next_back()
          }
      *)
      Definition next_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth_back(n)
          }
      *)
      Definition nth_back
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "nth_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back N T));
            ("nth_back", InstanceField.Method (nth_back N T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                [],
                [],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty N T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunksMut_N_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunksMut_N_T.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ N ] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (N : Value.t) (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self N T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT N T))
          ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunksMut_N_T.
    
    (* StructRecord
      {
        name := "RChunks";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "RChunks" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunks",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunks",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::RChunks"
              [ ("v", M.read (| slice |)); ("chunk_size", M.read (| size |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RChunks_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              RChunks { v: self.v, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RChunks"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunks",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::RChunks",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let len = self.v.len();
                  let chunksz = cmp::min(len, self.chunk_size);
                  // SAFETY: split_at_unchecked just requires the argument be less
                  // than the length. This could only happen if the expression `len -
                  // chunksz` overflows. This could only happen if `chunksz > len`,
                  // which is impossible as we initialize it as the `min` of `len` and
                  // `self.chunk_size`.
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(len - chunksz) };
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ chunksz : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                            [
                              M.read (| len |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at_unchecked",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              BinOp.Wrap.sub (| M.read (| len |), M.read (| chunksz |) |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.div (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ n : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.gt (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  // Can't underflow because of the check above
                  let end = self.v.len() - end;
                  let start = match end.checked_sub(self.chunk_size) {
                      Some(sum) => sum,
                      None => 0,
                  };
                  let nth = &self.v[start..end];
                  self.v = &self.v[0..start];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::RChunks",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ : Ty.path "usize" :=
                                M.alloc (|
                                  BinOp.Wrap.sub (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::RChunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |),
                                    M.read (| end_ |)
                                  |)
                                |) in
                              let~ start : Ty.path "usize" :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_sub",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| end_ |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunks",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          sum));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                                    ]
                                  |)
                                |) in
                              let~ nth :
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::slice::iter::RChunks",
                                                  "v"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start", M.read (| start |));
                                              ("end_", M.read (| end_ |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::slice::iter::RChunks",
                                                        "v"
                                                      |)
                                                    |)
                                                  |)
                                                |);
                                                Value.StructRecord
                                                  "core::ops::range::Range"
                                                  [
                                                    ("start", Value.Integer IntegerKind.Usize 0);
                                                    ("end_", M.read (| start |))
                                                  ]
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let rem = self.v.len() % self.chunk_size;
                  let end = if rem == 0 { self.chunk_size } else { rem };
                  Some(&self.v[0..end])
              }
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.eq (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunks",
                                    "chunk_size"
                                  |)));
                              fun γ => ltac:(M.monadic rem)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::RChunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::Range"
                                          [
                                            ("start", Value.Integer IntegerKind.Usize 0);
                                            ("end_", M.read (| end_ |))
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = match end.checked_sub(self.chunk_size) {
                  None => 0,
                  Some(start) => start,
              };
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.sub (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunks",
                                "v"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |),
                    BinOp.Wrap.mul (|
                      M.read (| idx |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunks",
                          "chunk_size"
                        |)
                      |)
                    |)
                  |)
                |) in
              let~ start : Ty.path "usize" :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                        [
                          M.read (| end_ |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunks",
                              "chunk_size"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (| Value.Integer IntegerKind.Usize 0 |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let start := M.copy (| γ0_0 |) in
                          start))
                    ]
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |);
                            M.read (| start |)
                          ]
                        |);
                        BinOp.Wrap.sub (| M.read (| end_ |), M.read (| start |) |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let chunksz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: similar to Chunks::next_back
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(chunksz) };
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ chunksz : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.read (| remainder |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunks",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at_unchecked",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              M.read (| chunksz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunks",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  // can't underflow because `n < len`
                  let offset_from_end = (len - 1 - n) * self.chunk_size;
                  let end = self.v.len() - offset_from_end;
                  let start = end.saturating_sub(self.chunk_size);
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunks",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset_from_end : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunks",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (| offset_from_end |)
                          |)
                        |) in
                      let~ start : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.path "usize",
                              "saturating_sub",
                              [],
                              []
                            |),
                            [
                              M.read (| end_ |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ nth_back :
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunks",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunks",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::RChunks",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeFrom"
                                          [ ("start", M.read (| end_ |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth_back |) |) |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunks_T.
    
    (* StructRecord
      {
        name := "RChunksMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "&mut") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "RChunksMut" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksMut",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksMut",
                        "chunk_size"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "_marker" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksMut",
                            "_marker"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::RChunksMut"
              [
                ("v", M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| slice |) |) |));
                ("chunk_size", M.read (| size |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let sz = cmp::min(self.v.len(), self.chunk_size);
                  let len = self.v.len();
                  // SAFETY: split_at_mut_unchecked just requires the argument be less
                  // than the length. This could only happen if the expression
                  // `len - sz` overflows. This could only happen if `sz >
                  // len`, which is impossible as we initialize it as the `min` of
                  // `self.v.len()` (e.g. `len`) and `self.chunk_size`.
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ sz : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ len : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut_unchecked",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub (| M.read (| len |), M.read (| sz |) |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksMut",
                                      "v"
                                    |),
                                    M.read (| head |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| tail |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.div (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ n : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.gt (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  // Can't underflow because of the check above
                  let end = self.v.len() - end;
                  let start = match end.checked_sub(self.chunk_size) {
                      Some(sum) => sum,
                      None => 0,
                  };
                  // SAFETY: This type ensures that self.v is a valid pointer with a correct len.
                  // Therefore the bounds check in split_at_mut guarantees the split point is inbounds.
                  let (head, tail) = unsafe { self.v.split_at_mut(start) };
                  // SAFETY: This type ensures that self.v is a valid pointer with a correct len.
                  // Therefore the bounds check in split_at_mut guarantees the split point is inbounds.
                  let (nth, _) = unsafe { tail.split_at_mut(end - start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth })
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::RChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksMut",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ : Ty.path "usize" :=
                                M.alloc (|
                                  BinOp.Wrap.sub (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::RChunksMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |),
                                    M.read (| end_ |)
                                  |)
                                |) in
                              let~ start : Ty.path "usize" :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_sub",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| end_ |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksMut",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          sum));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let tail := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                              "split_at_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| tail |);
                                              BinOp.Wrap.sub (|
                                                M.read (| end_ |),
                                                M.read (| start |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let nth := M.copy (| γ0_0 |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.write (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::slice::iter::RChunksMut",
                                                      "v"
                                                    |),
                                                    M.read (| head |)
                                                  |)
                                                |) in
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (| M.read (| nth |) |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let rem = self.v.len() % self.chunk_size;
                  let end = if rem == 0 { self.chunk_size } else { rem };
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })
              }
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ rem : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.eq (|
                                          M.read (| rem |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "chunk_size"
                                  |)));
                              fun γ => ltac:(M.monadic rem)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "get_unchecked_mut",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ]
                                            ]
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "core::slice::iter::RChunksMut",
                                                "v"
                                              |)
                                            |);
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", Value.Integer IntegerKind.Usize 0);
                                                ("end_", M.read (| end_ |))
                                              ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = match end.checked_sub(self.chunk_size) {
                  None => 0,
                  Some(start) => start,
              };
              // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and
              // `ChunksMut::__iterator_get_unchecked`, `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ end_ : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.sub (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            "len",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksMut",
                                "v"
                              |)
                            |)
                          ]
                        |),
                        BinOp.Wrap.mul (|
                          M.read (| idx |),
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksMut",
                              "chunk_size"
                            |)
                          |)
                        |)
                      |)
                    |) in
                  let~ start : Ty.path "usize" :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                            [
                              M.read (| end_ |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.alloc (| Value.Integer IntegerKind.Usize 0 |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let start := M.copy (| γ0_0 |) in
                              start))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.get_function (|
                                "core::slice::raw::from_raw_parts_mut",
                                [],
                                [ T ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "as_mut_ptr",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::RChunksMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| start |)
                                  ]
                                |);
                                BinOp.Wrap.sub (| M.read (| end_ |), M.read (| start |) |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let sz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: Similar to `Chunks::next_back`
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ sz : Ty.path "usize" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.read (| remainder |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut_unchecked",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| sz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksMut",
                                      "v"
                                    |),
                                    M.read (| tail |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| head |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  // can't underflow because `n < len`
                  let offset_from_end = (len - 1 - n) * self.chunk_size;
                  let end = self.v.len() - offset_from_end;
                  let start = end.saturating_sub(self.chunk_size);
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (tmp, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth_back) = unsafe { tmp.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksMut",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.MutPointer,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset_from_end : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (|
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.read (| n |)
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (| offset_from_end |)
                          |)
                        |) in
                      let~ start : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.path "usize",
                              "saturating_sub",
                              [],
                              []
                            |),
                            [
                              M.read (| end_ |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let tmp := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [ M.read (| tmp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksMut",
                                              "v"
                                            |),
                                            M.read (| tail |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| nth_back |) |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksMut_T.
    
    (* StructRecord
      {
        name := "RChunksExact";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "RChunksExact" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExact",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExact",
                        "rem"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksExact",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              // SAFETY: 0 <= rem <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_unchecked(rem) };
              Self { v: snd, rem: fst, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.rem (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| chunk_size |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "split_at_unchecked",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                      M.read (| rem |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::RChunksExact"
                          [
                            ("v", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |));
                            ("rem",
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "core::slice::iter::RChunksExact",
                "rem"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "remainder" (remainder T).
      Smpl Add apply AssociatedFunction_remainder : is_associated.
    End Impl_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*
          fn clone(&self) -> RChunksExact<'a, T> {
              RChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RChunksExact"
              [
                ("v",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksExact",
                          "v"
                        |)
                      |)
                    |)
                  |));
                ("rem",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksExact",
                          "rem"
                        |)
                      |)
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::slice::iter::RChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::RChunksExact",
                                            "v"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksExact",
                                    "chunk_size"
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.div (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExact",
                                "v"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExact",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let (fst, _) = self.v.split_at(self.v.len() - end);
                  self.v = fst;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksExact",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::RChunksExact",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "split_at",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksExact",
                                              "v"
                                            |)
                                          |)
                                        |)
                                      |);
                                      BinOp.Wrap.sub (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::iter::RChunksExact",
                                                    "v"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |),
                                        M.read (| end_ |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let fst := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksExact",
                                              "v"
                                            |),
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| fst |) |)
                                            |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::RChunksExact")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = end - self.chunk_size;
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.sub (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExact",
                                "v"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |),
                    BinOp.Wrap.mul (|
                      M.read (| idx |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksExact",
                          "chunk_size"
                        |)
                      |)
                    |)
                  |)
                |) in
              let~ start : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.sub (|
                    M.read (| end_ |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExact",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      M.get_function (| "core::slice::raw::from_raw_parts", [], [ T ] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ T ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunksExact",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |);
                            M.read (| start |)
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksExact",
                            "chunk_size"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.chunk_size);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |)
                                  |)
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| snd |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fst |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  // now that we know that `n` corresponds to a chunk,
                  // none of these operations can underflow/overflow
                  let offset = (len - n) * self.chunk_size;
                  let start = self.v.len() - offset;
                  let end = start + self.chunk_size;
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksExact",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (| M.read (| len |), M.read (| n |) |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExact",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::RChunksExact",
                                        "v"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (| offset |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.add (|
                            M.read (| start |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExact",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ nth_back :
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksExact",
                                          "v"
                                        |)
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksExact",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::RChunksExact",
                                                "v"
                                              |)
                                            |)
                                          |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeFrom"
                                          [ ("start", M.read (| end_ |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| nth_back |) |) |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ T ],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExact",
                        "v"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExact_T.
    
    (* StructRecord
      {
        name := "RChunksExactMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "RChunksExactMut" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "v" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExactMut",
                        "v"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "rem" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExactMut",
                        "rem"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "chunk_size" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksExactMut",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              // SAFETY: 0 <= rem <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_mut_unchecked(rem) };
              Self { v: snd, rem: fst, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.rem (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |),
                    M.read (| chunk_size |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "split_at_mut_unchecked",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |);
                      M.read (| rem |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::RChunksExactMut"
                          [
                            ("v",
                              M.borrow (|
                                Pointer.Kind.MutPointer,
                                M.deref (| M.read (| snd |) |)
                              |));
                            ("rem",
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fst |) |) |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::slice::iter::RChunksExactMut",
                        "rem"
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_remainder" (into_remainder T).
      Smpl Add apply AssociatedFunction_into_remainder : is_associated.
    End Impl_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let len = self.v.len();
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.read (| len |),
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksExactMut",
                                    "chunk_size"
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |),
                                    M.read (| head |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| tail |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n : Ty.path "usize" :=
                M.alloc (|
                  BinOp.Wrap.div (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksExactMut",
                            "v"
                          |)
                        |)
                      ]
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::iter::RChunksExactMut",
                        "chunk_size"
                      |)
                    |)
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ],
                [],
                [],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  let len = self.v.len();
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (fst, _) = unsafe { self.v.split_at_mut(len - end) };
                  self.v = fst;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "usize"; Ty.path "bool" ],
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [], [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::slice::iter::RChunksExactMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ge (|
                                        M.read (| end_ |),
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::iter::RChunksExactMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (| Value.Array [] |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ len : Ty.path "usize" :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksExactMut",
                                          "v"
                                        |)
                                      |)
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::slice::iter::RChunksExactMut",
                                          "v"
                                        |)
                                      |);
                                      BinOp.Wrap.sub (| M.read (| len |), M.read (| end_ |) |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let fst := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksExactMut",
                                              "v"
                                            |),
                                            M.read (| fst |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::RChunksExactMut")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = end - self.chunk_size;
              // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ end_ : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.sub (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            "len",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExactMut",
                                "v"
                              |)
                            |)
                          ]
                        |),
                        BinOp.Wrap.mul (|
                          M.read (| idx |),
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksExactMut",
                              "chunk_size"
                            |)
                          |)
                        |)
                      |)
                    |) in
                  let~ start : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.sub (|
                        M.read (| end_ |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::iter::RChunksExactMut",
                            "chunk_size"
                          |)
                        |)
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.get_function (|
                                "core::slice::raw::from_raw_parts_mut",
                                [],
                                [ T ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        "as_mut_ptr",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::RChunksExactMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| start |)
                                  ]
                                |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksExactMut",
                                    "chunk_size"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.lt (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |),
                                    M.read (| tail |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| head |) |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  // now that we know that `n` corresponds to a chunk,
                  // none of these operations can underflow/overflow
                  let offset = (len - n) * self.chunk_size;
                  let start = self.v.len() - offset;
                  let end = start + self.chunk_size;
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (tmp, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth_back) = unsafe { tmp.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ] ],
                      [],
                      [],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.ge (| M.read (| n |), M.read (| len |) |) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::iter::RChunksExactMut",
                              "v"
                            |),
                            M.borrow (|
                              Pointer.Kind.MutPointer,
                              M.deref (|
                                M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.mul (|
                            BinOp.Wrap.sub (| M.read (| len |), M.read (| n |) |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExactMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      let~ start : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::slice::iter::RChunksExactMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |),
                            M.read (| offset |)
                          |)
                        |) in
                      let~ end_ : Ty.path "usize" :=
                        M.alloc (|
                          BinOp.Wrap.add (|
                            M.read (| start |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::RChunksExactMut",
                                "chunk_size"
                              |)
                            |)
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let tmp := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      "split_at_mut",
                                      [],
                                      []
                                    |),
                                    [ M.read (| tmp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::slice::iter::RChunksExactMut",
                                              "v"
                                            |),
                                            M.read (| tail |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| nth_back |) |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                "is_empty",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::slice::iter::RChunksExactMut",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Iter_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Iter_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_IterMut_T.
    
    (* StructRecord
      {
        name := "ChunkBy";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("slice", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("predicate", P)
          ];
      } *)
    
    Module Impl_core_slice_iter_ChunkBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], predicate: P) -> Self {
              ChunkBy { slice, predicate }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; predicate ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let predicate := M.alloc (| predicate |) in
            Value.StructRecord
              "core::slice::iter::ChunkBy"
              [
                ("slice", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |));
                ("predicate", M.read (| predicate |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_ChunkBy_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let (head, tail) = self.slice.split_at(len);
                  self.slice = tail;
                  Some(head)
              }
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkBy",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |) in
                      let~ iter : Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "windows",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Windows")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, iter |) ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [],
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [] [ T ];
                                                            Ty.apply (Ty.path "&") [] [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::ChunkBy",
                                                          "predicate"
                                                        |)
                                                      |);
                                                      Value.Tuple
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| l |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| r |) |)
                                                          |)
                                                        ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              let β := len in
                                              M.write (|
                                                β,
                                                BinOp.Wrap.add (|
                                                  M.read (| β |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              M.read (| len |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| tail |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| head |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkBy",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunkBy",
                                            "slice"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P));
            ("last", InstanceField.Method (last T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next_back() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let (head, tail) = self.slice.split_at(self.slice.len() - len);
                  self.slice = head;
                  Some(tail)
              }
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkBy",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |) in
                      let~ iter : Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "windows",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::double_ended::DoubleEndedIterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Windows")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next_back",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, iter |) ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [],
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [] [ T ];
                                                            Ty.apply (Ty.path "&") [] [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::ChunkBy",
                                                          "predicate"
                                                        |)
                                                      |);
                                                      Value.Tuple
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| l |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| r |) |)
                                                          |)
                                                        ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              let β := len in
                                              M.write (|
                                                β,
                                                BinOp.Wrap.add (|
                                                  M.read (| β |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunkBy",
                                            "slice"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                M.read (| len |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkBy",
                                      "slice"
                                    |),
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| head |) |) |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| tail |) |) |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkBy_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunkBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkBy") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("ChunkBy").field("slice", &self.slice).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "ChunkBy" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "slice" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunkBy",
                                "slice"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunkBy_T_P.
    
    (* StructRecord
      {
        name := "ChunkByMut";
        const_params := [];
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("slice", Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]);
            ("predicate", P)
          ];
      } *)
    
    Module Impl_core_slice_iter_ChunkByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {
              ChunkByMut { slice, predicate }
          }
      *)
      Definition new (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ slice; predicate ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let predicate := M.alloc (| predicate |) in
            Value.StructRecord
              "core::slice::iter::ChunkByMut"
              [
                ("slice", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |));
                ("predicate", M.read (| predicate |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      Smpl Add apply AssociatedFunction_new : is_associated.
    End Impl_core_slice_iter_ChunkByMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let slice = mem::take(&mut self.slice);
                  let (head, tail) = slice.split_at_mut(len);
                  self.slice = tail;
                  Some(head)
              }
          }
      *)
      Definition next (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkByMut",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |) in
                      let~ iter : Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "windows",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Windows")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, iter |) ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [],
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [] [ T ];
                                                            Ty.apply (Ty.path "&") [] [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::ChunkByMut",
                                                          "predicate"
                                                        |)
                                                      |);
                                                      Value.Tuple
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| l |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| r |) |)
                                                          |)
                                                        ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              let β := len in
                                              M.write (|
                                                β,
                                                BinOp.Wrap.add (|
                                                  M.read (| β |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      let~ slice :
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            M.get_function (|
                              "core::mem::take",
                              [],
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |);
                              M.read (| len |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| tail |) |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| head |) |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }
          }
      *)
      Definition size_hint (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkByMut",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::slice::iter::ChunkByMut",
                                            "slice"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P));
            ("last", InstanceField.Method (last T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next_back() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let slice = mem::take(&mut self.slice);
                  let (head, tail) = slice.split_at_mut(slice.len() - len);
                  self.slice = head;
                  Some(tail)
              }
          }
      *)
      Definition next_back (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::slice::iter::ChunkByMut",
                                        "slice"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |) in
                      let~ iter : Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "windows",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::double_ended::DoubleEndedIterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Windows")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next_back",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, iter |) ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [],
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [] [ T ];
                                                            Ty.apply (Ty.path "&") [] [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "core::slice::iter::ChunkByMut",
                                                          "predicate"
                                                        |)
                                                      |);
                                                      Value.Tuple
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| l |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| r |) |)
                                                          |)
                                                        ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              let β := len in
                                              M.write (|
                                                β,
                                                BinOp.Wrap.add (|
                                                  M.read (| β |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      let~ slice :
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            M.get_function (|
                              "core::mem::take",
                              [],
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "split_at_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |);
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| slice |) |)
                                    |)
                                  ]
                                |),
                                M.read (| len |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::slice::iter::ChunkByMut",
                                      "slice"
                                    |),
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| head |) |)
                                    |)
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| tail |) |)
                                    |)
                                  ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_ChunkByMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunkByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunkByMut") [] [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("ChunkByMut").field("slice", &self.slice).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "ChunkByMut" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "slice" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::iter::ChunkByMut",
                                "slice"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T P)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunkByMut_T_P.
  End iter.
End slice.
